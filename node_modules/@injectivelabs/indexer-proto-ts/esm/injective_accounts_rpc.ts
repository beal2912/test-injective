/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "injective_accounts_rpc";

export interface PortfolioRequest {
  /** Account address */
  accountAddress: string;
}

export interface PortfolioResponse {
  /** The portfolio of this account */
  portfolio: AccountPortfolio | undefined;
}

export interface AccountPortfolio {
  /** The account's portfolio value in USD. */
  portfolioValue: string;
  /** The account's available balance value in USD. */
  availableBalance: string;
  /** The account's locked balance value in USD. */
  lockedBalance: string;
  /** The account's total unrealized PnL value in USD. */
  unrealizedPnl: string;
  /** List of all subaccounts' portfolio */
  subaccounts: SubaccountPortfolio[];
}

export interface SubaccountPortfolio {
  /** The ID of this subaccount */
  subaccountId: string;
  /** The subaccount's available balance value in USD. */
  availableBalance: string;
  /** The subaccount's locked balance value in USD. */
  lockedBalance: string;
  /** The subaccount's total unrealized PnL value in USD. */
  unrealizedPnl: string;
}

export interface OrderStatesRequest {
  spotOrderHashes: string[];
  derivativeOrderHashes: string[];
}

export interface OrderStatesResponse {
  /** List of the spot order state records */
  spotOrderStates: OrderStateRecord[];
  /** List of the derivative order state records */
  derivativeOrderStates: OrderStateRecord[];
}

export interface OrderStateRecord {
  /** Hash of the order */
  orderHash: string;
  /** The subaccountId that this order belongs to */
  subaccountId: string;
  /** The Market ID of the order */
  marketId: string;
  /** The type of the order */
  orderType: string;
  /** The side of the order */
  orderSide: string;
  /** The state (status) of the order */
  state: string;
  /** The filled quantity of the order */
  quantityFilled: string;
  /** The filled quantity of the order */
  quantityRemaining: string;
  /** Order committed timestamp in UNIX millis. */
  createdAt: string;
  /** Order updated timestamp in UNIX millis. */
  updatedAt: string;
}

export interface SubaccountsListRequest {
  /** Account address, the subaccounts owner */
  accountAddress: string;
}

export interface SubaccountsListResponse {
  subaccounts: string[];
}

export interface SubaccountBalancesListRequest {
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /**
   * Filter balances by denoms. If not set, the balances of all the denoms for
   * the subaccount are provided.
   */
  denoms: string[];
}

export interface SubaccountBalancesListResponse {
  /** List of subaccount balances */
  balances: SubaccountBalance[];
}

export interface SubaccountBalance {
  /** Related subaccount ID */
  subaccountId: string;
  /** Account address, owner of this subaccount */
  accountAddress: string;
  /** Coin denom on the chain. */
  denom: string;
  deposit: SubaccountDeposit | undefined;
}

export interface SubaccountDeposit {
  totalBalance: string;
  availableBalance: string;
}

export interface SubaccountBalanceEndpointRequest {
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Specify denom to get balance */
  denom: string;
}

export interface SubaccountBalanceEndpointResponse {
  /** Subaccount balance */
  balance: SubaccountBalance | undefined;
}

export interface StreamSubaccountBalanceRequest {
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /**
   * Filter balances by denoms. If not set, the balances of all the denoms for
   * the subaccount are provided.
   */
  denoms: string[];
}

export interface StreamSubaccountBalanceResponse {
  /** Subaccount balance */
  balance:
    | SubaccountBalance
    | undefined;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface SubaccountHistoryRequest {
  /** SubaccountId of the trader we want to get the history from */
  subaccountId: string;
  /** Filter history by denom */
  denom: string;
  /** Filter history by transfer type */
  transferTypes: string[];
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /** Upper bound of account transfer history's executedAt */
  endTime: string;
}

export interface SubaccountHistoryResponse {
  /** List of subaccount transfers */
  transfers: SubaccountBalanceTransfer[];
  paging: Paging | undefined;
}

export interface SubaccountBalanceTransfer {
  /** Type of the subaccount balance transfer */
  transferType: string;
  /** Subaccount ID of the sending side */
  srcSubaccountId: string;
  /** Account address of the sending side */
  srcAccountAddress: string;
  /** Subaccount ID of the receiving side */
  dstSubaccountId: string;
  /** Account address of the receiving side */
  dstAccountAddress: string;
  /** Coin amount of the transfer */
  amount:
    | CosmosCoin
    | undefined;
  /** Timestamp of the transfer in UNIX millis */
  executedAt: string;
}

export interface CosmosCoin {
  /** Coin denominator */
  denom: string;
  /** Coin amount (big int) */
  amount: string;
}

/** Paging defines the structure for required params for handling pagination */
export interface Paging {
  /** total number of txs saved in database */
  total: string;
  /** can be either block height or index num */
  from: number;
  /** can be either block height or index num */
  to: number;
  /** count entries by subaccount, serving some places on helix */
  countBySubaccount: string;
}

export interface SubaccountOrderSummaryRequest {
  /** SubaccountId of the trader we want to get the summary from */
  subaccountId: string;
  /** MarketId is limiting order summary to specific market only */
  marketId: string;
  /** Filter by direction of the orders */
  orderDirection: string;
}

export interface SubaccountOrderSummaryResponse {
  /** Total count of subaccount's spot orders in given market and direction */
  spotOrdersTotal: string;
  /** Total count of subaccount's derivative orders in given market and direction */
  derivativeOrdersTotal: string;
}

export interface RewardsRequest {
  /** The distribution epoch sequence number. -1 for latest. */
  epoch: string;
  /** Account address for the rewards distribution */
  accountAddress: string;
}

export interface RewardsResponse {
  /** The trading rewards distributed */
  rewards: Reward[];
}

export interface Reward {
  /** Account address */
  accountAddress: string;
  /** Reward coins distributed */
  rewards: Coin[];
  /** Rewards distribution timestamp in UNIX millis. */
  distributedAt: string;
}

export interface Coin {
  /** Denom of the coin */
  denom: string;
  amount: string;
}

function createBasePortfolioRequest(): PortfolioRequest {
  return { accountAddress: "" };
}

export const PortfolioRequest = {
  encode(message: PortfolioRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortfolioRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortfolioRequest {
    return { accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "" };
  },

  toJSON(message: PortfolioRequest): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    return obj;
  },

  create(base?: DeepPartial<PortfolioRequest>): PortfolioRequest {
    return PortfolioRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PortfolioRequest>): PortfolioRequest {
    const message = createBasePortfolioRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBasePortfolioResponse(): PortfolioResponse {
  return { portfolio: undefined };
}

export const PortfolioResponse = {
  encode(message: PortfolioResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.portfolio !== undefined) {
      AccountPortfolio.encode(message.portfolio, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortfolioResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.portfolio = AccountPortfolio.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortfolioResponse {
    return { portfolio: isSet(object.portfolio) ? AccountPortfolio.fromJSON(object.portfolio) : undefined };
  },

  toJSON(message: PortfolioResponse): unknown {
    const obj: any = {};
    message.portfolio !== undefined &&
      (obj.portfolio = message.portfolio ? AccountPortfolio.toJSON(message.portfolio) : undefined);
    return obj;
  },

  create(base?: DeepPartial<PortfolioResponse>): PortfolioResponse {
    return PortfolioResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PortfolioResponse>): PortfolioResponse {
    const message = createBasePortfolioResponse();
    message.portfolio = (object.portfolio !== undefined && object.portfolio !== null)
      ? AccountPortfolio.fromPartial(object.portfolio)
      : undefined;
    return message;
  },
};

function createBaseAccountPortfolio(): AccountPortfolio {
  return { portfolioValue: "", availableBalance: "", lockedBalance: "", unrealizedPnl: "", subaccounts: [] };
}

export const AccountPortfolio = {
  encode(message: AccountPortfolio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.portfolioValue !== "") {
      writer.uint32(10).string(message.portfolioValue);
    }
    if (message.availableBalance !== "") {
      writer.uint32(18).string(message.availableBalance);
    }
    if (message.lockedBalance !== "") {
      writer.uint32(26).string(message.lockedBalance);
    }
    if (message.unrealizedPnl !== "") {
      writer.uint32(34).string(message.unrealizedPnl);
    }
    for (const v of message.subaccounts) {
      SubaccountPortfolio.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountPortfolio {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPortfolio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.portfolioValue = reader.string();
          break;
        case 2:
          message.availableBalance = reader.string();
          break;
        case 3:
          message.lockedBalance = reader.string();
          break;
        case 4:
          message.unrealizedPnl = reader.string();
          break;
        case 5:
          message.subaccounts.push(SubaccountPortfolio.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccountPortfolio {
    return {
      portfolioValue: isSet(object.portfolioValue) ? String(object.portfolioValue) : "",
      availableBalance: isSet(object.availableBalance) ? String(object.availableBalance) : "",
      lockedBalance: isSet(object.lockedBalance) ? String(object.lockedBalance) : "",
      unrealizedPnl: isSet(object.unrealizedPnl) ? String(object.unrealizedPnl) : "",
      subaccounts: Array.isArray(object?.subaccounts)
        ? object.subaccounts.map((e: any) => SubaccountPortfolio.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountPortfolio): unknown {
    const obj: any = {};
    message.portfolioValue !== undefined && (obj.portfolioValue = message.portfolioValue);
    message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
    message.lockedBalance !== undefined && (obj.lockedBalance = message.lockedBalance);
    message.unrealizedPnl !== undefined && (obj.unrealizedPnl = message.unrealizedPnl);
    if (message.subaccounts) {
      obj.subaccounts = message.subaccounts.map((e) => e ? SubaccountPortfolio.toJSON(e) : undefined);
    } else {
      obj.subaccounts = [];
    }
    return obj;
  },

  create(base?: DeepPartial<AccountPortfolio>): AccountPortfolio {
    return AccountPortfolio.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AccountPortfolio>): AccountPortfolio {
    const message = createBaseAccountPortfolio();
    message.portfolioValue = object.portfolioValue ?? "";
    message.availableBalance = object.availableBalance ?? "";
    message.lockedBalance = object.lockedBalance ?? "";
    message.unrealizedPnl = object.unrealizedPnl ?? "";
    message.subaccounts = object.subaccounts?.map((e) => SubaccountPortfolio.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubaccountPortfolio(): SubaccountPortfolio {
  return { subaccountId: "", availableBalance: "", lockedBalance: "", unrealizedPnl: "" };
}

export const SubaccountPortfolio = {
  encode(message: SubaccountPortfolio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.availableBalance !== "") {
      writer.uint32(18).string(message.availableBalance);
    }
    if (message.lockedBalance !== "") {
      writer.uint32(26).string(message.lockedBalance);
    }
    if (message.unrealizedPnl !== "") {
      writer.uint32(34).string(message.unrealizedPnl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountPortfolio {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountPortfolio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.availableBalance = reader.string();
          break;
        case 3:
          message.lockedBalance = reader.string();
          break;
        case 4:
          message.unrealizedPnl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountPortfolio {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      availableBalance: isSet(object.availableBalance) ? String(object.availableBalance) : "",
      lockedBalance: isSet(object.lockedBalance) ? String(object.lockedBalance) : "",
      unrealizedPnl: isSet(object.unrealizedPnl) ? String(object.unrealizedPnl) : "",
    };
  },

  toJSON(message: SubaccountPortfolio): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
    message.lockedBalance !== undefined && (obj.lockedBalance = message.lockedBalance);
    message.unrealizedPnl !== undefined && (obj.unrealizedPnl = message.unrealizedPnl);
    return obj;
  },

  create(base?: DeepPartial<SubaccountPortfolio>): SubaccountPortfolio {
    return SubaccountPortfolio.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountPortfolio>): SubaccountPortfolio {
    const message = createBaseSubaccountPortfolio();
    message.subaccountId = object.subaccountId ?? "";
    message.availableBalance = object.availableBalance ?? "";
    message.lockedBalance = object.lockedBalance ?? "";
    message.unrealizedPnl = object.unrealizedPnl ?? "";
    return message;
  },
};

function createBaseOrderStatesRequest(): OrderStatesRequest {
  return { spotOrderHashes: [], derivativeOrderHashes: [] };
}

export const OrderStatesRequest = {
  encode(message: OrderStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.spotOrderHashes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.derivativeOrderHashes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spotOrderHashes.push(reader.string());
          break;
        case 2:
          message.derivativeOrderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderStatesRequest {
    return {
      spotOrderHashes: Array.isArray(object?.spotOrderHashes) ? object.spotOrderHashes.map((e: any) => String(e)) : [],
      derivativeOrderHashes: Array.isArray(object?.derivativeOrderHashes)
        ? object.derivativeOrderHashes.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: OrderStatesRequest): unknown {
    const obj: any = {};
    if (message.spotOrderHashes) {
      obj.spotOrderHashes = message.spotOrderHashes.map((e) => e);
    } else {
      obj.spotOrderHashes = [];
    }
    if (message.derivativeOrderHashes) {
      obj.derivativeOrderHashes = message.derivativeOrderHashes.map((e) => e);
    } else {
      obj.derivativeOrderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderStatesRequest>): OrderStatesRequest {
    return OrderStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderStatesRequest>): OrderStatesRequest {
    const message = createBaseOrderStatesRequest();
    message.spotOrderHashes = object.spotOrderHashes?.map((e) => e) || [];
    message.derivativeOrderHashes = object.derivativeOrderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderStatesResponse(): OrderStatesResponse {
  return { spotOrderStates: [], derivativeOrderStates: [] };
}

export const OrderStatesResponse = {
  encode(message: OrderStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.spotOrderStates) {
      OrderStateRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.derivativeOrderStates) {
      OrderStateRecord.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spotOrderStates.push(OrderStateRecord.decode(reader, reader.uint32()));
          break;
        case 2:
          message.derivativeOrderStates.push(OrderStateRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderStatesResponse {
    return {
      spotOrderStates: Array.isArray(object?.spotOrderStates)
        ? object.spotOrderStates.map((e: any) => OrderStateRecord.fromJSON(e))
        : [],
      derivativeOrderStates: Array.isArray(object?.derivativeOrderStates)
        ? object.derivativeOrderStates.map((e: any) => OrderStateRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderStatesResponse): unknown {
    const obj: any = {};
    if (message.spotOrderStates) {
      obj.spotOrderStates = message.spotOrderStates.map((e) => e ? OrderStateRecord.toJSON(e) : undefined);
    } else {
      obj.spotOrderStates = [];
    }
    if (message.derivativeOrderStates) {
      obj.derivativeOrderStates = message.derivativeOrderStates.map((e) => e ? OrderStateRecord.toJSON(e) : undefined);
    } else {
      obj.derivativeOrderStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderStatesResponse>): OrderStatesResponse {
    return OrderStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderStatesResponse>): OrderStatesResponse {
    const message = createBaseOrderStatesResponse();
    message.spotOrderStates = object.spotOrderStates?.map((e) => OrderStateRecord.fromPartial(e)) || [];
    message.derivativeOrderStates = object.derivativeOrderStates?.map((e) => OrderStateRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderStateRecord(): OrderStateRecord {
  return {
    orderHash: "",
    subaccountId: "",
    marketId: "",
    orderType: "",
    orderSide: "",
    state: "",
    quantityFilled: "",
    quantityRemaining: "",
    createdAt: "0",
    updatedAt: "0",
  };
}

export const OrderStateRecord = {
  encode(message: OrderStateRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.orderType !== "") {
      writer.uint32(34).string(message.orderType);
    }
    if (message.orderSide !== "") {
      writer.uint32(42).string(message.orderSide);
    }
    if (message.state !== "") {
      writer.uint32(50).string(message.state);
    }
    if (message.quantityFilled !== "") {
      writer.uint32(58).string(message.quantityFilled);
    }
    if (message.quantityRemaining !== "") {
      writer.uint32(66).string(message.quantityRemaining);
    }
    if (message.createdAt !== "0") {
      writer.uint32(72).sint64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(80).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderStateRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStateRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.orderType = reader.string();
          break;
        case 5:
          message.orderSide = reader.string();
          break;
        case 6:
          message.state = reader.string();
          break;
        case 7:
          message.quantityFilled = reader.string();
          break;
        case 8:
          message.quantityRemaining = reader.string();
          break;
        case 9:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        case 10:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderStateRecord {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      state: isSet(object.state) ? String(object.state) : "",
      quantityFilled: isSet(object.quantityFilled) ? String(object.quantityFilled) : "",
      quantityRemaining: isSet(object.quantityRemaining) ? String(object.quantityRemaining) : "",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: OrderStateRecord): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.state !== undefined && (obj.state = message.state);
    message.quantityFilled !== undefined && (obj.quantityFilled = message.quantityFilled);
    message.quantityRemaining !== undefined && (obj.quantityRemaining = message.quantityRemaining);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<OrderStateRecord>): OrderStateRecord {
    return OrderStateRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderStateRecord>): OrderStateRecord {
    const message = createBaseOrderStateRecord();
    message.orderHash = object.orderHash ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.orderType = object.orderType ?? "";
    message.orderSide = object.orderSide ?? "";
    message.state = object.state ?? "";
    message.quantityFilled = object.quantityFilled ?? "";
    message.quantityRemaining = object.quantityRemaining ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBaseSubaccountsListRequest(): SubaccountsListRequest {
  return { accountAddress: "" };
}

export const SubaccountsListRequest = {
  encode(message: SubaccountsListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountsListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountsListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountsListRequest {
    return { accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "" };
  },

  toJSON(message: SubaccountsListRequest): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    return obj;
  },

  create(base?: DeepPartial<SubaccountsListRequest>): SubaccountsListRequest {
    return SubaccountsListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountsListRequest>): SubaccountsListRequest {
    const message = createBaseSubaccountsListRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseSubaccountsListResponse(): SubaccountsListResponse {
  return { subaccounts: [] };
}

export const SubaccountsListResponse = {
  encode(message: SubaccountsListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subaccounts) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountsListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountsListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccounts.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountsListResponse {
    return { subaccounts: Array.isArray(object?.subaccounts) ? object.subaccounts.map((e: any) => String(e)) : [] };
  },

  toJSON(message: SubaccountsListResponse): unknown {
    const obj: any = {};
    if (message.subaccounts) {
      obj.subaccounts = message.subaccounts.map((e) => e);
    } else {
      obj.subaccounts = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountsListResponse>): SubaccountsListResponse {
    return SubaccountsListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountsListResponse>): SubaccountsListResponse {
    const message = createBaseSubaccountsListResponse();
    message.subaccounts = object.subaccounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubaccountBalancesListRequest(): SubaccountBalancesListRequest {
  return { subaccountId: "", denoms: [] };
}

export const SubaccountBalancesListRequest = {
  encode(message: SubaccountBalancesListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    for (const v of message.denoms) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalancesListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalancesListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denoms.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalancesListRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denoms: Array.isArray(object?.denoms) ? object.denoms.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: SubaccountBalancesListRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.denoms) {
      obj.denoms = message.denoms.map((e) => e);
    } else {
      obj.denoms = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalancesListRequest>): SubaccountBalancesListRequest {
    return SubaccountBalancesListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalancesListRequest>): SubaccountBalancesListRequest {
    const message = createBaseSubaccountBalancesListRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.denoms = object.denoms?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubaccountBalancesListResponse(): SubaccountBalancesListResponse {
  return { balances: [] };
}

export const SubaccountBalancesListResponse = {
  encode(message: SubaccountBalancesListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      SubaccountBalance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalancesListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalancesListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balances.push(SubaccountBalance.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalancesListResponse {
    return {
      balances: Array.isArray(object?.balances) ? object.balances.map((e: any) => SubaccountBalance.fromJSON(e)) : [],
    };
  },

  toJSON(message: SubaccountBalancesListResponse): unknown {
    const obj: any = {};
    if (message.balances) {
      obj.balances = message.balances.map((e) => e ? SubaccountBalance.toJSON(e) : undefined);
    } else {
      obj.balances = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalancesListResponse>): SubaccountBalancesListResponse {
    return SubaccountBalancesListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalancesListResponse>): SubaccountBalancesListResponse {
    const message = createBaseSubaccountBalancesListResponse();
    message.balances = object.balances?.map((e) => SubaccountBalance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubaccountBalance(): SubaccountBalance {
  return { subaccountId: "", accountAddress: "", denom: "", deposit: undefined };
}

export const SubaccountBalance = {
  encode(message: SubaccountBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.denom !== "") {
      writer.uint32(26).string(message.denom);
    }
    if (message.deposit !== undefined) {
      SubaccountDeposit.encode(message.deposit, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalance {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.accountAddress = reader.string();
          break;
        case 3:
          message.denom = reader.string();
          break;
        case 4:
          message.deposit = SubaccountDeposit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalance {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      deposit: isSet(object.deposit) ? SubaccountDeposit.fromJSON(object.deposit) : undefined,
    };
  },

  toJSON(message: SubaccountBalance): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    message.denom !== undefined && (obj.denom = message.denom);
    message.deposit !== undefined &&
      (obj.deposit = message.deposit ? SubaccountDeposit.toJSON(message.deposit) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalance>): SubaccountBalance {
    return SubaccountBalance.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalance>): SubaccountBalance {
    const message = createBaseSubaccountBalance();
    message.subaccountId = object.subaccountId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.denom = object.denom ?? "";
    message.deposit = (object.deposit !== undefined && object.deposit !== null)
      ? SubaccountDeposit.fromPartial(object.deposit)
      : undefined;
    return message;
  },
};

function createBaseSubaccountDeposit(): SubaccountDeposit {
  return { totalBalance: "", availableBalance: "" };
}

export const SubaccountDeposit = {
  encode(message: SubaccountDeposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalBalance !== "") {
      writer.uint32(10).string(message.totalBalance);
    }
    if (message.availableBalance !== "") {
      writer.uint32(18).string(message.availableBalance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountDeposit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.totalBalance = reader.string();
          break;
        case 2:
          message.availableBalance = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountDeposit {
    return {
      totalBalance: isSet(object.totalBalance) ? String(object.totalBalance) : "",
      availableBalance: isSet(object.availableBalance) ? String(object.availableBalance) : "",
    };
  },

  toJSON(message: SubaccountDeposit): unknown {
    const obj: any = {};
    message.totalBalance !== undefined && (obj.totalBalance = message.totalBalance);
    message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
    return obj;
  },

  create(base?: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    return SubaccountDeposit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    const message = createBaseSubaccountDeposit();
    message.totalBalance = object.totalBalance ?? "";
    message.availableBalance = object.availableBalance ?? "";
    return message;
  },
};

function createBaseSubaccountBalanceEndpointRequest(): SubaccountBalanceEndpointRequest {
  return { subaccountId: "", denom: "" };
}

export const SubaccountBalanceEndpointRequest = {
  encode(message: SubaccountBalanceEndpointRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalanceEndpointRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalanceEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalanceEndpointRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
    };
  },

  toJSON(message: SubaccountBalanceEndpointRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalanceEndpointRequest>): SubaccountBalanceEndpointRequest {
    return SubaccountBalanceEndpointRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalanceEndpointRequest>): SubaccountBalanceEndpointRequest {
    const message = createBaseSubaccountBalanceEndpointRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseSubaccountBalanceEndpointResponse(): SubaccountBalanceEndpointResponse {
  return { balance: undefined };
}

export const SubaccountBalanceEndpointResponse = {
  encode(message: SubaccountBalanceEndpointResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.balance !== undefined) {
      SubaccountBalance.encode(message.balance, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalanceEndpointResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalanceEndpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balance = SubaccountBalance.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalanceEndpointResponse {
    return { balance: isSet(object.balance) ? SubaccountBalance.fromJSON(object.balance) : undefined };
  },

  toJSON(message: SubaccountBalanceEndpointResponse): unknown {
    const obj: any = {};
    message.balance !== undefined &&
      (obj.balance = message.balance ? SubaccountBalance.toJSON(message.balance) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalanceEndpointResponse>): SubaccountBalanceEndpointResponse {
    return SubaccountBalanceEndpointResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalanceEndpointResponse>): SubaccountBalanceEndpointResponse {
    const message = createBaseSubaccountBalanceEndpointResponse();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? SubaccountBalance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseStreamSubaccountBalanceRequest(): StreamSubaccountBalanceRequest {
  return { subaccountId: "", denoms: [] };
}

export const StreamSubaccountBalanceRequest = {
  encode(message: StreamSubaccountBalanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    for (const v of message.denoms) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSubaccountBalanceRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSubaccountBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denoms.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamSubaccountBalanceRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denoms: Array.isArray(object?.denoms) ? object.denoms.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamSubaccountBalanceRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.denoms) {
      obj.denoms = message.denoms.map((e) => e);
    } else {
      obj.denoms = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamSubaccountBalanceRequest>): StreamSubaccountBalanceRequest {
    return StreamSubaccountBalanceRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamSubaccountBalanceRequest>): StreamSubaccountBalanceRequest {
    const message = createBaseStreamSubaccountBalanceRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.denoms = object.denoms?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamSubaccountBalanceResponse(): StreamSubaccountBalanceResponse {
  return { balance: undefined, timestamp: "0" };
}

export const StreamSubaccountBalanceResponse = {
  encode(message: StreamSubaccountBalanceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.balance !== undefined) {
      SubaccountBalance.encode(message.balance, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamSubaccountBalanceResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamSubaccountBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balance = SubaccountBalance.decode(reader, reader.uint32());
          break;
        case 2:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamSubaccountBalanceResponse {
    return {
      balance: isSet(object.balance) ? SubaccountBalance.fromJSON(object.balance) : undefined,
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamSubaccountBalanceResponse): unknown {
    const obj: any = {};
    message.balance !== undefined &&
      (obj.balance = message.balance ? SubaccountBalance.toJSON(message.balance) : undefined);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamSubaccountBalanceResponse>): StreamSubaccountBalanceResponse {
    return StreamSubaccountBalanceResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamSubaccountBalanceResponse>): StreamSubaccountBalanceResponse {
    const message = createBaseStreamSubaccountBalanceResponse();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? SubaccountBalance.fromPartial(object.balance)
      : undefined;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseSubaccountHistoryRequest(): SubaccountHistoryRequest {
  return { subaccountId: "", denom: "", transferTypes: [], skip: "0", limit: 0, endTime: "0" };
}

export const SubaccountHistoryRequest = {
  encode(message: SubaccountHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    for (const v of message.transferTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.skip !== "0") {
      writer.uint32(32).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(40).sint32(message.limit);
    }
    if (message.endTime !== "0") {
      writer.uint32(48).sint64(message.endTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.transferTypes.push(reader.string());
          break;
        case 4:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.limit = reader.sint32();
          break;
        case 6:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountHistoryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      transferTypes: Array.isArray(object?.transferTypes) ? object.transferTypes.map((e: any) => String(e)) : [],
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
    };
  },

  toJSON(message: SubaccountHistoryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    if (message.transferTypes) {
      obj.transferTypes = message.transferTypes.map((e) => e);
    } else {
      obj.transferTypes = [];
    }
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.endTime !== undefined && (obj.endTime = message.endTime);
    return obj;
  },

  create(base?: DeepPartial<SubaccountHistoryRequest>): SubaccountHistoryRequest {
    return SubaccountHistoryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountHistoryRequest>): SubaccountHistoryRequest {
    const message = createBaseSubaccountHistoryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    message.transferTypes = object.transferTypes?.map((e) => e) || [];
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.endTime = object.endTime ?? "0";
    return message;
  },
};

function createBaseSubaccountHistoryResponse(): SubaccountHistoryResponse {
  return { transfers: [], paging: undefined };
}

export const SubaccountHistoryResponse = {
  encode(message: SubaccountHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      SubaccountBalanceTransfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.transfers.push(SubaccountBalanceTransfer.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountHistoryResponse {
    return {
      transfers: Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => SubaccountBalanceTransfer.fromJSON(e))
        : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: SubaccountHistoryResponse): unknown {
    const obj: any = {};
    if (message.transfers) {
      obj.transfers = message.transfers.map((e) => e ? SubaccountBalanceTransfer.toJSON(e) : undefined);
    } else {
      obj.transfers = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountHistoryResponse>): SubaccountHistoryResponse {
    return SubaccountHistoryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountHistoryResponse>): SubaccountHistoryResponse {
    const message = createBaseSubaccountHistoryResponse();
    message.transfers = object.transfers?.map((e) => SubaccountBalanceTransfer.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSubaccountBalanceTransfer(): SubaccountBalanceTransfer {
  return {
    transferType: "",
    srcSubaccountId: "",
    srcAccountAddress: "",
    dstSubaccountId: "",
    dstAccountAddress: "",
    amount: undefined,
    executedAt: "0",
  };
}

export const SubaccountBalanceTransfer = {
  encode(message: SubaccountBalanceTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transferType !== "") {
      writer.uint32(10).string(message.transferType);
    }
    if (message.srcSubaccountId !== "") {
      writer.uint32(18).string(message.srcSubaccountId);
    }
    if (message.srcAccountAddress !== "") {
      writer.uint32(26).string(message.srcAccountAddress);
    }
    if (message.dstSubaccountId !== "") {
      writer.uint32(34).string(message.dstSubaccountId);
    }
    if (message.dstAccountAddress !== "") {
      writer.uint32(42).string(message.dstAccountAddress);
    }
    if (message.amount !== undefined) {
      CosmosCoin.encode(message.amount, writer.uint32(50).fork()).ldelim();
    }
    if (message.executedAt !== "0") {
      writer.uint32(56).sint64(message.executedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalanceTransfer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalanceTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.transferType = reader.string();
          break;
        case 2:
          message.srcSubaccountId = reader.string();
          break;
        case 3:
          message.srcAccountAddress = reader.string();
          break;
        case 4:
          message.dstSubaccountId = reader.string();
          break;
        case 5:
          message.dstAccountAddress = reader.string();
          break;
        case 6:
          message.amount = CosmosCoin.decode(reader, reader.uint32());
          break;
        case 7:
          message.executedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalanceTransfer {
    return {
      transferType: isSet(object.transferType) ? String(object.transferType) : "",
      srcSubaccountId: isSet(object.srcSubaccountId) ? String(object.srcSubaccountId) : "",
      srcAccountAddress: isSet(object.srcAccountAddress) ? String(object.srcAccountAddress) : "",
      dstSubaccountId: isSet(object.dstSubaccountId) ? String(object.dstSubaccountId) : "",
      dstAccountAddress: isSet(object.dstAccountAddress) ? String(object.dstAccountAddress) : "",
      amount: isSet(object.amount) ? CosmosCoin.fromJSON(object.amount) : undefined,
      executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
    };
  },

  toJSON(message: SubaccountBalanceTransfer): unknown {
    const obj: any = {};
    message.transferType !== undefined && (obj.transferType = message.transferType);
    message.srcSubaccountId !== undefined && (obj.srcSubaccountId = message.srcSubaccountId);
    message.srcAccountAddress !== undefined && (obj.srcAccountAddress = message.srcAccountAddress);
    message.dstSubaccountId !== undefined && (obj.dstSubaccountId = message.dstSubaccountId);
    message.dstAccountAddress !== undefined && (obj.dstAccountAddress = message.dstAccountAddress);
    message.amount !== undefined && (obj.amount = message.amount ? CosmosCoin.toJSON(message.amount) : undefined);
    message.executedAt !== undefined && (obj.executedAt = message.executedAt);
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalanceTransfer>): SubaccountBalanceTransfer {
    return SubaccountBalanceTransfer.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalanceTransfer>): SubaccountBalanceTransfer {
    const message = createBaseSubaccountBalanceTransfer();
    message.transferType = object.transferType ?? "";
    message.srcSubaccountId = object.srcSubaccountId ?? "";
    message.srcAccountAddress = object.srcAccountAddress ?? "";
    message.dstSubaccountId = object.dstSubaccountId ?? "";
    message.dstAccountAddress = object.dstAccountAddress ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? CosmosCoin.fromPartial(object.amount)
      : undefined;
    message.executedAt = object.executedAt ?? "0";
    return message;
  },
};

function createBaseCosmosCoin(): CosmosCoin {
  return { denom: "", amount: "" };
}

export const CosmosCoin = {
  encode(message: CosmosCoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosCoin {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CosmosCoin {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: CosmosCoin): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  create(base?: DeepPartial<CosmosCoin>): CosmosCoin {
    return CosmosCoin.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CosmosCoin>): CosmosCoin {
    const message = createBaseCosmosCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBasePaging(): Paging {
  return { total: "0", from: 0, to: 0, countBySubaccount: "0" };
}

export const Paging = {
  encode(message: Paging, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== "0") {
      writer.uint32(8).sint64(message.total);
    }
    if (message.from !== 0) {
      writer.uint32(16).sint32(message.from);
    }
    if (message.to !== 0) {
      writer.uint32(24).sint32(message.to);
    }
    if (message.countBySubaccount !== "0") {
      writer.uint32(32).sint64(message.countBySubaccount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Paging {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaging();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.total = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.from = reader.sint32();
          break;
        case 3:
          message.to = reader.sint32();
          break;
        case 4:
          message.countBySubaccount = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Paging {
    return {
      total: isSet(object.total) ? String(object.total) : "0",
      from: isSet(object.from) ? Number(object.from) : 0,
      to: isSet(object.to) ? Number(object.to) : 0,
      countBySubaccount: isSet(object.countBySubaccount) ? String(object.countBySubaccount) : "0",
    };
  },

  toJSON(message: Paging): unknown {
    const obj: any = {};
    message.total !== undefined && (obj.total = message.total);
    message.from !== undefined && (obj.from = Math.round(message.from));
    message.to !== undefined && (obj.to = Math.round(message.to));
    message.countBySubaccount !== undefined && (obj.countBySubaccount = message.countBySubaccount);
    return obj;
  },

  create(base?: DeepPartial<Paging>): Paging {
    return Paging.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Paging>): Paging {
    const message = createBasePaging();
    message.total = object.total ?? "0";
    message.from = object.from ?? 0;
    message.to = object.to ?? 0;
    message.countBySubaccount = object.countBySubaccount ?? "0";
    return message;
  },
};

function createBaseSubaccountOrderSummaryRequest(): SubaccountOrderSummaryRequest {
  return { subaccountId: "", marketId: "", orderDirection: "" };
}

export const SubaccountOrderSummaryRequest = {
  encode(message: SubaccountOrderSummaryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.orderDirection !== "") {
      writer.uint32(26).string(message.orderDirection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderSummaryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrderSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.orderDirection = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrderSummaryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderDirection: isSet(object.orderDirection) ? String(object.orderDirection) : "",
    };
  },

  toJSON(message: SubaccountOrderSummaryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderDirection !== undefined && (obj.orderDirection = message.orderDirection);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrderSummaryRequest>): SubaccountOrderSummaryRequest {
    return SubaccountOrderSummaryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrderSummaryRequest>): SubaccountOrderSummaryRequest {
    const message = createBaseSubaccountOrderSummaryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.orderDirection = object.orderDirection ?? "";
    return message;
  },
};

function createBaseSubaccountOrderSummaryResponse(): SubaccountOrderSummaryResponse {
  return { spotOrdersTotal: "0", derivativeOrdersTotal: "0" };
}

export const SubaccountOrderSummaryResponse = {
  encode(message: SubaccountOrderSummaryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spotOrdersTotal !== "0") {
      writer.uint32(8).sint64(message.spotOrdersTotal);
    }
    if (message.derivativeOrdersTotal !== "0") {
      writer.uint32(16).sint64(message.derivativeOrdersTotal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderSummaryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrderSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spotOrdersTotal = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.derivativeOrdersTotal = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrderSummaryResponse {
    return {
      spotOrdersTotal: isSet(object.spotOrdersTotal) ? String(object.spotOrdersTotal) : "0",
      derivativeOrdersTotal: isSet(object.derivativeOrdersTotal) ? String(object.derivativeOrdersTotal) : "0",
    };
  },

  toJSON(message: SubaccountOrderSummaryResponse): unknown {
    const obj: any = {};
    message.spotOrdersTotal !== undefined && (obj.spotOrdersTotal = message.spotOrdersTotal);
    message.derivativeOrdersTotal !== undefined && (obj.derivativeOrdersTotal = message.derivativeOrdersTotal);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrderSummaryResponse>): SubaccountOrderSummaryResponse {
    return SubaccountOrderSummaryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrderSummaryResponse>): SubaccountOrderSummaryResponse {
    const message = createBaseSubaccountOrderSummaryResponse();
    message.spotOrdersTotal = object.spotOrdersTotal ?? "0";
    message.derivativeOrdersTotal = object.derivativeOrdersTotal ?? "0";
    return message;
  },
};

function createBaseRewardsRequest(): RewardsRequest {
  return { epoch: "0", accountAddress: "" };
}

export const RewardsRequest = {
  encode(message: RewardsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.epoch !== "0") {
      writer.uint32(8).sint64(message.epoch);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.epoch = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.accountAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RewardsRequest {
    return {
      epoch: isSet(object.epoch) ? String(object.epoch) : "0",
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
    };
  },

  toJSON(message: RewardsRequest): unknown {
    const obj: any = {};
    message.epoch !== undefined && (obj.epoch = message.epoch);
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    return obj;
  },

  create(base?: DeepPartial<RewardsRequest>): RewardsRequest {
    return RewardsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<RewardsRequest>): RewardsRequest {
    const message = createBaseRewardsRequest();
    message.epoch = object.epoch ?? "0";
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseRewardsResponse(): RewardsResponse {
  return { rewards: [] };
}

export const RewardsResponse = {
  encode(message: RewardsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rewards) {
      Reward.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rewards.push(Reward.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RewardsResponse {
    return { rewards: Array.isArray(object?.rewards) ? object.rewards.map((e: any) => Reward.fromJSON(e)) : [] };
  },

  toJSON(message: RewardsResponse): unknown {
    const obj: any = {};
    if (message.rewards) {
      obj.rewards = message.rewards.map((e) => e ? Reward.toJSON(e) : undefined);
    } else {
      obj.rewards = [];
    }
    return obj;
  },

  create(base?: DeepPartial<RewardsResponse>): RewardsResponse {
    return RewardsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<RewardsResponse>): RewardsResponse {
    const message = createBaseRewardsResponse();
    message.rewards = object.rewards?.map((e) => Reward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReward(): Reward {
  return { accountAddress: "", rewards: [], distributedAt: "0" };
}

export const Reward = {
  encode(message: Reward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    for (const v of message.rewards) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.distributedAt !== "0") {
      writer.uint32(24).sint64(message.distributedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reward {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        case 2:
          message.rewards.push(Coin.decode(reader, reader.uint32()));
          break;
        case 3:
          message.distributedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Reward {
    return {
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
      rewards: Array.isArray(object?.rewards) ? object.rewards.map((e: any) => Coin.fromJSON(e)) : [],
      distributedAt: isSet(object.distributedAt) ? String(object.distributedAt) : "0",
    };
  },

  toJSON(message: Reward): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    if (message.rewards) {
      obj.rewards = message.rewards.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.rewards = [];
    }
    message.distributedAt !== undefined && (obj.distributedAt = message.distributedAt);
    return obj;
  },

  create(base?: DeepPartial<Reward>): Reward {
    return Reward.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Reward>): Reward {
    const message = createBaseReward();
    message.accountAddress = object.accountAddress ?? "";
    message.rewards = object.rewards?.map((e) => Coin.fromPartial(e)) || [];
    message.distributedAt = object.distributedAt ?? "0";
    return message;
  },
};

function createBaseCoin(): Coin {
  return { denom: "", amount: "" };
}

export const Coin = {
  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Coin {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: Coin): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  create(base?: DeepPartial<Coin>): Coin {
    return Coin.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Coin>): Coin {
    const message = createBaseCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

/** InjectiveAccountsRPC defines API of Exchange Accounts provider. */
export interface InjectiveAccountsRPC {
  /** Provide the account's portfolio value in USD. */
  Portfolio(request: DeepPartial<PortfolioRequest>, metadata?: grpc.Metadata): Promise<PortfolioResponse>;
  /** List order states by order hashes */
  OrderStates(request: DeepPartial<OrderStatesRequest>, metadata?: grpc.Metadata): Promise<OrderStatesResponse>;
  /** List all subaccounts IDs of an account address */
  SubaccountsList(
    request: DeepPartial<SubaccountsListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountsListResponse>;
  /** List subaccount balances for the provided denoms. */
  SubaccountBalancesList(
    request: DeepPartial<SubaccountBalancesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountBalancesListResponse>;
  /** Gets a balance for specific coin denom */
  SubaccountBalanceEndpoint(
    request: DeepPartial<SubaccountBalanceEndpointRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountBalanceEndpointResponse>;
  /**
   * StreamSubaccountBalance streams new balance changes for a specified
   * subaccount and denoms. If no denoms are provided, all denom changes are
   * streamed.
   */
  StreamSubaccountBalance(
    request: DeepPartial<StreamSubaccountBalanceRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSubaccountBalanceResponse>;
  /** Get subaccount's deposits and withdrawals history */
  SubaccountHistory(
    request: DeepPartial<SubaccountHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountHistoryResponse>;
  /** Get subaccount's orders summary */
  SubaccountOrderSummary(
    request: DeepPartial<SubaccountOrderSummaryRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrderSummaryResponse>;
  /** Provide historical trading rewards */
  Rewards(request: DeepPartial<RewardsRequest>, metadata?: grpc.Metadata): Promise<RewardsResponse>;
}

export class InjectiveAccountsRPCClientImpl implements InjectiveAccountsRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Portfolio = this.Portfolio.bind(this);
    this.OrderStates = this.OrderStates.bind(this);
    this.SubaccountsList = this.SubaccountsList.bind(this);
    this.SubaccountBalancesList = this.SubaccountBalancesList.bind(this);
    this.SubaccountBalanceEndpoint = this.SubaccountBalanceEndpoint.bind(this);
    this.StreamSubaccountBalance = this.StreamSubaccountBalance.bind(this);
    this.SubaccountHistory = this.SubaccountHistory.bind(this);
    this.SubaccountOrderSummary = this.SubaccountOrderSummary.bind(this);
    this.Rewards = this.Rewards.bind(this);
  }

  Portfolio(request: DeepPartial<PortfolioRequest>, metadata?: grpc.Metadata): Promise<PortfolioResponse> {
    return this.rpc.unary(InjectiveAccountsRPCPortfolioDesc, PortfolioRequest.fromPartial(request), metadata);
  }

  OrderStates(request: DeepPartial<OrderStatesRequest>, metadata?: grpc.Metadata): Promise<OrderStatesResponse> {
    return this.rpc.unary(InjectiveAccountsRPCOrderStatesDesc, OrderStatesRequest.fromPartial(request), metadata);
  }

  SubaccountsList(
    request: DeepPartial<SubaccountsListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountsListResponse> {
    return this.rpc.unary(
      InjectiveAccountsRPCSubaccountsListDesc,
      SubaccountsListRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountBalancesList(
    request: DeepPartial<SubaccountBalancesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountBalancesListResponse> {
    return this.rpc.unary(
      InjectiveAccountsRPCSubaccountBalancesListDesc,
      SubaccountBalancesListRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountBalanceEndpoint(
    request: DeepPartial<SubaccountBalanceEndpointRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountBalanceEndpointResponse> {
    return this.rpc.unary(
      InjectiveAccountsRPCSubaccountBalanceEndpointDesc,
      SubaccountBalanceEndpointRequest.fromPartial(request),
      metadata,
    );
  }

  StreamSubaccountBalance(
    request: DeepPartial<StreamSubaccountBalanceRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamSubaccountBalanceResponse> {
    return this.rpc.invoke(
      InjectiveAccountsRPCStreamSubaccountBalanceDesc,
      StreamSubaccountBalanceRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountHistory(
    request: DeepPartial<SubaccountHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountHistoryResponse> {
    return this.rpc.unary(
      InjectiveAccountsRPCSubaccountHistoryDesc,
      SubaccountHistoryRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountOrderSummary(
    request: DeepPartial<SubaccountOrderSummaryRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrderSummaryResponse> {
    return this.rpc.unary(
      InjectiveAccountsRPCSubaccountOrderSummaryDesc,
      SubaccountOrderSummaryRequest.fromPartial(request),
      metadata,
    );
  }

  Rewards(request: DeepPartial<RewardsRequest>, metadata?: grpc.Metadata): Promise<RewardsResponse> {
    return this.rpc.unary(InjectiveAccountsRPCRewardsDesc, RewardsRequest.fromPartial(request), metadata);
  }
}

export const InjectiveAccountsRPCDesc = { serviceName: "injective_accounts_rpc.InjectiveAccountsRPC" };

export const InjectiveAccountsRPCPortfolioDesc: UnaryMethodDefinitionish = {
  methodName: "Portfolio",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PortfolioRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PortfolioResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCOrderStatesDesc: UnaryMethodDefinitionish = {
  methodName: "OrderStates",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCSubaccountsListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountsList",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountsListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountsListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCSubaccountBalancesListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountBalancesList",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountBalancesListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountBalancesListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCSubaccountBalanceEndpointDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountBalanceEndpoint",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountBalanceEndpointRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountBalanceEndpointResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCStreamSubaccountBalanceDesc: UnaryMethodDefinitionish = {
  methodName: "StreamSubaccountBalance",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamSubaccountBalanceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamSubaccountBalanceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCSubaccountHistoryDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountHistory",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountHistoryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountHistoryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCSubaccountOrderSummaryDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountOrderSummary",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountOrderSummaryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountOrderSummaryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveAccountsRPCRewardsDesc: UnaryMethodDefinitionish = {
  methodName: "Rewards",
  service: InjectiveAccountsRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return RewardsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = RewardsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes || [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Observable((observer) => {
      const upStream = (() => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          transport: this.options.streamingTransport || this.options.transport,
          metadata: maybeCombinedMetadata,
          debug: this.options.debug,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      });
      upStream();
    }).pipe(share());
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
