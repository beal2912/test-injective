/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "injective_spot_exchange_rpc";

export interface MarketsRequest {
  /** Filter by market status */
  marketStatus: string;
  /** Filter by the Coin denomination of the base currency */
  baseDenom: string;
  /** Filter by the Coin denomination of the quote currency */
  quoteDenom: string;
}

export interface MarketsResponse {
  /** Spot Markets list */
  markets: SpotMarketInfo[];
}

export interface SpotMarketInfo {
  /** SpotMarket ID is keccak265(baseDenom || quoteDenom) */
  marketId: string;
  /** The status of the market */
  marketStatus: string;
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   */
  ticker: string;
  /** Coin denom used for the base asset. */
  baseDenom: string;
  /** Token metadata for base asset, only for Ethereum-based assets */
  baseTokenMeta:
    | TokenMeta
    | undefined;
  /** Coin denom used for the quote asset. */
  quoteDenom: string;
  /** Token metadata for quote asset, only for Ethereum-based assets */
  quoteTokenMeta:
    | TokenMeta
    | undefined;
  /** Defines the fee percentage makers pay when trading (in quote asset) */
  makerFeeRate: string;
  /** Defines the fee percentage takers pay when trading (in quote asset) */
  takerFeeRate: string;
  /** Percentage of the transaction fee shared with the service provider */
  serviceProviderFee: string;
  /** Defines the minimum required tick size for the order's price */
  minPriceTickSize: string;
  /** Defines the minimum required tick size for the order's quantity */
  minQuantityTickSize: string;
}

export interface TokenMeta {
  /** Token full name */
  name: string;
  /** Token Ethereum contract address */
  address: string;
  /** Token symbol short name */
  symbol: string;
  /** URL to the logo image */
  logo: string;
  /** Token decimals */
  decimals: number;
  /** Token metadata fetched timestamp in UNIX millis. */
  updatedAt: string;
}

export interface MarketRequest {
  /** MarketId of the market we want to fetch */
  marketId: string;
}

export interface MarketResponse {
  /** Info about particular spot market */
  market: SpotMarketInfo | undefined;
}

export interface StreamMarketsRequest {
  /** List of market IDs for updates streaming, empty means 'ALL' spot markets */
  marketIds: string[];
}

export interface StreamMarketsResponse {
  /** Info about particular spot market */
  market:
    | SpotMarketInfo
    | undefined;
  /** Update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrderbookRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
}

export interface OrderbookResponse {
  /** Orderbook of a particular spot market */
  orderbook: SpotLimitOrderbook | undefined;
}

export interface SpotLimitOrderbook {
  /** Array of price levels for buys */
  buys: PriceLevel[];
  /** Array of price levels for sells */
  sells: PriceLevel[];
  /** Last update timestamp in UNIX millis. */
  timestamp: string;
}

export interface PriceLevel {
  /** Price number of the price level. */
  price: string;
  /** Quantity of the price level. */
  quantity: string;
  /** Price level last updated timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrderbookV2Request {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
}

export interface OrderbookV2Response {
  /** Orderbook of a particular spot market */
  orderbook: SpotLimitOrderbookV2 | undefined;
}

export interface SpotLimitOrderbookV2 {
  /** Array of price levels for buys */
  buys: PriceLevel[];
  /** Array of price levels for sells */
  sells: PriceLevel[];
  /** market orderbook sequence */
  sequence: string;
  /** Last update timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrderbooksRequest {
  /** MarketIds of the markets */
  marketIds: string[];
}

export interface OrderbooksResponse {
  orderbooks: SingleSpotLimitOrderbook[];
}

export interface SingleSpotLimitOrderbook {
  /** market's ID */
  marketId: string;
  /** Orderbook of the market */
  orderbook: SpotLimitOrderbook | undefined;
}

export interface OrderbooksV2Request {
  /** MarketIds of the markets */
  marketIds: string[];
}

export interface OrderbooksV2Response {
  orderbooks: SingleSpotLimitOrderbookV2[];
}

export interface SingleSpotLimitOrderbookV2 {
  /** market's ID */
  marketId: string;
  /** Orderbook of the market */
  orderbook: SpotLimitOrderbookV2 | undefined;
}

export interface StreamOrderbookRequest {
  /** List of market IDs for orderbook streaming, empty means 'ALL' spot markets */
  marketIds: string[];
}

export interface StreamOrderbookResponse {
  /** Orderbook of a Spot Market */
  orderbook:
    | SpotLimitOrderbook
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface StreamOrderbookV2Request {
  /** List of market IDs for orderbook streaming, empty means 'ALL' spot markets */
  marketIds: string[];
}

export interface StreamOrderbookV2Response {
  /** Orderbook of a Spot Market */
  orderbook:
    | SpotLimitOrderbookV2
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface StreamOrderbookUpdateRequest {
  /** List of market IDs for orderbook streaming, empty means 'ALL' spot markets */
  marketIds: string[];
}

export interface StreamOrderbookUpdateResponse {
  /** Orderbook level updates of a Spot Market */
  orderbookLevelUpdates:
    | OrderbookLevelUpdates
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface OrderbookLevelUpdates {
  /** market's ID */
  marketId: string;
  /** orderbook update sequence */
  sequence: string;
  /** buy levels */
  buys: PriceLevelUpdate[];
  /** sell levels */
  sells: PriceLevelUpdate[];
  /** updates timestamp */
  updatedAt: string;
}

export interface PriceLevelUpdate {
  /** Price number of the price level. */
  price: string;
  /** Quantity of the price level. */
  quantity: string;
  /** Price level status. */
  isActive: boolean;
  /** Price level last updated timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrdersRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Look for specific order side */
  orderSide: string;
  /** Look for specific subaccountId of an order */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /** Should include inactive orders */
  includeInactive: boolean;
  /** Choose to return subaccount total orders */
  subaccountTotalOrders: boolean;
}

export interface OrdersResponse {
  orders: SpotLimitOrder[];
  paging: Paging | undefined;
}

export interface SpotLimitOrder {
  /** Hash of the order */
  orderHash: string;
  /** The side of the order */
  orderSide: string;
  /** Spot Market ID is keccak265(baseDenom + quoteDenom) */
  marketId: string;
  /** The subaccountId that this order belongs to */
  subaccountId: string;
  /** Price of the order */
  price: string;
  /** Quantity of the order */
  quantity: string;
  /** The amount of the quantity remaining unfilled */
  unfilledQuantity: string;
  /**
   * Trigger price is the trigger price used by stop/take orders. 0 if the
   * trigger price is not set.
   */
  triggerPrice: string;
  /** Fee recipient address */
  feeRecipient: string;
  /** Order state */
  state: string;
  /** Order committed timestamp in UNIX millis. */
  createdAt: string;
  /** Order updated timestamp in UNIX millis. */
  updatedAt: string;
}

/** Paging defines the structure for required params for handling pagination */
export interface Paging {
  /** total number of txs saved in database */
  total: string;
  /** can be either block height or index num */
  from: number;
  /** can be either block height or index num */
  to: number;
  /** count entries by subaccount, serving some places on helix */
  countBySubaccount: string;
}

export interface StreamOrdersRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Look for specific order side */
  orderSide: string;
  /** Look for specific subaccountId of an order */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /** Should include inactive orders */
  includeInactive: boolean;
  /** Choose to return subaccount total orders */
  subaccountTotalOrders: boolean;
}

export interface StreamOrdersResponse {
  /** Updated market order */
  order:
    | SpotLimitOrder
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface TradesRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Filter by execution side of the trade */
  executionSide: string;
  /** Filter by direction the trade */
  direction: string;
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Skip will skip the first n item from the item result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /** Subaccount ids of traders we want to get trades */
  subaccountIds: string[];
  executionTypes: string[];
}

export interface TradesResponse {
  /** Trades of a Spot Market */
  trades: SpotTrade[];
  /** Paging indicates pages response is on */
  paging: Paging | undefined;
}

export interface SpotTrade {
  /** Maker order hash. */
  orderHash: string;
  /** The subaccountId that executed the trade */
  subaccountId: string;
  /** The ID of the market that this trade is in */
  marketId: string;
  /** The execution type of the trade */
  tradeExecutionType: string;
  /** The direction the trade */
  tradeDirection: string;
  /** Price level at which trade has been executed */
  price:
    | PriceLevel
    | undefined;
  /** The fee associated with the trade (quote asset denom) */
  fee: string;
  /** Timestamp of trade execution in UNIX millis */
  executedAt: string;
  /** Fee recipient address */
  feeRecipient: string;
  /** A unique string that helps differentiate between trades */
  tradeId: string;
  /** Trade's execution side, marker/taker */
  executionSide: string;
}

export interface StreamTradesRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Filter by execution side of the trade */
  executionSide: string;
  /** Filter by direction the trade */
  direction: string;
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Skip will skip the first n item from the item result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /** Subaccount ids of traders we want to get trades */
  subaccountIds: string[];
  executionTypes: string[];
}

export interface StreamTradesResponse {
  /** New spot market trade */
  trade:
    | SpotTrade
    | undefined;
  /** Executed trades update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface SubaccountOrdersListRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
}

export interface SubaccountOrdersListResponse {
  orders: SpotLimitOrder[];
  paging: Paging | undefined;
}

export interface SubaccountTradesListRequest {
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Filter trades by market ID */
  marketId: string;
  /** Filter by execution type of trades */
  executionType: string;
  /** Filter by direction trades */
  direction: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
}

export interface SubaccountTradesListResponse {
  /** List of spot market trades */
  trades: SpotTrade[];
}

export interface OrdersHistoryRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /** filter by order types */
  orderTypes: string[];
  /** order side filter */
  direction: string;
  /** Search for orders which createdAt >= startTime, time in millisecond */
  startTime: string;
  /** Search for orders which createdAt <= endTime, time in millisecond */
  endTime: string;
  /** Filter by order state */
  state: string;
  executionTypes: string[];
  marketIds: string[];
}

export interface OrdersHistoryResponse {
  /** List of history spot orders */
  orders: SpotOrderHistory[];
  paging: Paging | undefined;
}

export interface SpotOrderHistory {
  /** Hash of the order */
  orderHash: string;
  /** Spot Market ID is keccak265(baseDenom + quoteDenom) */
  marketId: string;
  /** active state of the order */
  isActive: boolean;
  /** The subaccountId that this order belongs to */
  subaccountId: string;
  /** The execution type */
  executionType: string;
  /** The side of the order */
  orderType: string;
  /** Price of the order */
  price: string;
  /** Trigger price */
  triggerPrice: string;
  /** Quantity of the order */
  quantity: string;
  /** Filled amount */
  filledQuantity: string;
  /** Order state */
  state: string;
  /** Order committed timestamp in UNIX millis. */
  createdAt: string;
  /** Order updated timestamp in UNIX millis. */
  updatedAt: string;
  /** Order direction (order side) */
  direction: string;
}

export interface StreamOrdersHistoryRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** filter by order types */
  orderTypes: string[];
  /** order side filter */
  direction: string;
  /** Filter by order state */
  state: string;
  executionTypes: string[];
}

export interface StreamOrdersHistoryResponse {
  /** Updated order */
  order:
    | SpotOrderHistory
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

function createBaseMarketsRequest(): MarketsRequest {
  return { marketStatus: "", baseDenom: "", quoteDenom: "" };
}

export const MarketsRequest = {
  encode(message: MarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketStatus !== "") {
      writer.uint32(10).string(message.marketStatus);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(26).string(message.quoteDenom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketStatus = reader.string();
          break;
        case 2:
          message.baseDenom = reader.string();
          break;
        case 3:
          message.quoteDenom = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketsRequest {
    return {
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
    };
  },

  toJSON(message: MarketsRequest): unknown {
    const obj: any = {};
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    return obj;
  },

  create(base?: DeepPartial<MarketsRequest>): MarketsRequest {
    return MarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketsRequest>): MarketsRequest {
    const message = createBaseMarketsRequest();
    message.marketStatus = object.marketStatus ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    return message;
  },
};

function createBaseMarketsResponse(): MarketsResponse {
  return { markets: [] };
}

export const MarketsResponse = {
  encode(message: MarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      SpotMarketInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(SpotMarketInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketsResponse {
    return {
      markets: Array.isArray(object?.markets) ? object.markets.map((e: any) => SpotMarketInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: MarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? SpotMarketInfo.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MarketsResponse>): MarketsResponse {
    return MarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketsResponse>): MarketsResponse {
    const message = createBaseMarketsResponse();
    message.markets = object.markets?.map((e) => SpotMarketInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpotMarketInfo(): SpotMarketInfo {
  return {
    marketId: "",
    marketStatus: "",
    ticker: "",
    baseDenom: "",
    baseTokenMeta: undefined,
    quoteDenom: "",
    quoteTokenMeta: undefined,
    makerFeeRate: "",
    takerFeeRate: "",
    serviceProviderFee: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const SpotMarketInfo = {
  encode(message: SpotMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.marketStatus !== "") {
      writer.uint32(18).string(message.marketStatus);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.baseDenom !== "") {
      writer.uint32(34).string(message.baseDenom);
    }
    if (message.baseTokenMeta !== undefined) {
      TokenMeta.encode(message.baseTokenMeta, writer.uint32(42).fork()).ldelim();
    }
    if (message.quoteDenom !== "") {
      writer.uint32(50).string(message.quoteDenom);
    }
    if (message.quoteTokenMeta !== undefined) {
      TokenMeta.encode(message.quoteTokenMeta, writer.uint32(58).fork()).ldelim();
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(66).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(74).string(message.takerFeeRate);
    }
    if (message.serviceProviderFee !== "") {
      writer.uint32(82).string(message.serviceProviderFee);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(90).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(98).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.marketStatus = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.baseDenom = reader.string();
          break;
        case 5:
          message.baseTokenMeta = TokenMeta.decode(reader, reader.uint32());
          break;
        case 6:
          message.quoteDenom = reader.string();
          break;
        case 7:
          message.quoteTokenMeta = TokenMeta.decode(reader, reader.uint32());
          break;
        case 8:
          message.makerFeeRate = reader.string();
          break;
        case 9:
          message.takerFeeRate = reader.string();
          break;
        case 10:
          message.serviceProviderFee = reader.string();
          break;
        case 11:
          message.minPriceTickSize = reader.string();
          break;
        case 12:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarketInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : "",
      baseTokenMeta: isSet(object.baseTokenMeta) ? TokenMeta.fromJSON(object.baseTokenMeta) : undefined,
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      quoteTokenMeta: isSet(object.quoteTokenMeta) ? TokenMeta.fromJSON(object.quoteTokenMeta) : undefined,
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      serviceProviderFee: isSet(object.serviceProviderFee) ? String(object.serviceProviderFee) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: SpotMarketInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
    message.baseTokenMeta !== undefined &&
      (obj.baseTokenMeta = message.baseTokenMeta ? TokenMeta.toJSON(message.baseTokenMeta) : undefined);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.quoteTokenMeta !== undefined &&
      (obj.quoteTokenMeta = message.quoteTokenMeta ? TokenMeta.toJSON(message.quoteTokenMeta) : undefined);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.serviceProviderFee !== undefined && (obj.serviceProviderFee = message.serviceProviderFee);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<SpotMarketInfo>): SpotMarketInfo {
    return SpotMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarketInfo>): SpotMarketInfo {
    const message = createBaseSpotMarketInfo();
    message.marketId = object.marketId ?? "";
    message.marketStatus = object.marketStatus ?? "";
    message.ticker = object.ticker ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.baseTokenMeta = (object.baseTokenMeta !== undefined && object.baseTokenMeta !== null)
      ? TokenMeta.fromPartial(object.baseTokenMeta)
      : undefined;
    message.quoteDenom = object.quoteDenom ?? "";
    message.quoteTokenMeta = (object.quoteTokenMeta !== undefined && object.quoteTokenMeta !== null)
      ? TokenMeta.fromPartial(object.quoteTokenMeta)
      : undefined;
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.serviceProviderFee = object.serviceProviderFee ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseTokenMeta(): TokenMeta {
  return { name: "", address: "", symbol: "", logo: "", decimals: 0, updatedAt: "0" };
}

export const TokenMeta = {
  encode(message: TokenMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.logo !== "") {
      writer.uint32(34).string(message.logo);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).sint32(message.decimals);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(48).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenMeta {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        case 3:
          message.symbol = reader.string();
          break;
        case 4:
          message.logo = reader.string();
          break;
        case 5:
          message.decimals = reader.sint32();
          break;
        case 6:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TokenMeta {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      address: isSet(object.address) ? String(object.address) : "",
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      logo: isSet(object.logo) ? String(object.logo) : "",
      decimals: isSet(object.decimals) ? Number(object.decimals) : 0,
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: TokenMeta): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.address !== undefined && (obj.address = message.address);
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.logo !== undefined && (obj.logo = message.logo);
    message.decimals !== undefined && (obj.decimals = Math.round(message.decimals));
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<TokenMeta>): TokenMeta {
    return TokenMeta.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TokenMeta>): TokenMeta {
    const message = createBaseTokenMeta();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.symbol = object.symbol ?? "";
    message.logo = object.logo ?? "";
    message.decimals = object.decimals ?? 0;
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBaseMarketRequest(): MarketRequest {
  return { marketId: "" };
}

export const MarketRequest = {
  encode(message: MarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: MarketRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<MarketRequest>): MarketRequest {
    return MarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketRequest>): MarketRequest {
    const message = createBaseMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseMarketResponse(): MarketResponse {
  return { market: undefined };
}

export const MarketResponse = {
  encode(message: MarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      SpotMarketInfo.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = SpotMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketResponse {
    return { market: isSet(object.market) ? SpotMarketInfo.fromJSON(object.market) : undefined };
  },

  toJSON(message: MarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined && (obj.market = message.market ? SpotMarketInfo.toJSON(message.market) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MarketResponse>): MarketResponse {
    return MarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketResponse>): MarketResponse {
    const message = createBaseMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? SpotMarketInfo.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseStreamMarketsRequest(): StreamMarketsRequest {
  return { marketIds: [] };
}

export const StreamMarketsRequest = {
  encode(message: StreamMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamMarketsRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamMarketsRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMarketsRequest>): StreamMarketsRequest {
    return StreamMarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamMarketsRequest>): StreamMarketsRequest {
    const message = createBaseStreamMarketsRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamMarketsResponse(): StreamMarketsResponse {
  return { market: undefined, operationType: "", timestamp: "0" };
}

export const StreamMarketsResponse = {
  encode(message: StreamMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      SpotMarketInfo.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = SpotMarketInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamMarketsResponse {
    return {
      market: isSet(object.market) ? SpotMarketInfo.fromJSON(object.market) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamMarketsResponse): unknown {
    const obj: any = {};
    message.market !== undefined && (obj.market = message.market ? SpotMarketInfo.toJSON(message.market) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamMarketsResponse>): StreamMarketsResponse {
    return StreamMarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamMarketsResponse>): StreamMarketsResponse {
    const message = createBaseStreamMarketsResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? SpotMarketInfo.fromPartial(object.market)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrderbookRequest(): OrderbookRequest {
  return { marketId: "" };
}

export const OrderbookRequest = {
  encode(message: OrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: OrderbookRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<OrderbookRequest>): OrderbookRequest {
    return OrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookRequest>): OrderbookRequest {
    const message = createBaseOrderbookRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookResponse(): OrderbookResponse {
  return { orderbook: undefined };
}

export const OrderbookResponse = {
  encode(message: OrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      SpotLimitOrderbook.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = SpotLimitOrderbook.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookResponse {
    return { orderbook: isSet(object.orderbook) ? SpotLimitOrderbook.fromJSON(object.orderbook) : undefined };
  },

  toJSON(message: OrderbookResponse): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbook.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrderbookResponse>): OrderbookResponse {
    return OrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookResponse>): OrderbookResponse {
    const message = createBaseOrderbookResponse();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseSpotLimitOrderbook(): SpotLimitOrderbook {
  return { buys: [], sells: [], timestamp: "0" };
}

export const SpotLimitOrderbook = {
  encode(message: SpotLimitOrderbook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buys) {
      PriceLevel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevel.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotLimitOrderbook {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotLimitOrderbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buys.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sells.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotLimitOrderbook {
    return {
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevel.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: SpotLimitOrderbook): unknown {
    const obj: any = {};
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<SpotLimitOrderbook>): SpotLimitOrderbook {
    return SpotLimitOrderbook.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotLimitOrderbook>): SpotLimitOrderbook {
    const message = createBaseSpotLimitOrderbook();
    message.buys = object.buys?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBasePriceLevel(): PriceLevel {
  return { price: "", quantity: "", timestamp: "0" };
}

export const PriceLevel = {
  encode(message: PriceLevel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceLevel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceLevel {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: PriceLevel): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<PriceLevel>): PriceLevel {
    return PriceLevel.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceLevel>): PriceLevel {
    const message = createBasePriceLevel();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrderbookV2Request(): OrderbookV2Request {
  return { marketId: "" };
}

export const OrderbookV2Request = {
  encode(message: OrderbookV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookV2Request {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: OrderbookV2Request): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<OrderbookV2Request>): OrderbookV2Request {
    return OrderbookV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookV2Request>): OrderbookV2Request {
    const message = createBaseOrderbookV2Request();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookV2Response(): OrderbookV2Response {
  return { orderbook: undefined };
}

export const OrderbookV2Response = {
  encode(message: OrderbookV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      SpotLimitOrderbookV2.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = SpotLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookV2Response {
    return { orderbook: isSet(object.orderbook) ? SpotLimitOrderbookV2.fromJSON(object.orderbook) : undefined };
  },

  toJSON(message: OrderbookV2Response): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrderbookV2Response>): OrderbookV2Response {
    return OrderbookV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookV2Response>): OrderbookV2Response {
    const message = createBaseOrderbookV2Response();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseSpotLimitOrderbookV2(): SpotLimitOrderbookV2 {
  return { buys: [], sells: [], sequence: "0", timestamp: "0" };
}

export const SpotLimitOrderbookV2 = {
  encode(message: SpotLimitOrderbookV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buys) {
      PriceLevel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevel.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.sequence !== "0") {
      writer.uint32(24).uint64(message.sequence);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotLimitOrderbookV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotLimitOrderbookV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buys.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sells.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 3:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotLimitOrderbookV2 {
    return {
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: SpotLimitOrderbookV2): unknown {
    const obj: any = {};
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.sequence !== undefined && (obj.sequence = message.sequence);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<SpotLimitOrderbookV2>): SpotLimitOrderbookV2 {
    return SpotLimitOrderbookV2.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotLimitOrderbookV2>): SpotLimitOrderbookV2 {
    const message = createBaseSpotLimitOrderbookV2();
    message.buys = object.buys?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sequence = object.sequence ?? "0";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrderbooksRequest(): OrderbooksRequest {
  return { marketIds: [] };
}

export const OrderbooksRequest = {
  encode(message: OrderbooksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: OrderbooksRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksRequest>): OrderbooksRequest {
    return OrderbooksRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksRequest>): OrderbooksRequest {
    const message = createBaseOrderbooksRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderbooksResponse(): OrderbooksResponse {
  return { orderbooks: [] };
}

export const OrderbooksResponse = {
  encode(message: OrderbooksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderbooks) {
      SingleSpotLimitOrderbook.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbooks.push(SingleSpotLimitOrderbook.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksResponse {
    return {
      orderbooks: Array.isArray(object?.orderbooks)
        ? object.orderbooks.map((e: any) => SingleSpotLimitOrderbook.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderbooksResponse): unknown {
    const obj: any = {};
    if (message.orderbooks) {
      obj.orderbooks = message.orderbooks.map((e) => e ? SingleSpotLimitOrderbook.toJSON(e) : undefined);
    } else {
      obj.orderbooks = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksResponse>): OrderbooksResponse {
    return OrderbooksResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksResponse>): OrderbooksResponse {
    const message = createBaseOrderbooksResponse();
    message.orderbooks = object.orderbooks?.map((e) => SingleSpotLimitOrderbook.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleSpotLimitOrderbook(): SingleSpotLimitOrderbook {
  return { marketId: "", orderbook: undefined };
}

export const SingleSpotLimitOrderbook = {
  encode(message: SingleSpotLimitOrderbook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderbook !== undefined) {
      SpotLimitOrderbook.encode(message.orderbook, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleSpotLimitOrderbook {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleSpotLimitOrderbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderbook = SpotLimitOrderbook.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SingleSpotLimitOrderbook {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderbook: isSet(object.orderbook) ? SpotLimitOrderbook.fromJSON(object.orderbook) : undefined,
    };
  },

  toJSON(message: SingleSpotLimitOrderbook): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbook.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SingleSpotLimitOrderbook>): SingleSpotLimitOrderbook {
    return SingleSpotLimitOrderbook.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SingleSpotLimitOrderbook>): SingleSpotLimitOrderbook {
    const message = createBaseSingleSpotLimitOrderbook();
    message.marketId = object.marketId ?? "";
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseOrderbooksV2Request(): OrderbooksV2Request {
  return { marketIds: [] };
}

export const OrderbooksV2Request = {
  encode(message: OrderbooksV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksV2Request {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: OrderbooksV2Request): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksV2Request>): OrderbooksV2Request {
    return OrderbooksV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksV2Request>): OrderbooksV2Request {
    const message = createBaseOrderbooksV2Request();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderbooksV2Response(): OrderbooksV2Response {
  return { orderbooks: [] };
}

export const OrderbooksV2Response = {
  encode(message: OrderbooksV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderbooks) {
      SingleSpotLimitOrderbookV2.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbooks.push(SingleSpotLimitOrderbookV2.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksV2Response {
    return {
      orderbooks: Array.isArray(object?.orderbooks)
        ? object.orderbooks.map((e: any) => SingleSpotLimitOrderbookV2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderbooksV2Response): unknown {
    const obj: any = {};
    if (message.orderbooks) {
      obj.orderbooks = message.orderbooks.map((e) => e ? SingleSpotLimitOrderbookV2.toJSON(e) : undefined);
    } else {
      obj.orderbooks = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksV2Response>): OrderbooksV2Response {
    return OrderbooksV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksV2Response>): OrderbooksV2Response {
    const message = createBaseOrderbooksV2Response();
    message.orderbooks = object.orderbooks?.map((e) => SingleSpotLimitOrderbookV2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleSpotLimitOrderbookV2(): SingleSpotLimitOrderbookV2 {
  return { marketId: "", orderbook: undefined };
}

export const SingleSpotLimitOrderbookV2 = {
  encode(message: SingleSpotLimitOrderbookV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderbook !== undefined) {
      SpotLimitOrderbookV2.encode(message.orderbook, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleSpotLimitOrderbookV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleSpotLimitOrderbookV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderbook = SpotLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SingleSpotLimitOrderbookV2 {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderbook: isSet(object.orderbook) ? SpotLimitOrderbookV2.fromJSON(object.orderbook) : undefined,
    };
  },

  toJSON(message: SingleSpotLimitOrderbookV2): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SingleSpotLimitOrderbookV2>): SingleSpotLimitOrderbookV2 {
    return SingleSpotLimitOrderbookV2.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SingleSpotLimitOrderbookV2>): SingleSpotLimitOrderbookV2 {
    const message = createBaseSingleSpotLimitOrderbookV2();
    message.marketId = object.marketId ?? "";
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseStreamOrderbookRequest(): StreamOrderbookRequest {
  return { marketIds: [] };
}

export const StreamOrderbookRequest = {
  encode(message: StreamOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookRequest>): StreamOrderbookRequest {
    return StreamOrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookRequest>): StreamOrderbookRequest {
    const message = createBaseStreamOrderbookRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookResponse(): StreamOrderbookResponse {
  return { orderbook: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookResponse = {
  encode(message: StreamOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      SpotLimitOrderbook.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = SpotLimitOrderbook.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookResponse {
    return {
      orderbook: isSet(object.orderbook) ? SpotLimitOrderbook.fromJSON(object.orderbook) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookResponse): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbook.toJSON(message.orderbook) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookResponse>): StreamOrderbookResponse {
    return StreamOrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookResponse>): StreamOrderbookResponse {
    const message = createBaseStreamOrderbookResponse();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseStreamOrderbookV2Request(): StreamOrderbookV2Request {
  return { marketIds: [] };
}

export const StreamOrderbookV2Request = {
  encode(message: StreamOrderbookV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookV2Request {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookV2Request): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookV2Request>): StreamOrderbookV2Request {
    return StreamOrderbookV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookV2Request>): StreamOrderbookV2Request {
    const message = createBaseStreamOrderbookV2Request();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookV2Response(): StreamOrderbookV2Response {
  return { orderbook: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookV2Response = {
  encode(message: StreamOrderbookV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      SpotLimitOrderbookV2.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = SpotLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookV2Response {
    return {
      orderbook: isSet(object.orderbook) ? SpotLimitOrderbookV2.fromJSON(object.orderbook) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookV2Response): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? SpotLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookV2Response>): StreamOrderbookV2Response {
    return StreamOrderbookV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookV2Response>): StreamOrderbookV2Response {
    const message = createBaseStreamOrderbookV2Response();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? SpotLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseStreamOrderbookUpdateRequest(): StreamOrderbookUpdateRequest {
  return { marketIds: [] };
}

export const StreamOrderbookUpdateRequest = {
  encode(message: StreamOrderbookUpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookUpdateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookUpdateRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookUpdateRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
    return StreamOrderbookUpdateRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
    const message = createBaseStreamOrderbookUpdateRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookUpdateResponse(): StreamOrderbookUpdateResponse {
  return { orderbookLevelUpdates: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookUpdateResponse = {
  encode(message: StreamOrderbookUpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbookLevelUpdates !== undefined) {
      OrderbookLevelUpdates.encode(message.orderbookLevelUpdates, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookUpdateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbookLevelUpdates = OrderbookLevelUpdates.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookUpdateResponse {
    return {
      orderbookLevelUpdates: isSet(object.orderbookLevelUpdates)
        ? OrderbookLevelUpdates.fromJSON(object.orderbookLevelUpdates)
        : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookUpdateResponse): unknown {
    const obj: any = {};
    message.orderbookLevelUpdates !== undefined && (obj.orderbookLevelUpdates = message.orderbookLevelUpdates
      ? OrderbookLevelUpdates.toJSON(message.orderbookLevelUpdates)
      : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
    return StreamOrderbookUpdateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
    const message = createBaseStreamOrderbookUpdateResponse();
    message.orderbookLevelUpdates =
      (object.orderbookLevelUpdates !== undefined && object.orderbookLevelUpdates !== null)
        ? OrderbookLevelUpdates.fromPartial(object.orderbookLevelUpdates)
        : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookLevelUpdates(): OrderbookLevelUpdates {
  return { marketId: "", sequence: "0", buys: [], sells: [], updatedAt: "0" };
}

export const OrderbookLevelUpdates = {
  encode(message: OrderbookLevelUpdates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.sequence !== "0") {
      writer.uint32(16).uint64(message.sequence);
    }
    for (const v of message.buys) {
      PriceLevelUpdate.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevelUpdate.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.updatedAt !== "0") {
      writer.uint32(40).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookLevelUpdates {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookLevelUpdates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.buys.push(PriceLevelUpdate.decode(reader, reader.uint32()));
          break;
        case 4:
          message.sells.push(PriceLevelUpdate.decode(reader, reader.uint32()));
          break;
        case 5:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookLevelUpdates {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevelUpdate.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevelUpdate.fromJSON(e)) : [],
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: OrderbookLevelUpdates): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.sequence !== undefined && (obj.sequence = message.sequence);
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevelUpdate.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevelUpdate.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<OrderbookLevelUpdates>): OrderbookLevelUpdates {
    return OrderbookLevelUpdates.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookLevelUpdates>): OrderbookLevelUpdates {
    const message = createBaseOrderbookLevelUpdates();
    message.marketId = object.marketId ?? "";
    message.sequence = object.sequence ?? "0";
    message.buys = object.buys?.map((e) => PriceLevelUpdate.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevelUpdate.fromPartial(e)) || [];
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBasePriceLevelUpdate(): PriceLevelUpdate {
  return { price: "", quantity: "", isActive: false, timestamp: "0" };
}

export const PriceLevelUpdate = {
  encode(message: PriceLevelUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.isActive === true) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceLevelUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.isActive = reader.bool();
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceLevelUpdate {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      isActive: isSet(object.isActive) ? Boolean(object.isActive) : false,
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: PriceLevelUpdate): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.isActive !== undefined && (obj.isActive = message.isActive);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<PriceLevelUpdate>): PriceLevelUpdate {
    return PriceLevelUpdate.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceLevelUpdate>): PriceLevelUpdate {
    const message = createBasePriceLevelUpdate();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.isActive = object.isActive ?? false;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrdersRequest(): OrdersRequest {
  return {
    marketId: "",
    orderSide: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    includeInactive: false,
    subaccountTotalOrders: false,
  };
}

export const OrdersRequest = {
  encode(message: OrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(32).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(40).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(48).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(56).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(66).string(v!);
    }
    if (message.includeInactive === true) {
      writer.uint32(72).bool(message.includeInactive);
    }
    if (message.subaccountTotalOrders === true) {
      writer.uint32(80).bool(message.subaccountTotalOrders);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.limit = reader.sint32();
          break;
        case 6:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 7:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.marketIds.push(reader.string());
          break;
        case 9:
          message.includeInactive = reader.bool();
          break;
        case 10:
          message.subaccountTotalOrders = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      includeInactive: isSet(object.includeInactive) ? Boolean(object.includeInactive) : false,
      subaccountTotalOrders: isSet(object.subaccountTotalOrders) ? Boolean(object.subaccountTotalOrders) : false,
    };
  },

  toJSON(message: OrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    message.includeInactive !== undefined && (obj.includeInactive = message.includeInactive);
    message.subaccountTotalOrders !== undefined && (obj.subaccountTotalOrders = message.subaccountTotalOrders);
    return obj;
  },

  create(base?: DeepPartial<OrdersRequest>): OrdersRequest {
    return OrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersRequest>): OrdersRequest {
    const message = createBaseOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.orderSide = object.orderSide ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.includeInactive = object.includeInactive ?? false;
    message.subaccountTotalOrders = object.subaccountTotalOrders ?? false;
    return message;
  },
};

function createBaseOrdersResponse(): OrdersResponse {
  return { orders: [], paging: undefined };
}

export const OrdersResponse = {
  encode(message: OrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      SpotLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(SpotLimitOrder.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => SpotLimitOrder.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: OrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? SpotLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrdersResponse>): OrdersResponse {
    return OrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersResponse>): OrdersResponse {
    const message = createBaseOrdersResponse();
    message.orders = object.orders?.map((e) => SpotLimitOrder.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSpotLimitOrder(): SpotLimitOrder {
  return {
    orderHash: "",
    orderSide: "",
    marketId: "",
    subaccountId: "",
    price: "",
    quantity: "",
    unfilledQuantity: "",
    triggerPrice: "",
    feeRecipient: "",
    state: "",
    createdAt: "0",
    updatedAt: "0",
  };
}

export const SpotLimitOrder = {
  encode(message: SpotLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.price !== "") {
      writer.uint32(42).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(50).string(message.quantity);
    }
    if (message.unfilledQuantity !== "") {
      writer.uint32(58).string(message.unfilledQuantity);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(66).string(message.triggerPrice);
    }
    if (message.feeRecipient !== "") {
      writer.uint32(74).string(message.feeRecipient);
    }
    if (message.state !== "") {
      writer.uint32(82).string(message.state);
    }
    if (message.createdAt !== "0") {
      writer.uint32(88).sint64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(96).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.price = reader.string();
          break;
        case 6:
          message.quantity = reader.string();
          break;
        case 7:
          message.unfilledQuantity = reader.string();
          break;
        case 8:
          message.triggerPrice = reader.string();
          break;
        case 9:
          message.feeRecipient = reader.string();
          break;
        case 10:
          message.state = reader.string();
          break;
        case 11:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        case 12:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotLimitOrder {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      unfilledQuantity: isSet(object.unfilledQuantity) ? String(object.unfilledQuantity) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
      state: isSet(object.state) ? String(object.state) : "",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: SpotLimitOrder): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.unfilledQuantity !== undefined && (obj.unfilledQuantity = message.unfilledQuantity);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
    message.state !== undefined && (obj.state = message.state);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<SpotLimitOrder>): SpotLimitOrder {
    return SpotLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotLimitOrder>): SpotLimitOrder {
    const message = createBaseSpotLimitOrder();
    message.orderHash = object.orderHash ?? "";
    message.orderSide = object.orderSide ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.unfilledQuantity = object.unfilledQuantity ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.feeRecipient = object.feeRecipient ?? "";
    message.state = object.state ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBasePaging(): Paging {
  return { total: "0", from: 0, to: 0, countBySubaccount: "0" };
}

export const Paging = {
  encode(message: Paging, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== "0") {
      writer.uint32(8).sint64(message.total);
    }
    if (message.from !== 0) {
      writer.uint32(16).sint32(message.from);
    }
    if (message.to !== 0) {
      writer.uint32(24).sint32(message.to);
    }
    if (message.countBySubaccount !== "0") {
      writer.uint32(32).sint64(message.countBySubaccount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Paging {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaging();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.total = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.from = reader.sint32();
          break;
        case 3:
          message.to = reader.sint32();
          break;
        case 4:
          message.countBySubaccount = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Paging {
    return {
      total: isSet(object.total) ? String(object.total) : "0",
      from: isSet(object.from) ? Number(object.from) : 0,
      to: isSet(object.to) ? Number(object.to) : 0,
      countBySubaccount: isSet(object.countBySubaccount) ? String(object.countBySubaccount) : "0",
    };
  },

  toJSON(message: Paging): unknown {
    const obj: any = {};
    message.total !== undefined && (obj.total = message.total);
    message.from !== undefined && (obj.from = Math.round(message.from));
    message.to !== undefined && (obj.to = Math.round(message.to));
    message.countBySubaccount !== undefined && (obj.countBySubaccount = message.countBySubaccount);
    return obj;
  },

  create(base?: DeepPartial<Paging>): Paging {
    return Paging.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Paging>): Paging {
    const message = createBasePaging();
    message.total = object.total ?? "0";
    message.from = object.from ?? 0;
    message.to = object.to ?? 0;
    message.countBySubaccount = object.countBySubaccount ?? "0";
    return message;
  },
};

function createBaseStreamOrdersRequest(): StreamOrdersRequest {
  return {
    marketId: "",
    orderSide: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    includeInactive: false,
    subaccountTotalOrders: false,
  };
}

export const StreamOrdersRequest = {
  encode(message: StreamOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(32).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(40).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(48).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(56).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(66).string(v!);
    }
    if (message.includeInactive === true) {
      writer.uint32(72).bool(message.includeInactive);
    }
    if (message.subaccountTotalOrders === true) {
      writer.uint32(80).bool(message.subaccountTotalOrders);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.limit = reader.sint32();
          break;
        case 6:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 7:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.marketIds.push(reader.string());
          break;
        case 9:
          message.includeInactive = reader.bool();
          break;
        case 10:
          message.subaccountTotalOrders = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      includeInactive: isSet(object.includeInactive) ? Boolean(object.includeInactive) : false,
      subaccountTotalOrders: isSet(object.subaccountTotalOrders) ? Boolean(object.subaccountTotalOrders) : false,
    };
  },

  toJSON(message: StreamOrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    message.includeInactive !== undefined && (obj.includeInactive = message.includeInactive);
    message.subaccountTotalOrders !== undefined && (obj.subaccountTotalOrders = message.subaccountTotalOrders);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersRequest>): StreamOrdersRequest {
    return StreamOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersRequest>): StreamOrdersRequest {
    const message = createBaseStreamOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.orderSide = object.orderSide ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.includeInactive = object.includeInactive ?? false;
    message.subaccountTotalOrders = object.subaccountTotalOrders ?? false;
    return message;
  },
};

function createBaseStreamOrdersResponse(): StreamOrdersResponse {
  return { order: undefined, operationType: "", timestamp: "0" };
}

export const StreamOrdersResponse = {
  encode(message: StreamOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      SpotLimitOrder.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order = SpotLimitOrder.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersResponse {
    return {
      order: isSet(object.order) ? SpotLimitOrder.fromJSON(object.order) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamOrdersResponse): unknown {
    const obj: any = {};
    message.order !== undefined && (obj.order = message.order ? SpotLimitOrder.toJSON(message.order) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersResponse>): StreamOrdersResponse {
    return StreamOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersResponse>): StreamOrdersResponse {
    const message = createBaseStreamOrdersResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? SpotLimitOrder.fromPartial(object.order)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseTradesRequest(): TradesRequest {
  return {
    marketId: "",
    executionSide: "",
    direction: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    subaccountIds: [],
    executionTypes: [],
  };
}

export const TradesRequest = {
  encode(message: TradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.executionSide !== "") {
      writer.uint32(18).string(message.executionSide);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.subaccountIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.executionTypes) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.executionSide = reader.string();
          break;
        case 3:
          message.direction = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.marketIds.push(reader.string());
          break;
        case 10:
          message.subaccountIds.push(reader.string());
          break;
        case 11:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      subaccountIds: Array.isArray(object?.subaccountIds) ? object.subaccountIds.map((e: any) => String(e)) : [],
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: TradesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    message.direction !== undefined && (obj.direction = message.direction);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => e);
    } else {
      obj.subaccountIds = [];
    }
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradesRequest>): TradesRequest {
    return TradesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradesRequest>): TradesRequest {
    const message = createBaseTradesRequest();
    message.marketId = object.marketId ?? "";
    message.executionSide = object.executionSide ?? "";
    message.direction = object.direction ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseTradesResponse(): TradesResponse {
  return { trades: [], paging: undefined };
}

export const TradesResponse = {
  encode(message: TradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trades) {
      SpotTrade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trades.push(SpotTrade.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradesResponse {
    return {
      trades: Array.isArray(object?.trades) ? object.trades.map((e: any) => SpotTrade.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: TradesResponse): unknown {
    const obj: any = {};
    if (message.trades) {
      obj.trades = message.trades.map((e) => e ? SpotTrade.toJSON(e) : undefined);
    } else {
      obj.trades = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<TradesResponse>): TradesResponse {
    return TradesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradesResponse>): TradesResponse {
    const message = createBaseTradesResponse();
    message.trades = object.trades?.map((e) => SpotTrade.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSpotTrade(): SpotTrade {
  return {
    orderHash: "",
    subaccountId: "",
    marketId: "",
    tradeExecutionType: "",
    tradeDirection: "",
    price: undefined,
    fee: "",
    executedAt: "0",
    feeRecipient: "",
    tradeId: "",
    executionSide: "",
  };
}

export const SpotTrade = {
  encode(message: SpotTrade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.tradeExecutionType !== "") {
      writer.uint32(34).string(message.tradeExecutionType);
    }
    if (message.tradeDirection !== "") {
      writer.uint32(42).string(message.tradeDirection);
    }
    if (message.price !== undefined) {
      PriceLevel.encode(message.price, writer.uint32(50).fork()).ldelim();
    }
    if (message.fee !== "") {
      writer.uint32(58).string(message.fee);
    }
    if (message.executedAt !== "0") {
      writer.uint32(64).sint64(message.executedAt);
    }
    if (message.feeRecipient !== "") {
      writer.uint32(74).string(message.feeRecipient);
    }
    if (message.tradeId !== "") {
      writer.uint32(82).string(message.tradeId);
    }
    if (message.executionSide !== "") {
      writer.uint32(90).string(message.executionSide);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotTrade {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.tradeExecutionType = reader.string();
          break;
        case 5:
          message.tradeDirection = reader.string();
          break;
        case 6:
          message.price = PriceLevel.decode(reader, reader.uint32());
          break;
        case 7:
          message.fee = reader.string();
          break;
        case 8:
          message.executedAt = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.feeRecipient = reader.string();
          break;
        case 10:
          message.tradeId = reader.string();
          break;
        case 11:
          message.executionSide = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotTrade {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      tradeExecutionType: isSet(object.tradeExecutionType) ? String(object.tradeExecutionType) : "",
      tradeDirection: isSet(object.tradeDirection) ? String(object.tradeDirection) : "",
      price: isSet(object.price) ? PriceLevel.fromJSON(object.price) : undefined,
      fee: isSet(object.fee) ? String(object.fee) : "",
      executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
      feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
      tradeId: isSet(object.tradeId) ? String(object.tradeId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
    };
  },

  toJSON(message: SpotTrade): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.tradeExecutionType !== undefined && (obj.tradeExecutionType = message.tradeExecutionType);
    message.tradeDirection !== undefined && (obj.tradeDirection = message.tradeDirection);
    message.price !== undefined && (obj.price = message.price ? PriceLevel.toJSON(message.price) : undefined);
    message.fee !== undefined && (obj.fee = message.fee);
    message.executedAt !== undefined && (obj.executedAt = message.executedAt);
    message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
    message.tradeId !== undefined && (obj.tradeId = message.tradeId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    return obj;
  },

  create(base?: DeepPartial<SpotTrade>): SpotTrade {
    return SpotTrade.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotTrade>): SpotTrade {
    const message = createBaseSpotTrade();
    message.orderHash = object.orderHash ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.tradeExecutionType = object.tradeExecutionType ?? "";
    message.tradeDirection = object.tradeDirection ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? PriceLevel.fromPartial(object.price)
      : undefined;
    message.fee = object.fee ?? "";
    message.executedAt = object.executedAt ?? "0";
    message.feeRecipient = object.feeRecipient ?? "";
    message.tradeId = object.tradeId ?? "";
    message.executionSide = object.executionSide ?? "";
    return message;
  },
};

function createBaseStreamTradesRequest(): StreamTradesRequest {
  return {
    marketId: "",
    executionSide: "",
    direction: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    subaccountIds: [],
    executionTypes: [],
  };
}

export const StreamTradesRequest = {
  encode(message: StreamTradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.executionSide !== "") {
      writer.uint32(18).string(message.executionSide);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.subaccountIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.executionTypes) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTradesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.executionSide = reader.string();
          break;
        case 3:
          message.direction = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.marketIds.push(reader.string());
          break;
        case 10:
          message.subaccountIds.push(reader.string());
          break;
        case 11:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamTradesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      subaccountIds: Array.isArray(object?.subaccountIds) ? object.subaccountIds.map((e: any) => String(e)) : [],
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamTradesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    message.direction !== undefined && (obj.direction = message.direction);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => e);
    } else {
      obj.subaccountIds = [];
    }
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTradesRequest>): StreamTradesRequest {
    return StreamTradesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamTradesRequest>): StreamTradesRequest {
    const message = createBaseStreamTradesRequest();
    message.marketId = object.marketId ?? "";
    message.executionSide = object.executionSide ?? "";
    message.direction = object.direction ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamTradesResponse(): StreamTradesResponse {
  return { trade: undefined, operationType: "", timestamp: "0" };
}

export const StreamTradesResponse = {
  encode(message: StreamTradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trade !== undefined) {
      SpotTrade.encode(message.trade, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTradesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trade = SpotTrade.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamTradesResponse {
    return {
      trade: isSet(object.trade) ? SpotTrade.fromJSON(object.trade) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamTradesResponse): unknown {
    const obj: any = {};
    message.trade !== undefined && (obj.trade = message.trade ? SpotTrade.toJSON(message.trade) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamTradesResponse>): StreamTradesResponse {
    return StreamTradesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamTradesResponse>): StreamTradesResponse {
    const message = createBaseStreamTradesResponse();
    message.trade = (object.trade !== undefined && object.trade !== null)
      ? SpotTrade.fromPartial(object.trade)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseSubaccountOrdersListRequest(): SubaccountOrdersListRequest {
  return { subaccountId: "", marketId: "", skip: "0", limit: 0 };
}

export const SubaccountOrdersListRequest = {
  encode(message: SubaccountOrdersListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrdersListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrdersListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrdersListRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: SubaccountOrdersListRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
    return SubaccountOrdersListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
    const message = createBaseSubaccountOrdersListRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSubaccountOrdersListResponse(): SubaccountOrdersListResponse {
  return { orders: [], paging: undefined };
}

export const SubaccountOrdersListResponse = {
  encode(message: SubaccountOrdersListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      SpotLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrdersListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrdersListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(SpotLimitOrder.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrdersListResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => SpotLimitOrder.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: SubaccountOrdersListResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? SpotLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
    return SubaccountOrdersListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
    const message = createBaseSubaccountOrdersListResponse();
    message.orders = object.orders?.map((e) => SpotLimitOrder.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSubaccountTradesListRequest(): SubaccountTradesListRequest {
  return { subaccountId: "", marketId: "", executionType: "", direction: "", skip: "0", limit: 0 };
}

export const SubaccountTradesListRequest = {
  encode(message: SubaccountTradesListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.executionType !== "") {
      writer.uint32(26).string(message.executionType);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradesListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountTradesListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.executionType = reader.string();
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountTradesListRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionType: isSet(object.executionType) ? String(object.executionType) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: SubaccountTradesListRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionType !== undefined && (obj.executionType = message.executionType);
    message.direction !== undefined && (obj.direction = message.direction);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<SubaccountTradesListRequest>): SubaccountTradesListRequest {
    return SubaccountTradesListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountTradesListRequest>): SubaccountTradesListRequest {
    const message = createBaseSubaccountTradesListRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.executionType = object.executionType ?? "";
    message.direction = object.direction ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSubaccountTradesListResponse(): SubaccountTradesListResponse {
  return { trades: [] };
}

export const SubaccountTradesListResponse = {
  encode(message: SubaccountTradesListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trades) {
      SpotTrade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradesListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountTradesListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trades.push(SpotTrade.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountTradesListResponse {
    return { trades: Array.isArray(object?.trades) ? object.trades.map((e: any) => SpotTrade.fromJSON(e)) : [] };
  },

  toJSON(message: SubaccountTradesListResponse): unknown {
    const obj: any = {};
    if (message.trades) {
      obj.trades = message.trades.map((e) => e ? SpotTrade.toJSON(e) : undefined);
    } else {
      obj.trades = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountTradesListResponse>): SubaccountTradesListResponse {
    return SubaccountTradesListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountTradesListResponse>): SubaccountTradesListResponse {
    const message = createBaseSubaccountTradesListResponse();
    message.trades = object.trades?.map((e) => SpotTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrdersHistoryRequest(): OrdersHistoryRequest {
  return {
    subaccountId: "",
    marketId: "",
    skip: "0",
    limit: 0,
    orderTypes: [],
    direction: "",
    startTime: "0",
    endTime: "0",
    state: "",
    executionTypes: [],
    marketIds: [],
  };
}

export const OrdersHistoryRequest = {
  encode(message: OrdersHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    for (const v of message.orderTypes) {
      writer.uint32(42).string(v!);
    }
    if (message.direction !== "") {
      writer.uint32(50).string(message.direction);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    if (message.state !== "") {
      writer.uint32(74).string(message.state);
    }
    for (const v of message.executionTypes) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.marketIds) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        case 5:
          message.orderTypes.push(reader.string());
          break;
        case 6:
          message.direction = reader.string();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.state = reader.string();
          break;
        case 10:
          message.executionTypes.push(reader.string());
          break;
        case 11:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersHistoryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      orderTypes: Array.isArray(object?.orderTypes) ? object.orderTypes.map((e: any) => String(e)) : [],
      direction: isSet(object.direction) ? String(object.direction) : "",
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      state: isSet(object.state) ? String(object.state) : "",
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: OrdersHistoryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    if (message.orderTypes) {
      obj.orderTypes = message.orderTypes.map((e) => e);
    } else {
      obj.orderTypes = [];
    }
    message.direction !== undefined && (obj.direction = message.direction);
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    message.state !== undefined && (obj.state = message.state);
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrdersHistoryRequest>): OrdersHistoryRequest {
    return OrdersHistoryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersHistoryRequest>): OrdersHistoryRequest {
    const message = createBaseOrdersHistoryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.orderTypes = object.orderTypes?.map((e) => e) || [];
    message.direction = object.direction ?? "";
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.state = object.state ?? "";
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrdersHistoryResponse(): OrdersHistoryResponse {
  return { orders: [], paging: undefined };
}

export const OrdersHistoryResponse = {
  encode(message: OrdersHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      SpotOrderHistory.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(SpotOrderHistory.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersHistoryResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => SpotOrderHistory.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: OrdersHistoryResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? SpotOrderHistory.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrdersHistoryResponse>): OrdersHistoryResponse {
    return OrdersHistoryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersHistoryResponse>): OrdersHistoryResponse {
    const message = createBaseOrdersHistoryResponse();
    message.orders = object.orders?.map((e) => SpotOrderHistory.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSpotOrderHistory(): SpotOrderHistory {
  return {
    orderHash: "",
    marketId: "",
    isActive: false,
    subaccountId: "",
    executionType: "",
    orderType: "",
    price: "",
    triggerPrice: "",
    quantity: "",
    filledQuantity: "",
    state: "",
    createdAt: "0",
    updatedAt: "0",
    direction: "",
  };
}

export const SpotOrderHistory = {
  encode(message: SpotOrderHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.isActive === true) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.executionType !== "") {
      writer.uint32(42).string(message.executionType);
    }
    if (message.orderType !== "") {
      writer.uint32(50).string(message.orderType);
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(66).string(message.triggerPrice);
    }
    if (message.quantity !== "") {
      writer.uint32(74).string(message.quantity);
    }
    if (message.filledQuantity !== "") {
      writer.uint32(82).string(message.filledQuantity);
    }
    if (message.state !== "") {
      writer.uint32(90).string(message.state);
    }
    if (message.createdAt !== "0") {
      writer.uint32(96).sint64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(104).sint64(message.updatedAt);
    }
    if (message.direction !== "") {
      writer.uint32(114).string(message.direction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotOrderHistory {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotOrderHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.isActive = reader.bool();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.executionType = reader.string();
          break;
        case 6:
          message.orderType = reader.string();
          break;
        case 7:
          message.price = reader.string();
          break;
        case 8:
          message.triggerPrice = reader.string();
          break;
        case 9:
          message.quantity = reader.string();
          break;
        case 10:
          message.filledQuantity = reader.string();
          break;
        case 11:
          message.state = reader.string();
          break;
        case 12:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        case 13:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        case 14:
          message.direction = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotOrderHistory {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      isActive: isSet(object.isActive) ? Boolean(object.isActive) : false,
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      executionType: isSet(object.executionType) ? String(object.executionType) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      price: isSet(object.price) ? String(object.price) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      filledQuantity: isSet(object.filledQuantity) ? String(object.filledQuantity) : "",
      state: isSet(object.state) ? String(object.state) : "",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
      direction: isSet(object.direction) ? String(object.direction) : "",
    };
  },

  toJSON(message: SpotOrderHistory): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.isActive !== undefined && (obj.isActive = message.isActive);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.executionType !== undefined && (obj.executionType = message.executionType);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.price !== undefined && (obj.price = message.price);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.filledQuantity !== undefined && (obj.filledQuantity = message.filledQuantity);
    message.state !== undefined && (obj.state = message.state);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    message.direction !== undefined && (obj.direction = message.direction);
    return obj;
  },

  create(base?: DeepPartial<SpotOrderHistory>): SpotOrderHistory {
    return SpotOrderHistory.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotOrderHistory>): SpotOrderHistory {
    const message = createBaseSpotOrderHistory();
    message.orderHash = object.orderHash ?? "";
    message.marketId = object.marketId ?? "";
    message.isActive = object.isActive ?? false;
    message.subaccountId = object.subaccountId ?? "";
    message.executionType = object.executionType ?? "";
    message.orderType = object.orderType ?? "";
    message.price = object.price ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.quantity = object.quantity ?? "";
    message.filledQuantity = object.filledQuantity ?? "";
    message.state = object.state ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.direction = object.direction ?? "";
    return message;
  },
};

function createBaseStreamOrdersHistoryRequest(): StreamOrdersHistoryRequest {
  return { subaccountId: "", marketId: "", orderTypes: [], direction: "", state: "", executionTypes: [] };
}

export const StreamOrdersHistoryRequest = {
  encode(message: StreamOrdersHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    for (const v of message.orderTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    for (const v of message.executionTypes) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.orderTypes.push(reader.string());
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.state = reader.string();
          break;
        case 6:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersHistoryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderTypes: Array.isArray(object?.orderTypes) ? object.orderTypes.map((e: any) => String(e)) : [],
      direction: isSet(object.direction) ? String(object.direction) : "",
      state: isSet(object.state) ? String(object.state) : "",
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamOrdersHistoryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    if (message.orderTypes) {
      obj.orderTypes = message.orderTypes.map((e) => e);
    } else {
      obj.orderTypes = [];
    }
    message.direction !== undefined && (obj.direction = message.direction);
    message.state !== undefined && (obj.state = message.state);
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
    return StreamOrdersHistoryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
    const message = createBaseStreamOrdersHistoryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.orderTypes = object.orderTypes?.map((e) => e) || [];
    message.direction = object.direction ?? "";
    message.state = object.state ?? "";
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrdersHistoryResponse(): StreamOrdersHistoryResponse {
  return { order: undefined, operationType: "", timestamp: "0" };
}

export const StreamOrdersHistoryResponse = {
  encode(message: StreamOrdersHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      SpotOrderHistory.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order = SpotOrderHistory.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersHistoryResponse {
    return {
      order: isSet(object.order) ? SpotOrderHistory.fromJSON(object.order) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamOrdersHistoryResponse): unknown {
    const obj: any = {};
    message.order !== undefined && (obj.order = message.order ? SpotOrderHistory.toJSON(message.order) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
    return StreamOrdersHistoryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
    const message = createBaseStreamOrdersHistoryResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? SpotOrderHistory.fromPartial(object.order)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

/** InjectiveSpotExchangeRPC defines gRPC API of Spot Exchange provider. */
export interface InjectiveSpotExchangeRPC {
  /** Get a list of Spot Markets */
  Markets(request: DeepPartial<MarketsRequest>, metadata?: grpc.Metadata): Promise<MarketsResponse>;
  /** Get details of a single spot market */
  Market(request: DeepPartial<MarketRequest>, metadata?: grpc.Metadata): Promise<MarketResponse>;
  /** Stream live updates of selected spot markets */
  StreamMarkets(
    request: DeepPartial<StreamMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamMarketsResponse>;
  /** Orderbook of a Spot Market */
  Orderbook(request: DeepPartial<OrderbookRequest>, metadata?: grpc.Metadata): Promise<OrderbookResponse>;
  /** Orderbook of a Spot Market */
  OrderbookV2(request: DeepPartial<OrderbookV2Request>, metadata?: grpc.Metadata): Promise<OrderbookV2Response>;
  /** Orderbook of Spot Markets */
  Orderbooks(request: DeepPartial<OrderbooksRequest>, metadata?: grpc.Metadata): Promise<OrderbooksResponse>;
  /** Orderbook of Spot Markets */
  OrderbooksV2(request: DeepPartial<OrderbooksV2Request>, metadata?: grpc.Metadata): Promise<OrderbooksV2Response>;
  /** Stream live snapshot updates of selected spot market orderbook */
  StreamOrderbook(
    request: DeepPartial<StreamOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookResponse>;
  /** Stream live snapshot updates of selected spot market orderbook */
  StreamOrderbookV2(
    request: DeepPartial<StreamOrderbookV2Request>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookV2Response>;
  /** Stream live level updates of selected spot market orderbook */
  StreamOrderbookUpdate(
    request: DeepPartial<StreamOrderbookUpdateRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookUpdateResponse>;
  /** Orders of a Spot Market */
  Orders(request: DeepPartial<OrdersRequest>, metadata?: grpc.Metadata): Promise<OrdersResponse>;
  /** Stream updates to individual orders of a Spot Market */
  StreamOrders(request: DeepPartial<StreamOrdersRequest>, metadata?: grpc.Metadata): Observable<StreamOrdersResponse>;
  /** Trades of a Spot Market */
  Trades(request: DeepPartial<TradesRequest>, metadata?: grpc.Metadata): Promise<TradesResponse>;
  /** Stream newly executed trades from Spot Market */
  StreamTrades(request: DeepPartial<StreamTradesRequest>, metadata?: grpc.Metadata): Observable<StreamTradesResponse>;
  /** List orders posted from this subaccount */
  SubaccountOrdersList(
    request: DeepPartial<SubaccountOrdersListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrdersListResponse>;
  /** List trades executed by this subaccount */
  SubaccountTradesList(
    request: DeepPartial<SubaccountTradesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountTradesListResponse>;
  /** Lists history orders posted from this subaccount */
  OrdersHistory(request: DeepPartial<OrdersHistoryRequest>, metadata?: grpc.Metadata): Promise<OrdersHistoryResponse>;
  /** Stream updates to historical orders of a spot Market */
  StreamOrdersHistory(
    request: DeepPartial<StreamOrdersHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrdersHistoryResponse>;
}

export class InjectiveSpotExchangeRPCClientImpl implements InjectiveSpotExchangeRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Markets = this.Markets.bind(this);
    this.Market = this.Market.bind(this);
    this.StreamMarkets = this.StreamMarkets.bind(this);
    this.Orderbook = this.Orderbook.bind(this);
    this.OrderbookV2 = this.OrderbookV2.bind(this);
    this.Orderbooks = this.Orderbooks.bind(this);
    this.OrderbooksV2 = this.OrderbooksV2.bind(this);
    this.StreamOrderbook = this.StreamOrderbook.bind(this);
    this.StreamOrderbookV2 = this.StreamOrderbookV2.bind(this);
    this.StreamOrderbookUpdate = this.StreamOrderbookUpdate.bind(this);
    this.Orders = this.Orders.bind(this);
    this.StreamOrders = this.StreamOrders.bind(this);
    this.Trades = this.Trades.bind(this);
    this.StreamTrades = this.StreamTrades.bind(this);
    this.SubaccountOrdersList = this.SubaccountOrdersList.bind(this);
    this.SubaccountTradesList = this.SubaccountTradesList.bind(this);
    this.OrdersHistory = this.OrdersHistory.bind(this);
    this.StreamOrdersHistory = this.StreamOrdersHistory.bind(this);
  }

  Markets(request: DeepPartial<MarketsRequest>, metadata?: grpc.Metadata): Promise<MarketsResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCMarketsDesc, MarketsRequest.fromPartial(request), metadata);
  }

  Market(request: DeepPartial<MarketRequest>, metadata?: grpc.Metadata): Promise<MarketResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCMarketDesc, MarketRequest.fromPartial(request), metadata);
  }

  StreamMarkets(
    request: DeepPartial<StreamMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamMarketsResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamMarketsDesc,
      StreamMarketsRequest.fromPartial(request),
      metadata,
    );
  }

  Orderbook(request: DeepPartial<OrderbookRequest>, metadata?: grpc.Metadata): Promise<OrderbookResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCOrderbookDesc, OrderbookRequest.fromPartial(request), metadata);
  }

  OrderbookV2(request: DeepPartial<OrderbookV2Request>, metadata?: grpc.Metadata): Promise<OrderbookV2Response> {
    return this.rpc.unary(InjectiveSpotExchangeRPCOrderbookV2Desc, OrderbookV2Request.fromPartial(request), metadata);
  }

  Orderbooks(request: DeepPartial<OrderbooksRequest>, metadata?: grpc.Metadata): Promise<OrderbooksResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCOrderbooksDesc, OrderbooksRequest.fromPartial(request), metadata);
  }

  OrderbooksV2(request: DeepPartial<OrderbooksV2Request>, metadata?: grpc.Metadata): Promise<OrderbooksV2Response> {
    return this.rpc.unary(InjectiveSpotExchangeRPCOrderbooksV2Desc, OrderbooksV2Request.fromPartial(request), metadata);
  }

  StreamOrderbook(
    request: DeepPartial<StreamOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamOrderbookDesc,
      StreamOrderbookRequest.fromPartial(request),
      metadata,
    );
  }

  StreamOrderbookV2(
    request: DeepPartial<StreamOrderbookV2Request>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookV2Response> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamOrderbookV2Desc,
      StreamOrderbookV2Request.fromPartial(request),
      metadata,
    );
  }

  StreamOrderbookUpdate(
    request: DeepPartial<StreamOrderbookUpdateRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookUpdateResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamOrderbookUpdateDesc,
      StreamOrderbookUpdateRequest.fromPartial(request),
      metadata,
    );
  }

  Orders(request: DeepPartial<OrdersRequest>, metadata?: grpc.Metadata): Promise<OrdersResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCOrdersDesc, OrdersRequest.fromPartial(request), metadata);
  }

  StreamOrders(request: DeepPartial<StreamOrdersRequest>, metadata?: grpc.Metadata): Observable<StreamOrdersResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamOrdersDesc,
      StreamOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  Trades(request: DeepPartial<TradesRequest>, metadata?: grpc.Metadata): Promise<TradesResponse> {
    return this.rpc.unary(InjectiveSpotExchangeRPCTradesDesc, TradesRequest.fromPartial(request), metadata);
  }

  StreamTrades(request: DeepPartial<StreamTradesRequest>, metadata?: grpc.Metadata): Observable<StreamTradesResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamTradesDesc,
      StreamTradesRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountOrdersList(
    request: DeepPartial<SubaccountOrdersListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrdersListResponse> {
    return this.rpc.unary(
      InjectiveSpotExchangeRPCSubaccountOrdersListDesc,
      SubaccountOrdersListRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountTradesList(
    request: DeepPartial<SubaccountTradesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountTradesListResponse> {
    return this.rpc.unary(
      InjectiveSpotExchangeRPCSubaccountTradesListDesc,
      SubaccountTradesListRequest.fromPartial(request),
      metadata,
    );
  }

  OrdersHistory(request: DeepPartial<OrdersHistoryRequest>, metadata?: grpc.Metadata): Promise<OrdersHistoryResponse> {
    return this.rpc.unary(
      InjectiveSpotExchangeRPCOrdersHistoryDesc,
      OrdersHistoryRequest.fromPartial(request),
      metadata,
    );
  }

  StreamOrdersHistory(
    request: DeepPartial<StreamOrdersHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrdersHistoryResponse> {
    return this.rpc.invoke(
      InjectiveSpotExchangeRPCStreamOrdersHistoryDesc,
      StreamOrdersHistoryRequest.fromPartial(request),
      metadata,
    );
  }
}

export const InjectiveSpotExchangeRPCDesc = { serviceName: "injective_spot_exchange_rpc.InjectiveSpotExchangeRPC" };

export const InjectiveSpotExchangeRPCMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "Markets",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCMarketDesc: UnaryMethodDefinitionish = {
  methodName: "Market",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "StreamMarkets",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamMarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamMarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "Orderbook",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrderbookV2Desc: UnaryMethodDefinitionish = {
  methodName: "OrderbookV2",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbookV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbookV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrderbooksDesc: UnaryMethodDefinitionish = {
  methodName: "Orderbooks",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbooksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbooksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrderbooksV2Desc: UnaryMethodDefinitionish = {
  methodName: "OrderbooksV2",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbooksV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbooksV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbook",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamOrderbookV2Desc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbookV2",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamOrderbookUpdateDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbookUpdate",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookUpdateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookUpdateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "Orders",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrders",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCTradesDesc: UnaryMethodDefinitionish = {
  methodName: "Trades",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamTradesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamTrades",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamTradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamTradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCSubaccountOrdersListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountOrdersList",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountOrdersListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountOrdersListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCSubaccountTradesListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountTradesList",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountTradesListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountTradesListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCOrdersHistoryDesc: UnaryMethodDefinitionish = {
  methodName: "OrdersHistory",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrdersHistoryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrdersHistoryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveSpotExchangeRPCStreamOrdersHistoryDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrdersHistory",
  service: InjectiveSpotExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrdersHistoryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrdersHistoryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes || [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Observable((observer) => {
      const upStream = (() => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          transport: this.options.streamingTransport || this.options.transport,
          metadata: maybeCombinedMetadata,
          debug: this.options.debug,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      });
      upStream();
    }).pipe(share());
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
