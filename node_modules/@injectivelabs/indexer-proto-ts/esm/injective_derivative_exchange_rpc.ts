/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "injective_derivative_exchange_rpc";

export interface MarketsRequest {
  /** Filter by market status */
  marketStatus: string;
  /** Filter by the Coin denomination of the quote currency */
  quoteDenom: string;
}

export interface MarketsResponse {
  /** Derivative Markets list */
  markets: DerivativeMarketInfo[];
}

export interface DerivativeMarketInfo {
  /**
   * DerivativeMarket ID is crypto.Keccak256Hash([]byte((oracleType.String() +
   * ticker + quoteDenom + oracleBase + oracleQuote))) for perpetual markets and
   * crypto.Keccak256Hash([]byte((oracleType.String() + ticker + quoteDenom +
   * oracleBase + oracleQuote + strconv.Itoa(int(expiry))))) for expiry futures
   * markets
   */
  marketId: string;
  /** The status of the market */
  marketStatus: string;
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   */
  ticker: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Oracle Type */
  oracleType: string;
  /** OracleScaleFactor */
  oracleScaleFactor: number;
  /** Defines the initial margin ratio of a derivative market */
  initialMarginRatio: string;
  /** Defines the maintenance margin ratio of a derivative market */
  maintenanceMarginRatio: string;
  /** Coin denom used for the quote asset. */
  quoteDenom: string;
  /** Token metadata for quote asset, only for Ethereum-based assets */
  quoteTokenMeta:
    | TokenMeta
    | undefined;
  /** Defines the fee percentage makers pay when trading (in quote asset) */
  makerFeeRate: string;
  /** Defines the fee percentage takers pay when trading (in quote asset) */
  takerFeeRate: string;
  /** Percentage of the transaction fee shared with the service provider */
  serviceProviderFee: string;
  /** True if the market is a perpetual swap market */
  isPerpetual: boolean;
  /** Defines the minimum required tick size for the order's price */
  minPriceTickSize: string;
  /** Defines the minimum required tick size for the order's quantity */
  minQuantityTickSize: string;
  perpetualMarketInfo: PerpetualMarketInfo | undefined;
  perpetualMarketFunding: PerpetualMarketFunding | undefined;
  expiryFuturesMarketInfo: ExpiryFuturesMarketInfo | undefined;
}

export interface TokenMeta {
  /** Token full name */
  name: string;
  /** Token Ethereum contract address */
  address: string;
  /** Token symbol short name */
  symbol: string;
  /** URL to the logo image */
  logo: string;
  /** Token decimals */
  decimals: number;
  /** Token metadata fetched timestamp in UNIX millis. */
  updatedAt: string;
}

export interface PerpetualMarketInfo {
  /**
   * Defines the default maximum absolute value of the hourly funding rate of the
   * perpetual market.
   */
  hourlyFundingRateCap: string;
  /** Defines the hourly interest rate of the perpetual market. */
  hourlyInterestRate: string;
  /**
   * Defines the next funding timestamp in seconds of a perpetual market in UNIX
   * seconds.
   */
  nextFundingTimestamp: string;
  /** Defines the funding interval in seconds of a perpetual market in seconds. */
  fundingInterval: string;
}

export interface PerpetualMarketFunding {
  /** Defines the cumulative funding of a perpetual market. */
  cumulativeFunding: string;
  /**
   * Defines defines the cumulative price for the current hour up to the last
   * timestamp.
   */
  cumulativePrice: string;
  /**
   * Defines the last funding timestamp in seconds of a perpetual market in UNIX
   * seconds.
   */
  lastTimestamp: string;
}

export interface ExpiryFuturesMarketInfo {
  /** Defines the expiration time for a time expiry futures market in UNIX seconds. */
  expirationTimestamp: string;
  /** Defines the settlement price for a time expiry futures market. */
  settlementPrice: string;
}

export interface MarketRequest {
  /** MarketId of the market we want to fetch */
  marketId: string;
}

export interface MarketResponse {
  /** Info about particular derivative market */
  market: DerivativeMarketInfo | undefined;
}

export interface StreamMarketRequest {
  /**
   * List of market IDs for updates streaming, empty means 'ALL' derivative
   * markets
   */
  marketIds: string[];
}

export interface StreamMarketResponse {
  /** Info about particular derivative market */
  market:
    | DerivativeMarketInfo
    | undefined;
  /** Update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface BinaryOptionsMarketsRequest {
  /** Filter by market status */
  marketStatus: string;
  /** Filter by the Coin denomination of the quote currency */
  quoteDenom: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
}

export interface BinaryOptionsMarketsResponse {
  /** Binary Options Markets list */
  markets: BinaryOptionsMarketInfo[];
  paging: Paging | undefined;
}

export interface BinaryOptionsMarketInfo {
  /**
   * Binary Options Market ID is crypto.Keccak256Hash([]byte((oracleType.String()
   * + ticker + quoteDenom + oracleSymbol + oracleProvider)))
   */
  marketId: string;
  /** The status of the market */
  marketStatus: string;
  /** A name of the binary options market. */
  ticker: string;
  /** Oracle symbol */
  oracleSymbol: string;
  /** Oracle provider */
  oracleProvider: string;
  /** Oracle Type */
  oracleType: string;
  /** OracleScaleFactor */
  oracleScaleFactor: number;
  /** Defines the expiration time for the market in UNIX seconds. */
  expirationTimestamp: string;
  /** Defines the settlement time for the market in UNIX seconds. */
  settlementTimestamp: string;
  /** Coin denom used for the quote asset. */
  quoteDenom: string;
  /** Token metadata for quote asset, only for Ethereum-based assets */
  quoteTokenMeta:
    | TokenMeta
    | undefined;
  /** Defines the fee percentage makers pay when trading (in quote asset) */
  makerFeeRate: string;
  /** Defines the fee percentage takers pay when trading (in quote asset) */
  takerFeeRate: string;
  /** Percentage of the transaction fee shared with the service provider */
  serviceProviderFee: string;
  /** Defines the minimum required tick size for the order's price */
  minPriceTickSize: string;
  /** Defines the minimum required tick size for the order's quantity */
  minQuantityTickSize: string;
  /** Defines the settlement price of the market */
  settlementPrice: string;
}

/** Paging defines the structure for required params for handling pagination */
export interface Paging {
  /** total number of txs saved in database */
  total: string;
  /** can be either block height or index num */
  from: number;
  /** can be either block height or index num */
  to: number;
  /** count entries by subaccount, serving some places on helix */
  countBySubaccount: string;
}

export interface BinaryOptionsMarketRequest {
  /** MarketId of the market we want to fetch */
  marketId: string;
}

export interface BinaryOptionsMarketResponse {
  /** Info about particular derivative market */
  market: BinaryOptionsMarketInfo | undefined;
}

export interface OrderbookRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
}

export interface OrderbookResponse {
  /** Orderbook of a particular derivative market */
  orderbook: DerivativeLimitOrderbook | undefined;
}

export interface DerivativeLimitOrderbook {
  /** Array of price levels for buys */
  buys: PriceLevel[];
  /** Array of price levels for sells */
  sells: PriceLevel[];
  /** Last update timestamp in UNIX millis. */
  timestamp: string;
}

export interface PriceLevel {
  /** Price number of the price level. */
  price: string;
  /** Quantity of the price level. */
  quantity: string;
  /** Price level last updated timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrderbookV2Request {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
}

export interface OrderbookV2Response {
  /** Orderbook of a particular derivative market */
  orderbook: DerivativeLimitOrderbookV2 | undefined;
}

export interface DerivativeLimitOrderbookV2 {
  /** Array of price levels for buys */
  buys: PriceLevel[];
  /** Array of price levels for sells */
  sells: PriceLevel[];
  /** market orderbook sequence */
  sequence: string;
  /** Last update timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrderbooksRequest {
  /** MarketIds of the markets */
  marketIds: string[];
}

export interface OrderbooksResponse {
  orderbooks: SingleDerivativeLimitOrderbook[];
}

export interface SingleDerivativeLimitOrderbook {
  /** market's ID */
  marketId: string;
  /** Orderbook of the market */
  orderbook: DerivativeLimitOrderbook | undefined;
}

export interface OrderbooksV2Request {
  /** MarketIds of the markets */
  marketIds: string[];
}

export interface OrderbooksV2Response {
  orderbooks: SingleDerivativeLimitOrderbookV2[];
}

export interface SingleDerivativeLimitOrderbookV2 {
  /** market's ID */
  marketId: string;
  /** Orderbook of the market */
  orderbook: DerivativeLimitOrderbookV2 | undefined;
}

export interface StreamOrderbookRequest {
  /**
   * List of market IDs for orderbook streaming, empty means 'ALL' derivative
   * markets
   */
  marketIds: string[];
}

export interface StreamOrderbookResponse {
  /** Orderbook of a Derivative Market */
  orderbook:
    | DerivativeLimitOrderbook
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface StreamOrderbookV2Request {
  /**
   * List of market IDs for orderbook streaming, empty means 'ALL' derivative
   * markets
   */
  marketIds: string[];
}

export interface StreamOrderbookV2Response {
  /** Orderbook of a Derivative Market */
  orderbook:
    | DerivativeLimitOrderbookV2
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface StreamOrderbookUpdateRequest {
  /**
   * List of market IDs for orderbook streaming, empty means 'ALL' derivative
   * markets
   */
  marketIds: string[];
}

export interface StreamOrderbookUpdateResponse {
  /** Orderbook level updates of a Derivative Market */
  orderbookLevelUpdates:
    | OrderbookLevelUpdates
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
  /** MarketId of the market's orderbook */
  marketId: string;
}

export interface OrderbookLevelUpdates {
  /** market's ID */
  marketId: string;
  /** orderbook update sequence */
  sequence: string;
  /** buy levels */
  buys: PriceLevelUpdate[];
  /** sell levels */
  sells: PriceLevelUpdate[];
  /** updates timestamp */
  updatedAt: string;
}

export interface PriceLevelUpdate {
  /** Price number of the price level. */
  price: string;
  /** Quantity of the price level. */
  quantity: string;
  /** Price level status. */
  isActive: boolean;
  /** Price level last updated timestamp in UNIX millis. */
  timestamp: string;
}

export interface OrdersRequest {
  /**
   * MarketId of market we want to fetch orders from. Using this field for one
   * single marketId
   */
  marketId: string;
  /** Look for specific order side */
  orderSide: string;
  /** Look for specific subaccountId of an order */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /**
   * MarketIds of the markets of which we want to get order from, use this field
   * for fetching orders from multiple markets
   */
  marketIds: string[];
  /** Only search for conditional/non-conditional orders */
  isConditional: string;
  /** Search for specific order type */
  orderType: string;
  /** Should include inactive orders */
  includeInactive: boolean;
  /** Choose to return subaccount total orders */
  subaccountTotalOrders: boolean;
}

export interface OrdersResponse {
  orders: DerivativeLimitOrder[];
  paging: Paging | undefined;
}

export interface DerivativeLimitOrder {
  /** Hash of the order */
  orderHash: string;
  /** The side of the order */
  orderSide: string;
  /** Derivative Market ID */
  marketId: string;
  /** The subaccountId that this order belongs to */
  subaccountId: string;
  /** True if the order is a reduce-only order */
  isReduceOnly: boolean;
  /** Margin of the order */
  margin: string;
  /** Price of the order */
  price: string;
  /** Quantity of the order */
  quantity: string;
  /** The amount of the quantity remaining unfilled */
  unfilledQuantity: string;
  /** Trigger price is the trigger price used by stop/take orders */
  triggerPrice: string;
  /** Fee recipient address */
  feeRecipient: string;
  /** Order state */
  state: string;
  /** Order committed timestamp in UNIX millis. */
  createdAt: string;
  /** Order updated timestamp in UNIX millis. */
  updatedAt: string;
  /** Order number of subaccount */
  orderNumber: string;
  /** Order type */
  orderType: string;
  /** Order type */
  isConditional: boolean;
  /** Trigger timestamp, only exists for conditional orders */
  triggerAt: string;
  /** OrderHash of order that is triggered by this conditional order */
  placedOrderHash: string;
  /** Execution type of conditional order */
  executionType: string;
}

export interface PositionsRequest {
  /** SubaccountId of the trader we want to get the positions from */
  subaccountId: string;
  /**
   * MarketId of the position we want to fetch. Use this field for fetching from
   * single market
   */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /**
   * MarketIds of the markets we want to filter. Use this field for fetching from
   * multiple markets
   */
  marketIds: string[];
  /** filter by direction of the position */
  direction: string;
  /** set to True to return subaccount total positions */
  subaccountTotalPositions: boolean;
}

export interface PositionsResponse {
  positions: DerivativePosition[];
  paging: Paging | undefined;
}

export interface DerivativePosition {
  /** Ticker of the derivative market */
  ticker: string;
  /** Derivative Market ID */
  marketId: string;
  /** The subaccountId that the position belongs to */
  subaccountId: string;
  /** Direction of the position */
  direction: string;
  /** Quantity of the position */
  quantity: string;
  /** Price of the position */
  entryPrice: string;
  /** Margin of the position */
  margin: string;
  /** LiquidationPrice of the position */
  liquidationPrice: string;
  /** MarkPrice of the position */
  markPrice: string;
  /** Aggregate Quantity of the Reduce Only orders associated with the position */
  aggregateReduceOnlyQuantity: string;
  /** Position updated timestamp in UNIX millis. */
  updatedAt: string;
  /** Position created timestamp in UNIX millis. */
  createdAt: string;
}

export interface LiquidablePositionsRequest {
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
}

export interface LiquidablePositionsResponse {
  /** List of derivative positions */
  positions: DerivativePosition[];
}

export interface FundingPaymentsRequest {
  /** SubaccountId of the trader we want to get the positions from */
  subaccountId: string;
  /**
   * MarketIds of the funding payment we want to fetch. Using this for only one
   * market id. This field is prioritized
   */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /** Upper bound of funding payment updatedAt */
  endTime: string;
  /**
   * Filter by market ids. Using this field for fetching funding payments from
   * multiple market ids
   */
  marketIds: string[];
}

export interface FundingPaymentsResponse {
  /** List of funding payments */
  payments: FundingPayment[];
  paging: Paging | undefined;
}

export interface FundingPayment {
  /** Derivative Market ID */
  marketId: string;
  /** The subaccountId that the position belongs to */
  subaccountId: string;
  /** Amount of the funding payment */
  amount: string;
  /** Timestamp of funding payment in UNIX millis */
  timestamp: string;
}

export interface FundingRatesRequest {
  /** MarketId of the position we want to fetch */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /** Upper bound of funding timestamp */
  endTime: string;
}

export interface FundingRatesResponse {
  /** List of funding rates */
  fundingRates: FundingRate[];
  paging: Paging | undefined;
}

export interface FundingRate {
  /** Derivative Market ID */
  marketId: string;
  /** Value of the funding rate */
  rate: string;
  /** Timestamp of funding rate in UNIX millis */
  timestamp: string;
}

export interface StreamPositionsRequest {
  /** SubaccountId of the trader we want to get the positions from */
  subaccountId: string;
  /** Backward compat single market ID of position we want to stream */
  marketId: string;
  /** List of market IDs of the positions we want to stream */
  marketIds: string[];
  /** Subaccount ids of traders we want to get positions */
  subaccountIds: string[];
}

export interface StreamPositionsResponse {
  /** Updated Derivative Position */
  position:
    | DerivativePosition
    | undefined;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface StreamOrdersRequest {
  /**
   * MarketId of market we want to fetch orders from. Using this field for one
   * single marketId
   */
  marketId: string;
  /** Look for specific order side */
  orderSide: string;
  /** Look for specific subaccountId of an order */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /**
   * MarketIds of the markets of which we want to get order from, use this field
   * for fetching orders from multiple markets
   */
  marketIds: string[];
  /** Only search for conditional/non-conditional orders */
  isConditional: string;
  /** Search for specific order type */
  orderType: string;
  /** Should include inactive orders */
  includeInactive: boolean;
  /** Choose to return subaccount total orders */
  subaccountTotalOrders: boolean;
}

export interface StreamOrdersResponse {
  /** Updated market order */
  order:
    | DerivativeLimitOrder
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface TradesRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Filter by execution side of the trade */
  executionSide: string;
  /** Filter by direction the trade */
  direction: string;
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /**
   * Subaccount ids of traders we want to get trades. Use this field for fetching
   * trades from multiple subaccounts
   */
  subaccountIds: string[];
  executionTypes: string[];
}

export interface TradesResponse {
  /** Trades of a Derivative Market */
  trades: DerivativeTrade[];
  paging: Paging | undefined;
}

export interface DerivativeTrade {
  /** Order hash. */
  orderHash: string;
  /** The subaccountId that executed the trade */
  subaccountId: string;
  /** The ID of the market that this trade is in */
  marketId: string;
  /** The execution type of the trade */
  tradeExecutionType: string;
  /** True if the trade is a liquidation */
  isLiquidation: boolean;
  /** Position Delta from the trade */
  positionDelta:
    | PositionDelta
    | undefined;
  /** The payout associated with the trade */
  payout: string;
  /** The fee associated with the trade */
  fee: string;
  /** Timestamp of trade execution in UNIX millis */
  executedAt: string;
  /** Fee recipient address */
  feeRecipient: string;
  /** A unique string that helps differentiate between trades */
  tradeId: string;
  /** Trade's execution side, marker/taker */
  executionSide: string;
}

export interface PositionDelta {
  /** The direction the trade */
  tradeDirection: string;
  /** Execution Price of the trade. */
  executionPrice: string;
  /** Execution Quantity of the trade. */
  executionQuantity: string;
  /** Execution Margin of the trade. */
  executionMargin: string;
}

export interface StreamTradesRequest {
  /** MarketId of the market's orderbook we want to fetch */
  marketId: string;
  /** Filter by execution side of the trade */
  executionSide: string;
  /** Filter by direction the trade */
  direction: string;
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned. */
  limit: number;
  /**
   * The starting timestamp in UNIX milliseconds that the trades must be equal or
   * older than
   */
  startTime: string;
  /**
   * The ending timestamp in UNIX milliseconds that the trades must be equal or
   * younger than
   */
  endTime: string;
  /** MarketIds of the markets of which we want to get trades */
  marketIds: string[];
  /**
   * Subaccount ids of traders we want to get trades. Use this field for fetching
   * trades from multiple subaccounts
   */
  subaccountIds: string[];
  executionTypes: string[];
}

export interface StreamTradesResponse {
  /** New derivative market trade */
  trade:
    | DerivativeTrade
    | undefined;
  /** Executed trades update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

export interface SubaccountOrdersListRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
}

export interface SubaccountOrdersListResponse {
  /** List of derivative orders */
  orders: DerivativeLimitOrder[];
  paging: Paging | undefined;
}

export interface SubaccountTradesListRequest {
  /** SubaccountId of the trader we want to get the trades from */
  subaccountId: string;
  /** Filter trades by market ID */
  marketId: string;
  /** Filter by execution type of trades */
  executionType: string;
  /** Filter by direction trades */
  direction: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
}

export interface SubaccountTradesListResponse {
  /** List of derivative market trades */
  trades: DerivativeTrade[];
}

export interface OrdersHistoryRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** Skip will skip the first n item from the result */
  skip: string;
  /** Limit is used to specify the maximum number of items to be returned */
  limit: number;
  /** filter by order types */
  orderTypes: string[];
  /** order side filter */
  direction: string;
  /** Search for orders which createdAt >= startTime, time in millisecond */
  startTime: string;
  /** Search for orders which createdAt <= endTime, time in millisecond */
  endTime: string;
  /** Only search for conditional/non-conditional orders */
  isConditional: string;
  /** filter by order type */
  orderType: string;
  /** Filter by order state */
  state: string;
  executionTypes: string[];
  marketIds: string[];
}

export interface OrdersHistoryResponse {
  /** List of historical derivative orders */
  orders: DerivativeOrderHistory[];
  paging: Paging | undefined;
}

export interface DerivativeOrderHistory {
  /** Hash of the order */
  orderHash: string;
  /** Spot Market ID is keccak265(baseDenom + quoteDenom) */
  marketId: string;
  /** active state of the order */
  isActive: boolean;
  /** The subaccountId that this order belongs to */
  subaccountId: string;
  /** The execution type */
  executionType: string;
  /** The side of the order */
  orderType: string;
  /** Price of the order */
  price: string;
  /** Trigger price */
  triggerPrice: string;
  /** Quantity of the order */
  quantity: string;
  /** Filled amount */
  filledQuantity: string;
  /** Order state */
  state: string;
  /** Order committed timestamp in UNIX millis. */
  createdAt: string;
  /** Order updated timestamp in UNIX millis. */
  updatedAt: string;
  /** True if an order is reduce only */
  isReduceOnly: boolean;
  /** Order direction (order side) */
  direction: string;
  /** True if this is conditional order, otherwise false */
  isConditional: boolean;
  /** Trigger timestamp in unix milli */
  triggerAt: string;
  /** Order hash placed when this triggers */
  placedOrderHash: string;
  /** Order's margin */
  margin: string;
}

export interface StreamOrdersHistoryRequest {
  /** subaccount ID to filter orders for specific subaccount */
  subaccountId: string;
  /** Market ID to filter orders for specific market */
  marketId: string;
  /** filter by order types */
  orderTypes: string[];
  /** order side filter */
  direction: string;
  /** Filter by order state */
  state: string;
  executionTypes: string[];
}

export interface StreamOrdersHistoryResponse {
  /** Updated order */
  order:
    | DerivativeOrderHistory
    | undefined;
  /** Order update type */
  operationType: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

function createBaseMarketsRequest(): MarketsRequest {
  return { marketStatus: "", quoteDenom: "" };
}

export const MarketsRequest = {
  encode(message: MarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketStatus !== "") {
      writer.uint32(10).string(message.marketStatus);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(18).string(message.quoteDenom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketStatus = reader.string();
          break;
        case 2:
          message.quoteDenom = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketsRequest {
    return {
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
    };
  },

  toJSON(message: MarketsRequest): unknown {
    const obj: any = {};
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    return obj;
  },

  create(base?: DeepPartial<MarketsRequest>): MarketsRequest {
    return MarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketsRequest>): MarketsRequest {
    const message = createBaseMarketsRequest();
    message.marketStatus = object.marketStatus ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    return message;
  },
};

function createBaseMarketsResponse(): MarketsResponse {
  return { markets: [] };
}

export const MarketsResponse = {
  encode(message: MarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      DerivativeMarketInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(DerivativeMarketInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketsResponse {
    return {
      markets: Array.isArray(object?.markets) ? object.markets.map((e: any) => DerivativeMarketInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: MarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? DerivativeMarketInfo.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MarketsResponse>): MarketsResponse {
    return MarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketsResponse>): MarketsResponse {
    const message = createBaseMarketsResponse();
    message.markets = object.markets?.map((e) => DerivativeMarketInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDerivativeMarketInfo(): DerivativeMarketInfo {
  return {
    marketId: "",
    marketStatus: "",
    ticker: "",
    oracleBase: "",
    oracleQuote: "",
    oracleType: "",
    oracleScaleFactor: 0,
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    quoteDenom: "",
    quoteTokenMeta: undefined,
    makerFeeRate: "",
    takerFeeRate: "",
    serviceProviderFee: "",
    isPerpetual: false,
    minPriceTickSize: "",
    minQuantityTickSize: "",
    perpetualMarketInfo: undefined,
    perpetualMarketFunding: undefined,
    expiryFuturesMarketInfo: undefined,
  };
}

export const DerivativeMarketInfo = {
  encode(message: DerivativeMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.marketStatus !== "") {
      writer.uint32(18).string(message.marketStatus);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.oracleBase !== "") {
      writer.uint32(34).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(42).string(message.oracleQuote);
    }
    if (message.oracleType !== "") {
      writer.uint32(50).string(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(66).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(74).string(message.maintenanceMarginRatio);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(82).string(message.quoteDenom);
    }
    if (message.quoteTokenMeta !== undefined) {
      TokenMeta.encode(message.quoteTokenMeta, writer.uint32(90).fork()).ldelim();
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(98).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(106).string(message.takerFeeRate);
    }
    if (message.serviceProviderFee !== "") {
      writer.uint32(114).string(message.serviceProviderFee);
    }
    if (message.isPerpetual === true) {
      writer.uint32(120).bool(message.isPerpetual);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(130).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(138).string(message.minQuantityTickSize);
    }
    if (message.perpetualMarketInfo !== undefined) {
      PerpetualMarketInfo.encode(message.perpetualMarketInfo, writer.uint32(146).fork()).ldelim();
    }
    if (message.perpetualMarketFunding !== undefined) {
      PerpetualMarketFunding.encode(message.perpetualMarketFunding, writer.uint32(154).fork()).ldelim();
    }
    if (message.expiryFuturesMarketInfo !== undefined) {
      ExpiryFuturesMarketInfo.encode(message.expiryFuturesMarketInfo, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.marketStatus = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.oracleBase = reader.string();
          break;
        case 5:
          message.oracleQuote = reader.string();
          break;
        case 6:
          message.oracleType = reader.string();
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.initialMarginRatio = reader.string();
          break;
        case 9:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 10:
          message.quoteDenom = reader.string();
          break;
        case 11:
          message.quoteTokenMeta = TokenMeta.decode(reader, reader.uint32());
          break;
        case 12:
          message.makerFeeRate = reader.string();
          break;
        case 13:
          message.takerFeeRate = reader.string();
          break;
        case 14:
          message.serviceProviderFee = reader.string();
          break;
        case 15:
          message.isPerpetual = reader.bool();
          break;
        case 16:
          message.minPriceTickSize = reader.string();
          break;
        case 17:
          message.minQuantityTickSize = reader.string();
          break;
        case 18:
          message.perpetualMarketInfo = PerpetualMarketInfo.decode(reader, reader.uint32());
          break;
        case 19:
          message.perpetualMarketFunding = PerpetualMarketFunding.decode(reader, reader.uint32());
          break;
        case 20:
          message.expiryFuturesMarketInfo = ExpiryFuturesMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarketInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleType: isSet(object.oracleType) ? String(object.oracleType) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      quoteTokenMeta: isSet(object.quoteTokenMeta) ? TokenMeta.fromJSON(object.quoteTokenMeta) : undefined,
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      serviceProviderFee: isSet(object.serviceProviderFee) ? String(object.serviceProviderFee) : "",
      isPerpetual: isSet(object.isPerpetual) ? Boolean(object.isPerpetual) : false,
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      perpetualMarketInfo: isSet(object.perpetualMarketInfo)
        ? PerpetualMarketInfo.fromJSON(object.perpetualMarketInfo)
        : undefined,
      perpetualMarketFunding: isSet(object.perpetualMarketFunding)
        ? PerpetualMarketFunding.fromJSON(object.perpetualMarketFunding)
        : undefined,
      expiryFuturesMarketInfo: isSet(object.expiryFuturesMarketInfo)
        ? ExpiryFuturesMarketInfo.fromJSON(object.expiryFuturesMarketInfo)
        : undefined,
    };
  },

  toJSON(message: DerivativeMarketInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleType !== undefined && (obj.oracleType = message.oracleType);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.quoteTokenMeta !== undefined &&
      (obj.quoteTokenMeta = message.quoteTokenMeta ? TokenMeta.toJSON(message.quoteTokenMeta) : undefined);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.serviceProviderFee !== undefined && (obj.serviceProviderFee = message.serviceProviderFee);
    message.isPerpetual !== undefined && (obj.isPerpetual = message.isPerpetual);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.perpetualMarketInfo !== undefined && (obj.perpetualMarketInfo = message.perpetualMarketInfo
      ? PerpetualMarketInfo.toJSON(message.perpetualMarketInfo)
      : undefined);
    message.perpetualMarketFunding !== undefined && (obj.perpetualMarketFunding = message.perpetualMarketFunding
      ? PerpetualMarketFunding.toJSON(message.perpetualMarketFunding)
      : undefined);
    message.expiryFuturesMarketInfo !== undefined && (obj.expiryFuturesMarketInfo = message.expiryFuturesMarketInfo
      ? ExpiryFuturesMarketInfo.toJSON(message.expiryFuturesMarketInfo)
      : undefined);
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarketInfo>): DerivativeMarketInfo {
    return DerivativeMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarketInfo>): DerivativeMarketInfo {
    const message = createBaseDerivativeMarketInfo();
    message.marketId = object.marketId ?? "";
    message.marketStatus = object.marketStatus ?? "";
    message.ticker = object.ticker ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleType = object.oracleType ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.quoteTokenMeta = (object.quoteTokenMeta !== undefined && object.quoteTokenMeta !== null)
      ? TokenMeta.fromPartial(object.quoteTokenMeta)
      : undefined;
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.serviceProviderFee = object.serviceProviderFee ?? "";
    message.isPerpetual = object.isPerpetual ?? false;
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.perpetualMarketInfo = (object.perpetualMarketInfo !== undefined && object.perpetualMarketInfo !== null)
      ? PerpetualMarketInfo.fromPartial(object.perpetualMarketInfo)
      : undefined;
    message.perpetualMarketFunding =
      (object.perpetualMarketFunding !== undefined && object.perpetualMarketFunding !== null)
        ? PerpetualMarketFunding.fromPartial(object.perpetualMarketFunding)
        : undefined;
    message.expiryFuturesMarketInfo =
      (object.expiryFuturesMarketInfo !== undefined && object.expiryFuturesMarketInfo !== null)
        ? ExpiryFuturesMarketInfo.fromPartial(object.expiryFuturesMarketInfo)
        : undefined;
    return message;
  },
};

function createBaseTokenMeta(): TokenMeta {
  return { name: "", address: "", symbol: "", logo: "", decimals: 0, updatedAt: "0" };
}

export const TokenMeta = {
  encode(message: TokenMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.logo !== "") {
      writer.uint32(34).string(message.logo);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).sint32(message.decimals);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(48).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenMeta {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        case 3:
          message.symbol = reader.string();
          break;
        case 4:
          message.logo = reader.string();
          break;
        case 5:
          message.decimals = reader.sint32();
          break;
        case 6:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TokenMeta {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      address: isSet(object.address) ? String(object.address) : "",
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      logo: isSet(object.logo) ? String(object.logo) : "",
      decimals: isSet(object.decimals) ? Number(object.decimals) : 0,
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: TokenMeta): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.address !== undefined && (obj.address = message.address);
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.logo !== undefined && (obj.logo = message.logo);
    message.decimals !== undefined && (obj.decimals = Math.round(message.decimals));
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<TokenMeta>): TokenMeta {
    return TokenMeta.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TokenMeta>): TokenMeta {
    const message = createBaseTokenMeta();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.symbol = object.symbol ?? "";
    message.logo = object.logo ?? "";
    message.decimals = object.decimals ?? 0;
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBasePerpetualMarketInfo(): PerpetualMarketInfo {
  return { hourlyFundingRateCap: "", hourlyInterestRate: "", nextFundingTimestamp: "0", fundingInterval: "0" };
}

export const PerpetualMarketInfo = {
  encode(message: PerpetualMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hourlyFundingRateCap !== "") {
      writer.uint32(10).string(message.hourlyFundingRateCap);
    }
    if (message.hourlyInterestRate !== "") {
      writer.uint32(18).string(message.hourlyInterestRate);
    }
    if (message.nextFundingTimestamp !== "0") {
      writer.uint32(24).sint64(message.nextFundingTimestamp);
    }
    if (message.fundingInterval !== "0") {
      writer.uint32(32).sint64(message.fundingInterval);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hourlyFundingRateCap = reader.string();
          break;
        case 2:
          message.hourlyInterestRate = reader.string();
          break;
        case 3:
          message.nextFundingTimestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.fundingInterval = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketInfo {
    return {
      hourlyFundingRateCap: isSet(object.hourlyFundingRateCap) ? String(object.hourlyFundingRateCap) : "",
      hourlyInterestRate: isSet(object.hourlyInterestRate) ? String(object.hourlyInterestRate) : "",
      nextFundingTimestamp: isSet(object.nextFundingTimestamp) ? String(object.nextFundingTimestamp) : "0",
      fundingInterval: isSet(object.fundingInterval) ? String(object.fundingInterval) : "0",
    };
  },

  toJSON(message: PerpetualMarketInfo): unknown {
    const obj: any = {};
    message.hourlyFundingRateCap !== undefined && (obj.hourlyFundingRateCap = message.hourlyFundingRateCap);
    message.hourlyInterestRate !== undefined && (obj.hourlyInterestRate = message.hourlyInterestRate);
    message.nextFundingTimestamp !== undefined && (obj.nextFundingTimestamp = message.nextFundingTimestamp);
    message.fundingInterval !== undefined && (obj.fundingInterval = message.fundingInterval);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo {
    return PerpetualMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo {
    const message = createBasePerpetualMarketInfo();
    message.hourlyFundingRateCap = object.hourlyFundingRateCap ?? "";
    message.hourlyInterestRate = object.hourlyInterestRate ?? "";
    message.nextFundingTimestamp = object.nextFundingTimestamp ?? "0";
    message.fundingInterval = object.fundingInterval ?? "0";
    return message;
  },
};

function createBasePerpetualMarketFunding(): PerpetualMarketFunding {
  return { cumulativeFunding: "", cumulativePrice: "", lastTimestamp: "0" };
}

export const PerpetualMarketFunding = {
  encode(message: PerpetualMarketFunding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cumulativeFunding !== "") {
      writer.uint32(10).string(message.cumulativeFunding);
    }
    if (message.cumulativePrice !== "") {
      writer.uint32(18).string(message.cumulativePrice);
    }
    if (message.lastTimestamp !== "0") {
      writer.uint32(24).sint64(message.lastTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketFunding {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketFunding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cumulativeFunding = reader.string();
          break;
        case 2:
          message.cumulativePrice = reader.string();
          break;
        case 3:
          message.lastTimestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketFunding {
    return {
      cumulativeFunding: isSet(object.cumulativeFunding) ? String(object.cumulativeFunding) : "",
      cumulativePrice: isSet(object.cumulativePrice) ? String(object.cumulativePrice) : "",
      lastTimestamp: isSet(object.lastTimestamp) ? String(object.lastTimestamp) : "0",
    };
  },

  toJSON(message: PerpetualMarketFunding): unknown {
    const obj: any = {};
    message.cumulativeFunding !== undefined && (obj.cumulativeFunding = message.cumulativeFunding);
    message.cumulativePrice !== undefined && (obj.cumulativePrice = message.cumulativePrice);
    message.lastTimestamp !== undefined && (obj.lastTimestamp = message.lastTimestamp);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding {
    return PerpetualMarketFunding.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding {
    const message = createBasePerpetualMarketFunding();
    message.cumulativeFunding = object.cumulativeFunding ?? "";
    message.cumulativePrice = object.cumulativePrice ?? "";
    message.lastTimestamp = object.lastTimestamp ?? "0";
    return message;
  },
};

function createBaseExpiryFuturesMarketInfo(): ExpiryFuturesMarketInfo {
  return { expirationTimestamp: "0", settlementPrice: "" };
}

export const ExpiryFuturesMarketInfo = {
  encode(message: ExpiryFuturesMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.expirationTimestamp !== "0") {
      writer.uint32(8).sint64(message.expirationTimestamp);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(18).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpiryFuturesMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpiryFuturesMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expirationTimestamp = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpiryFuturesMarketInfo {
    return {
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: ExpiryFuturesMarketInfo): unknown {
    const obj: any = {};
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
    return ExpiryFuturesMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
    const message = createBaseExpiryFuturesMarketInfo();
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBaseMarketRequest(): MarketRequest {
  return { marketId: "" };
}

export const MarketRequest = {
  encode(message: MarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: MarketRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<MarketRequest>): MarketRequest {
    return MarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketRequest>): MarketRequest {
    const message = createBaseMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseMarketResponse(): MarketResponse {
  return { market: undefined };
}

export const MarketResponse = {
  encode(message: MarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      DerivativeMarketInfo.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = DerivativeMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketResponse {
    return { market: isSet(object.market) ? DerivativeMarketInfo.fromJSON(object.market) : undefined };
  },

  toJSON(message: MarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined &&
      (obj.market = message.market ? DerivativeMarketInfo.toJSON(message.market) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MarketResponse>): MarketResponse {
    return MarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketResponse>): MarketResponse {
    const message = createBaseMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? DerivativeMarketInfo.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseStreamMarketRequest(): StreamMarketRequest {
  return { marketIds: [] };
}

export const StreamMarketRequest = {
  encode(message: StreamMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamMarketRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamMarketRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMarketRequest>): StreamMarketRequest {
    return StreamMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamMarketRequest>): StreamMarketRequest {
    const message = createBaseStreamMarketRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamMarketResponse(): StreamMarketResponse {
  return { market: undefined, operationType: "", timestamp: "0" };
}

export const StreamMarketResponse = {
  encode(message: StreamMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      DerivativeMarketInfo.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = DerivativeMarketInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamMarketResponse {
    return {
      market: isSet(object.market) ? DerivativeMarketInfo.fromJSON(object.market) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamMarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined &&
      (obj.market = message.market ? DerivativeMarketInfo.toJSON(message.market) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamMarketResponse>): StreamMarketResponse {
    return StreamMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamMarketResponse>): StreamMarketResponse {
    const message = createBaseStreamMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? DerivativeMarketInfo.fromPartial(object.market)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseBinaryOptionsMarketsRequest(): BinaryOptionsMarketsRequest {
  return { marketStatus: "", quoteDenom: "", skip: "0", limit: 0 };
}

export const BinaryOptionsMarketsRequest = {
  encode(message: BinaryOptionsMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketStatus !== "") {
      writer.uint32(10).string(message.marketStatus);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(18).string(message.quoteDenom);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketStatus = reader.string();
          break;
        case 2:
          message.quoteDenom = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketsRequest {
    return {
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: BinaryOptionsMarketsRequest): unknown {
    const obj: any = {};
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketsRequest>): BinaryOptionsMarketsRequest {
    return BinaryOptionsMarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketsRequest>): BinaryOptionsMarketsRequest {
    const message = createBaseBinaryOptionsMarketsRequest();
    message.marketStatus = object.marketStatus ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseBinaryOptionsMarketsResponse(): BinaryOptionsMarketsResponse {
  return { markets: [], paging: undefined };
}

export const BinaryOptionsMarketsResponse = {
  encode(message: BinaryOptionsMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      BinaryOptionsMarketInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(BinaryOptionsMarketInfo.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketsResponse {
    return {
      markets: Array.isArray(object?.markets)
        ? object.markets.map((e: any) => BinaryOptionsMarketInfo.fromJSON(e))
        : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: BinaryOptionsMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? BinaryOptionsMarketInfo.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketsResponse>): BinaryOptionsMarketsResponse {
    return BinaryOptionsMarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketsResponse>): BinaryOptionsMarketsResponse {
    const message = createBaseBinaryOptionsMarketsResponse();
    message.markets = object.markets?.map((e) => BinaryOptionsMarketInfo.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseBinaryOptionsMarketInfo(): BinaryOptionsMarketInfo {
  return {
    marketId: "",
    marketStatus: "",
    ticker: "",
    oracleSymbol: "",
    oracleProvider: "",
    oracleType: "",
    oracleScaleFactor: 0,
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    quoteDenom: "",
    quoteTokenMeta: undefined,
    makerFeeRate: "",
    takerFeeRate: "",
    serviceProviderFee: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
    settlementPrice: "",
  };
}

export const BinaryOptionsMarketInfo = {
  encode(message: BinaryOptionsMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.marketStatus !== "") {
      writer.uint32(18).string(message.marketStatus);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(34).string(message.oracleSymbol);
    }
    if (message.oracleProvider !== "") {
      writer.uint32(42).string(message.oracleProvider);
    }
    if (message.oracleType !== "") {
      writer.uint32(50).string(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(64).sint64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(72).sint64(message.settlementTimestamp);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(82).string(message.quoteDenom);
    }
    if (message.quoteTokenMeta !== undefined) {
      TokenMeta.encode(message.quoteTokenMeta, writer.uint32(90).fork()).ldelim();
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(98).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(106).string(message.takerFeeRate);
    }
    if (message.serviceProviderFee !== "") {
      writer.uint32(114).string(message.serviceProviderFee);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(122).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(130).string(message.minQuantityTickSize);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(138).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.marketStatus = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.oracleSymbol = reader.string();
          break;
        case 5:
          message.oracleProvider = reader.string();
          break;
        case 6:
          message.oracleType = reader.string();
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.expirationTimestamp = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.settlementTimestamp = longToString(reader.sint64() as Long);
          break;
        case 10:
          message.quoteDenom = reader.string();
          break;
        case 11:
          message.quoteTokenMeta = TokenMeta.decode(reader, reader.uint32());
          break;
        case 12:
          message.makerFeeRate = reader.string();
          break;
        case 13:
          message.takerFeeRate = reader.string();
          break;
        case 14:
          message.serviceProviderFee = reader.string();
          break;
        case 15:
          message.minPriceTickSize = reader.string();
          break;
        case 16:
          message.minQuantityTickSize = reader.string();
          break;
        case 17:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      marketStatus: isSet(object.marketStatus) ? String(object.marketStatus) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? String(object.oracleSymbol) : "",
      oracleProvider: isSet(object.oracleProvider) ? String(object.oracleProvider) : "",
      oracleType: isSet(object.oracleType) ? String(object.oracleType) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      quoteTokenMeta: isSet(object.quoteTokenMeta) ? TokenMeta.fromJSON(object.quoteTokenMeta) : undefined,
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      serviceProviderFee: isSet(object.serviceProviderFee) ? String(object.serviceProviderFee) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: BinaryOptionsMarketInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.marketStatus !== undefined && (obj.marketStatus = message.marketStatus);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleSymbol !== undefined && (obj.oracleSymbol = message.oracleSymbol);
    message.oracleProvider !== undefined && (obj.oracleProvider = message.oracleProvider);
    message.oracleType !== undefined && (obj.oracleType = message.oracleType);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.quoteTokenMeta !== undefined &&
      (obj.quoteTokenMeta = message.quoteTokenMeta ? TokenMeta.toJSON(message.quoteTokenMeta) : undefined);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.serviceProviderFee !== undefined && (obj.serviceProviderFee = message.serviceProviderFee);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketInfo>): BinaryOptionsMarketInfo {
    return BinaryOptionsMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketInfo>): BinaryOptionsMarketInfo {
    const message = createBaseBinaryOptionsMarketInfo();
    message.marketId = object.marketId ?? "";
    message.marketStatus = object.marketStatus ?? "";
    message.ticker = object.ticker ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.oracleProvider = object.oracleProvider ?? "";
    message.oracleType = object.oracleType ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.quoteDenom = object.quoteDenom ?? "";
    message.quoteTokenMeta = (object.quoteTokenMeta !== undefined && object.quoteTokenMeta !== null)
      ? TokenMeta.fromPartial(object.quoteTokenMeta)
      : undefined;
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.serviceProviderFee = object.serviceProviderFee ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBasePaging(): Paging {
  return { total: "0", from: 0, to: 0, countBySubaccount: "0" };
}

export const Paging = {
  encode(message: Paging, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== "0") {
      writer.uint32(8).sint64(message.total);
    }
    if (message.from !== 0) {
      writer.uint32(16).sint32(message.from);
    }
    if (message.to !== 0) {
      writer.uint32(24).sint32(message.to);
    }
    if (message.countBySubaccount !== "0") {
      writer.uint32(32).sint64(message.countBySubaccount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Paging {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaging();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.total = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.from = reader.sint32();
          break;
        case 3:
          message.to = reader.sint32();
          break;
        case 4:
          message.countBySubaccount = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Paging {
    return {
      total: isSet(object.total) ? String(object.total) : "0",
      from: isSet(object.from) ? Number(object.from) : 0,
      to: isSet(object.to) ? Number(object.to) : 0,
      countBySubaccount: isSet(object.countBySubaccount) ? String(object.countBySubaccount) : "0",
    };
  },

  toJSON(message: Paging): unknown {
    const obj: any = {};
    message.total !== undefined && (obj.total = message.total);
    message.from !== undefined && (obj.from = Math.round(message.from));
    message.to !== undefined && (obj.to = Math.round(message.to));
    message.countBySubaccount !== undefined && (obj.countBySubaccount = message.countBySubaccount);
    return obj;
  },

  create(base?: DeepPartial<Paging>): Paging {
    return Paging.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Paging>): Paging {
    const message = createBasePaging();
    message.total = object.total ?? "0";
    message.from = object.from ?? 0;
    message.to = object.to ?? 0;
    message.countBySubaccount = object.countBySubaccount ?? "0";
    return message;
  },
};

function createBaseBinaryOptionsMarketRequest(): BinaryOptionsMarketRequest {
  return { marketId: "" };
}

export const BinaryOptionsMarketRequest = {
  encode(message: BinaryOptionsMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: BinaryOptionsMarketRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketRequest>): BinaryOptionsMarketRequest {
    return BinaryOptionsMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketRequest>): BinaryOptionsMarketRequest {
    const message = createBaseBinaryOptionsMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseBinaryOptionsMarketResponse(): BinaryOptionsMarketResponse {
  return { market: undefined };
}

export const BinaryOptionsMarketResponse = {
  encode(message: BinaryOptionsMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      BinaryOptionsMarketInfo.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = BinaryOptionsMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketResponse {
    return { market: isSet(object.market) ? BinaryOptionsMarketInfo.fromJSON(object.market) : undefined };
  },

  toJSON(message: BinaryOptionsMarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined &&
      (obj.market = message.market ? BinaryOptionsMarketInfo.toJSON(message.market) : undefined);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketResponse>): BinaryOptionsMarketResponse {
    return BinaryOptionsMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketResponse>): BinaryOptionsMarketResponse {
    const message = createBaseBinaryOptionsMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? BinaryOptionsMarketInfo.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseOrderbookRequest(): OrderbookRequest {
  return { marketId: "" };
}

export const OrderbookRequest = {
  encode(message: OrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: OrderbookRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<OrderbookRequest>): OrderbookRequest {
    return OrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookRequest>): OrderbookRequest {
    const message = createBaseOrderbookRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookResponse(): OrderbookResponse {
  return { orderbook: undefined };
}

export const OrderbookResponse = {
  encode(message: OrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbook.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = DerivativeLimitOrderbook.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookResponse {
    return { orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbook.fromJSON(object.orderbook) : undefined };
  },

  toJSON(message: OrderbookResponse): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbook.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrderbookResponse>): OrderbookResponse {
    return OrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookResponse>): OrderbookResponse {
    const message = createBaseOrderbookResponse();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseDerivativeLimitOrderbook(): DerivativeLimitOrderbook {
  return { buys: [], sells: [], timestamp: "0" };
}

export const DerivativeLimitOrderbook = {
  encode(message: DerivativeLimitOrderbook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buys) {
      PriceLevel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevel.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeLimitOrderbook {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeLimitOrderbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buys.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sells.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeLimitOrderbook {
    return {
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevel.fromJSON(e)) : [],
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: DerivativeLimitOrderbook): unknown {
    const obj: any = {};
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<DerivativeLimitOrderbook>): DerivativeLimitOrderbook {
    return DerivativeLimitOrderbook.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeLimitOrderbook>): DerivativeLimitOrderbook {
    const message = createBaseDerivativeLimitOrderbook();
    message.buys = object.buys?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBasePriceLevel(): PriceLevel {
  return { price: "", quantity: "", timestamp: "0" };
}

export const PriceLevel = {
  encode(message: PriceLevel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceLevel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceLevel {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: PriceLevel): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<PriceLevel>): PriceLevel {
    return PriceLevel.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceLevel>): PriceLevel {
    const message = createBasePriceLevel();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrderbookV2Request(): OrderbookV2Request {
  return { marketId: "" };
}

export const OrderbookV2Request = {
  encode(message: OrderbookV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookV2Request {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: OrderbookV2Request): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<OrderbookV2Request>): OrderbookV2Request {
    return OrderbookV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookV2Request>): OrderbookV2Request {
    const message = createBaseOrderbookV2Request();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookV2Response(): OrderbookV2Response {
  return { orderbook: undefined };
}

export const OrderbookV2Response = {
  encode(message: OrderbookV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbookV2.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = DerivativeLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookV2Response {
    return { orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbookV2.fromJSON(object.orderbook) : undefined };
  },

  toJSON(message: OrderbookV2Response): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrderbookV2Response>): OrderbookV2Response {
    return OrderbookV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookV2Response>): OrderbookV2Response {
    const message = createBaseOrderbookV2Response();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseDerivativeLimitOrderbookV2(): DerivativeLimitOrderbookV2 {
  return { buys: [], sells: [], sequence: "0", timestamp: "0" };
}

export const DerivativeLimitOrderbookV2 = {
  encode(message: DerivativeLimitOrderbookV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buys) {
      PriceLevel.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevel.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.sequence !== "0") {
      writer.uint32(24).uint64(message.sequence);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeLimitOrderbookV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeLimitOrderbookV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buys.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sells.push(PriceLevel.decode(reader, reader.uint32()));
          break;
        case 3:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeLimitOrderbookV2 {
    return {
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevel.fromJSON(e)) : [],
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: DerivativeLimitOrderbookV2): unknown {
    const obj: any = {};
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevel.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.sequence !== undefined && (obj.sequence = message.sequence);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<DerivativeLimitOrderbookV2>): DerivativeLimitOrderbookV2 {
    return DerivativeLimitOrderbookV2.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeLimitOrderbookV2>): DerivativeLimitOrderbookV2 {
    const message = createBaseDerivativeLimitOrderbookV2();
    message.buys = object.buys?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevel.fromPartial(e)) || [];
    message.sequence = object.sequence ?? "0";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrderbooksRequest(): OrderbooksRequest {
  return { marketIds: [] };
}

export const OrderbooksRequest = {
  encode(message: OrderbooksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: OrderbooksRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksRequest>): OrderbooksRequest {
    return OrderbooksRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksRequest>): OrderbooksRequest {
    const message = createBaseOrderbooksRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderbooksResponse(): OrderbooksResponse {
  return { orderbooks: [] };
}

export const OrderbooksResponse = {
  encode(message: OrderbooksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderbooks) {
      SingleDerivativeLimitOrderbook.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbooks.push(SingleDerivativeLimitOrderbook.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksResponse {
    return {
      orderbooks: Array.isArray(object?.orderbooks)
        ? object.orderbooks.map((e: any) => SingleDerivativeLimitOrderbook.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderbooksResponse): unknown {
    const obj: any = {};
    if (message.orderbooks) {
      obj.orderbooks = message.orderbooks.map((e) => e ? SingleDerivativeLimitOrderbook.toJSON(e) : undefined);
    } else {
      obj.orderbooks = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksResponse>): OrderbooksResponse {
    return OrderbooksResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksResponse>): OrderbooksResponse {
    const message = createBaseOrderbooksResponse();
    message.orderbooks = object.orderbooks?.map((e) => SingleDerivativeLimitOrderbook.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleDerivativeLimitOrderbook(): SingleDerivativeLimitOrderbook {
  return { marketId: "", orderbook: undefined };
}

export const SingleDerivativeLimitOrderbook = {
  encode(message: SingleDerivativeLimitOrderbook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbook.encode(message.orderbook, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleDerivativeLimitOrderbook {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDerivativeLimitOrderbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderbook = DerivativeLimitOrderbook.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SingleDerivativeLimitOrderbook {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbook.fromJSON(object.orderbook) : undefined,
    };
  },

  toJSON(message: SingleDerivativeLimitOrderbook): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbook.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SingleDerivativeLimitOrderbook>): SingleDerivativeLimitOrderbook {
    return SingleDerivativeLimitOrderbook.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SingleDerivativeLimitOrderbook>): SingleDerivativeLimitOrderbook {
    const message = createBaseSingleDerivativeLimitOrderbook();
    message.marketId = object.marketId ?? "";
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseOrderbooksV2Request(): OrderbooksV2Request {
  return { marketIds: [] };
}

export const OrderbooksV2Request = {
  encode(message: OrderbooksV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksV2Request {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: OrderbooksV2Request): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksV2Request>): OrderbooksV2Request {
    return OrderbooksV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksV2Request>): OrderbooksV2Request {
    const message = createBaseOrderbooksV2Request();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrderbooksV2Response(): OrderbooksV2Response {
  return { orderbooks: [] };
}

export const OrderbooksV2Response = {
  encode(message: OrderbooksV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderbooks) {
      SingleDerivativeLimitOrderbookV2.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbooksV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbooksV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbooks.push(SingleDerivativeLimitOrderbookV2.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbooksV2Response {
    return {
      orderbooks: Array.isArray(object?.orderbooks)
        ? object.orderbooks.map((e: any) => SingleDerivativeLimitOrderbookV2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrderbooksV2Response): unknown {
    const obj: any = {};
    if (message.orderbooks) {
      obj.orderbooks = message.orderbooks.map((e) => e ? SingleDerivativeLimitOrderbookV2.toJSON(e) : undefined);
    } else {
      obj.orderbooks = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrderbooksV2Response>): OrderbooksV2Response {
    return OrderbooksV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbooksV2Response>): OrderbooksV2Response {
    const message = createBaseOrderbooksV2Response();
    message.orderbooks = object.orderbooks?.map((e) => SingleDerivativeLimitOrderbookV2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSingleDerivativeLimitOrderbookV2(): SingleDerivativeLimitOrderbookV2 {
  return { marketId: "", orderbook: undefined };
}

export const SingleDerivativeLimitOrderbookV2 = {
  encode(message: SingleDerivativeLimitOrderbookV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbookV2.encode(message.orderbook, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingleDerivativeLimitOrderbookV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleDerivativeLimitOrderbookV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderbook = DerivativeLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SingleDerivativeLimitOrderbookV2 {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbookV2.fromJSON(object.orderbook) : undefined,
    };
  },

  toJSON(message: SingleDerivativeLimitOrderbookV2): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SingleDerivativeLimitOrderbookV2>): SingleDerivativeLimitOrderbookV2 {
    return SingleDerivativeLimitOrderbookV2.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SingleDerivativeLimitOrderbookV2>): SingleDerivativeLimitOrderbookV2 {
    const message = createBaseSingleDerivativeLimitOrderbookV2();
    message.marketId = object.marketId ?? "";
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    return message;
  },
};

function createBaseStreamOrderbookRequest(): StreamOrderbookRequest {
  return { marketIds: [] };
}

export const StreamOrderbookRequest = {
  encode(message: StreamOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookRequest>): StreamOrderbookRequest {
    return StreamOrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookRequest>): StreamOrderbookRequest {
    const message = createBaseStreamOrderbookRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookResponse(): StreamOrderbookResponse {
  return { orderbook: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookResponse = {
  encode(message: StreamOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbook.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = DerivativeLimitOrderbook.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookResponse {
    return {
      orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbook.fromJSON(object.orderbook) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookResponse): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbook.toJSON(message.orderbook) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookResponse>): StreamOrderbookResponse {
    return StreamOrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookResponse>): StreamOrderbookResponse {
    const message = createBaseStreamOrderbookResponse();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbook.fromPartial(object.orderbook)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseStreamOrderbookV2Request(): StreamOrderbookV2Request {
  return { marketIds: [] };
}

export const StreamOrderbookV2Request = {
  encode(message: StreamOrderbookV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookV2Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookV2Request {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookV2Request): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookV2Request>): StreamOrderbookV2Request {
    return StreamOrderbookV2Request.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookV2Request>): StreamOrderbookV2Request {
    const message = createBaseStreamOrderbookV2Request();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookV2Response(): StreamOrderbookV2Response {
  return { orderbook: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookV2Response = {
  encode(message: StreamOrderbookV2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbook !== undefined) {
      DerivativeLimitOrderbookV2.encode(message.orderbook, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookV2Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookV2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbook = DerivativeLimitOrderbookV2.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookV2Response {
    return {
      orderbook: isSet(object.orderbook) ? DerivativeLimitOrderbookV2.fromJSON(object.orderbook) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookV2Response): unknown {
    const obj: any = {};
    message.orderbook !== undefined &&
      (obj.orderbook = message.orderbook ? DerivativeLimitOrderbookV2.toJSON(message.orderbook) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookV2Response>): StreamOrderbookV2Response {
    return StreamOrderbookV2Response.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookV2Response>): StreamOrderbookV2Response {
    const message = createBaseStreamOrderbookV2Response();
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? DerivativeLimitOrderbookV2.fromPartial(object.orderbook)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseStreamOrderbookUpdateRequest(): StreamOrderbookUpdateRequest {
  return { marketIds: [] };
}

export const StreamOrderbookUpdateRequest = {
  encode(message: StreamOrderbookUpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookUpdateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookUpdateRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: StreamOrderbookUpdateRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
    return StreamOrderbookUpdateRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookUpdateRequest>): StreamOrderbookUpdateRequest {
    const message = createBaseStreamOrderbookUpdateRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrderbookUpdateResponse(): StreamOrderbookUpdateResponse {
  return { orderbookLevelUpdates: undefined, operationType: "", timestamp: "0", marketId: "" };
}

export const StreamOrderbookUpdateResponse = {
  encode(message: StreamOrderbookUpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderbookLevelUpdates !== undefined) {
      OrderbookLevelUpdates.encode(message.orderbookLevelUpdates, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrderbookUpdateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrderbookUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderbookLevelUpdates = OrderbookLevelUpdates.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 4:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrderbookUpdateResponse {
    return {
      orderbookLevelUpdates: isSet(object.orderbookLevelUpdates)
        ? OrderbookLevelUpdates.fromJSON(object.orderbookLevelUpdates)
        : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: StreamOrderbookUpdateResponse): unknown {
    const obj: any = {};
    message.orderbookLevelUpdates !== undefined && (obj.orderbookLevelUpdates = message.orderbookLevelUpdates
      ? OrderbookLevelUpdates.toJSON(message.orderbookLevelUpdates)
      : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
    return StreamOrderbookUpdateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrderbookUpdateResponse>): StreamOrderbookUpdateResponse {
    const message = createBaseStreamOrderbookUpdateResponse();
    message.orderbookLevelUpdates =
      (object.orderbookLevelUpdates !== undefined && object.orderbookLevelUpdates !== null)
        ? OrderbookLevelUpdates.fromPartial(object.orderbookLevelUpdates)
        : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseOrderbookLevelUpdates(): OrderbookLevelUpdates {
  return { marketId: "", sequence: "0", buys: [], sells: [], updatedAt: "0" };
}

export const OrderbookLevelUpdates = {
  encode(message: OrderbookLevelUpdates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.sequence !== "0") {
      writer.uint32(16).uint64(message.sequence);
    }
    for (const v of message.buys) {
      PriceLevelUpdate.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.sells) {
      PriceLevelUpdate.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.updatedAt !== "0") {
      writer.uint32(40).sint64(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookLevelUpdates {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookLevelUpdates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.buys.push(PriceLevelUpdate.decode(reader, reader.uint32()));
          break;
        case 4:
          message.sells.push(PriceLevelUpdate.decode(reader, reader.uint32()));
          break;
        case 5:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderbookLevelUpdates {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      buys: Array.isArray(object?.buys) ? object.buys.map((e: any) => PriceLevelUpdate.fromJSON(e)) : [],
      sells: Array.isArray(object?.sells) ? object.sells.map((e: any) => PriceLevelUpdate.fromJSON(e)) : [],
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
    };
  },

  toJSON(message: OrderbookLevelUpdates): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.sequence !== undefined && (obj.sequence = message.sequence);
    if (message.buys) {
      obj.buys = message.buys.map((e) => e ? PriceLevelUpdate.toJSON(e) : undefined);
    } else {
      obj.buys = [];
    }
    if (message.sells) {
      obj.sells = message.sells.map((e) => e ? PriceLevelUpdate.toJSON(e) : undefined);
    } else {
      obj.sells = [];
    }
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    return obj;
  },

  create(base?: DeepPartial<OrderbookLevelUpdates>): OrderbookLevelUpdates {
    return OrderbookLevelUpdates.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderbookLevelUpdates>): OrderbookLevelUpdates {
    const message = createBaseOrderbookLevelUpdates();
    message.marketId = object.marketId ?? "";
    message.sequence = object.sequence ?? "0";
    message.buys = object.buys?.map((e) => PriceLevelUpdate.fromPartial(e)) || [];
    message.sells = object.sells?.map((e) => PriceLevelUpdate.fromPartial(e)) || [];
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBasePriceLevelUpdate(): PriceLevelUpdate {
  return { price: "", quantity: "", isActive: false, timestamp: "0" };
}

export const PriceLevelUpdate = {
  encode(message: PriceLevelUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.isActive === true) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceLevelUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.isActive = reader.bool();
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceLevelUpdate {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      isActive: isSet(object.isActive) ? Boolean(object.isActive) : false,
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: PriceLevelUpdate): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.isActive !== undefined && (obj.isActive = message.isActive);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<PriceLevelUpdate>): PriceLevelUpdate {
    return PriceLevelUpdate.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceLevelUpdate>): PriceLevelUpdate {
    const message = createBasePriceLevelUpdate();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.isActive = object.isActive ?? false;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseOrdersRequest(): OrdersRequest {
  return {
    marketId: "",
    orderSide: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    isConditional: "",
    orderType: "",
    includeInactive: false,
    subaccountTotalOrders: false,
  };
}

export const OrdersRequest = {
  encode(message: OrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(32).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(40).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(48).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(56).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(66).string(v!);
    }
    if (message.isConditional !== "") {
      writer.uint32(74).string(message.isConditional);
    }
    if (message.orderType !== "") {
      writer.uint32(82).string(message.orderType);
    }
    if (message.includeInactive === true) {
      writer.uint32(88).bool(message.includeInactive);
    }
    if (message.subaccountTotalOrders === true) {
      writer.uint32(96).bool(message.subaccountTotalOrders);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.limit = reader.sint32();
          break;
        case 6:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 7:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.marketIds.push(reader.string());
          break;
        case 9:
          message.isConditional = reader.string();
          break;
        case 10:
          message.orderType = reader.string();
          break;
        case 11:
          message.includeInactive = reader.bool();
          break;
        case 12:
          message.subaccountTotalOrders = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      isConditional: isSet(object.isConditional) ? String(object.isConditional) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      includeInactive: isSet(object.includeInactive) ? Boolean(object.includeInactive) : false,
      subaccountTotalOrders: isSet(object.subaccountTotalOrders) ? Boolean(object.subaccountTotalOrders) : false,
    };
  },

  toJSON(message: OrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    message.isConditional !== undefined && (obj.isConditional = message.isConditional);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.includeInactive !== undefined && (obj.includeInactive = message.includeInactive);
    message.subaccountTotalOrders !== undefined && (obj.subaccountTotalOrders = message.subaccountTotalOrders);
    return obj;
  },

  create(base?: DeepPartial<OrdersRequest>): OrdersRequest {
    return OrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersRequest>): OrdersRequest {
    const message = createBaseOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.orderSide = object.orderSide ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.isConditional = object.isConditional ?? "";
    message.orderType = object.orderType ?? "";
    message.includeInactive = object.includeInactive ?? false;
    message.subaccountTotalOrders = object.subaccountTotalOrders ?? false;
    return message;
  },
};

function createBaseOrdersResponse(): OrdersResponse {
  return { orders: [], paging: undefined };
}

export const OrdersResponse = {
  encode(message: OrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      DerivativeLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(DerivativeLimitOrder.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => DerivativeLimitOrder.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: OrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? DerivativeLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrdersResponse>): OrdersResponse {
    return OrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersResponse>): OrdersResponse {
    const message = createBaseOrdersResponse();
    message.orders = object.orders?.map((e) => DerivativeLimitOrder.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseDerivativeLimitOrder(): DerivativeLimitOrder {
  return {
    orderHash: "",
    orderSide: "",
    marketId: "",
    subaccountId: "",
    isReduceOnly: false,
    margin: "",
    price: "",
    quantity: "",
    unfilledQuantity: "",
    triggerPrice: "",
    feeRecipient: "",
    state: "",
    createdAt: "0",
    updatedAt: "0",
    orderNumber: "0",
    orderType: "",
    isConditional: false,
    triggerAt: "0",
    placedOrderHash: "",
    executionType: "",
  };
}

export const DerivativeLimitOrder = {
  encode(message: DerivativeLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.isReduceOnly === true) {
      writer.uint32(40).bool(message.isReduceOnly);
    }
    if (message.margin !== "") {
      writer.uint32(50).string(message.margin);
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(66).string(message.quantity);
    }
    if (message.unfilledQuantity !== "") {
      writer.uint32(74).string(message.unfilledQuantity);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(82).string(message.triggerPrice);
    }
    if (message.feeRecipient !== "") {
      writer.uint32(90).string(message.feeRecipient);
    }
    if (message.state !== "") {
      writer.uint32(98).string(message.state);
    }
    if (message.createdAt !== "0") {
      writer.uint32(104).sint64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(112).sint64(message.updatedAt);
    }
    if (message.orderNumber !== "0") {
      writer.uint32(120).sint64(message.orderNumber);
    }
    if (message.orderType !== "") {
      writer.uint32(130).string(message.orderType);
    }
    if (message.isConditional === true) {
      writer.uint32(136).bool(message.isConditional);
    }
    if (message.triggerAt !== "0") {
      writer.uint32(144).uint64(message.triggerAt);
    }
    if (message.placedOrderHash !== "") {
      writer.uint32(154).string(message.placedOrderHash);
    }
    if (message.executionType !== "") {
      writer.uint32(162).string(message.executionType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.isReduceOnly = reader.bool();
          break;
        case 6:
          message.margin = reader.string();
          break;
        case 7:
          message.price = reader.string();
          break;
        case 8:
          message.quantity = reader.string();
          break;
        case 9:
          message.unfilledQuantity = reader.string();
          break;
        case 10:
          message.triggerPrice = reader.string();
          break;
        case 11:
          message.feeRecipient = reader.string();
          break;
        case 12:
          message.state = reader.string();
          break;
        case 13:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        case 14:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        case 15:
          message.orderNumber = longToString(reader.sint64() as Long);
          break;
        case 16:
          message.orderType = reader.string();
          break;
        case 17:
          message.isConditional = reader.bool();
          break;
        case 18:
          message.triggerAt = longToString(reader.uint64() as Long);
          break;
        case 19:
          message.placedOrderHash = reader.string();
          break;
        case 20:
          message.executionType = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeLimitOrder {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      isReduceOnly: isSet(object.isReduceOnly) ? Boolean(object.isReduceOnly) : false,
      margin: isSet(object.margin) ? String(object.margin) : "",
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      unfilledQuantity: isSet(object.unfilledQuantity) ? String(object.unfilledQuantity) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
      state: isSet(object.state) ? String(object.state) : "",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
      orderNumber: isSet(object.orderNumber) ? String(object.orderNumber) : "0",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      isConditional: isSet(object.isConditional) ? Boolean(object.isConditional) : false,
      triggerAt: isSet(object.triggerAt) ? String(object.triggerAt) : "0",
      placedOrderHash: isSet(object.placedOrderHash) ? String(object.placedOrderHash) : "",
      executionType: isSet(object.executionType) ? String(object.executionType) : "",
    };
  },

  toJSON(message: DerivativeLimitOrder): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.isReduceOnly !== undefined && (obj.isReduceOnly = message.isReduceOnly);
    message.margin !== undefined && (obj.margin = message.margin);
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.unfilledQuantity !== undefined && (obj.unfilledQuantity = message.unfilledQuantity);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
    message.state !== undefined && (obj.state = message.state);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    message.orderNumber !== undefined && (obj.orderNumber = message.orderNumber);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.isConditional !== undefined && (obj.isConditional = message.isConditional);
    message.triggerAt !== undefined && (obj.triggerAt = message.triggerAt);
    message.placedOrderHash !== undefined && (obj.placedOrderHash = message.placedOrderHash);
    message.executionType !== undefined && (obj.executionType = message.executionType);
    return obj;
  },

  create(base?: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder {
    return DerivativeLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder {
    const message = createBaseDerivativeLimitOrder();
    message.orderHash = object.orderHash ?? "";
    message.orderSide = object.orderSide ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.isReduceOnly = object.isReduceOnly ?? false;
    message.margin = object.margin ?? "";
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.unfilledQuantity = object.unfilledQuantity ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.feeRecipient = object.feeRecipient ?? "";
    message.state = object.state ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.orderNumber = object.orderNumber ?? "0";
    message.orderType = object.orderType ?? "";
    message.isConditional = object.isConditional ?? false;
    message.triggerAt = object.triggerAt ?? "0";
    message.placedOrderHash = object.placedOrderHash ?? "";
    message.executionType = object.executionType ?? "";
    return message;
  },
};

function createBasePositionsRequest(): PositionsRequest {
  return {
    subaccountId: "",
    marketId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    direction: "",
    subaccountTotalPositions: false,
  };
}

export const PositionsRequest = {
  encode(message: PositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(40).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(48).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(58).string(v!);
    }
    if (message.direction !== "") {
      writer.uint32(66).string(message.direction);
    }
    if (message.subaccountTotalPositions === true) {
      writer.uint32(72).bool(message.subaccountTotalPositions);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PositionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        case 5:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 6:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 7:
          message.marketIds.push(reader.string());
          break;
        case 8:
          message.direction = reader.string();
          break;
        case 9:
          message.subaccountTotalPositions = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PositionsRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      direction: isSet(object.direction) ? String(object.direction) : "",
      subaccountTotalPositions: isSet(object.subaccountTotalPositions)
        ? Boolean(object.subaccountTotalPositions)
        : false,
    };
  },

  toJSON(message: PositionsRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    message.direction !== undefined && (obj.direction = message.direction);
    message.subaccountTotalPositions !== undefined && (obj.subaccountTotalPositions = message.subaccountTotalPositions);
    return obj;
  },

  create(base?: DeepPartial<PositionsRequest>): PositionsRequest {
    return PositionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PositionsRequest>): PositionsRequest {
    const message = createBasePositionsRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.direction = object.direction ?? "";
    message.subaccountTotalPositions = object.subaccountTotalPositions ?? false;
    return message;
  },
};

function createBasePositionsResponse(): PositionsResponse {
  return { positions: [], paging: undefined };
}

export const PositionsResponse = {
  encode(message: PositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.positions) {
      DerivativePosition.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PositionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.positions.push(DerivativePosition.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PositionsResponse {
    return {
      positions: Array.isArray(object?.positions)
        ? object.positions.map((e: any) => DerivativePosition.fromJSON(e))
        : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: PositionsResponse): unknown {
    const obj: any = {};
    if (message.positions) {
      obj.positions = message.positions.map((e) => e ? DerivativePosition.toJSON(e) : undefined);
    } else {
      obj.positions = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<PositionsResponse>): PositionsResponse {
    return PositionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PositionsResponse>): PositionsResponse {
    const message = createBasePositionsResponse();
    message.positions = object.positions?.map((e) => DerivativePosition.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseDerivativePosition(): DerivativePosition {
  return {
    ticker: "",
    marketId: "",
    subaccountId: "",
    direction: "",
    quantity: "",
    entryPrice: "",
    margin: "",
    liquidationPrice: "",
    markPrice: "",
    aggregateReduceOnlyQuantity: "",
    updatedAt: "0",
    createdAt: "0",
  };
}

export const DerivativePosition = {
  encode(message: DerivativePosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticker !== "") {
      writer.uint32(10).string(message.ticker);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.quantity !== "") {
      writer.uint32(42).string(message.quantity);
    }
    if (message.entryPrice !== "") {
      writer.uint32(50).string(message.entryPrice);
    }
    if (message.margin !== "") {
      writer.uint32(58).string(message.margin);
    }
    if (message.liquidationPrice !== "") {
      writer.uint32(66).string(message.liquidationPrice);
    }
    if (message.markPrice !== "") {
      writer.uint32(74).string(message.markPrice);
    }
    if (message.aggregateReduceOnlyQuantity !== "") {
      writer.uint32(90).string(message.aggregateReduceOnlyQuantity);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(96).sint64(message.updatedAt);
    }
    if (message.createdAt !== "0") {
      writer.uint32(104).sint64(message.createdAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativePosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ticker = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.quantity = reader.string();
          break;
        case 6:
          message.entryPrice = reader.string();
          break;
        case 7:
          message.margin = reader.string();
          break;
        case 8:
          message.liquidationPrice = reader.string();
          break;
        case 9:
          message.markPrice = reader.string();
          break;
        case 11:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case 12:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        case 13:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativePosition {
    return {
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      entryPrice: isSet(object.entryPrice) ? String(object.entryPrice) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
      liquidationPrice: isSet(object.liquidationPrice) ? String(object.liquidationPrice) : "",
      markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
      aggregateReduceOnlyQuantity: isSet(object.aggregateReduceOnlyQuantity)
        ? String(object.aggregateReduceOnlyQuantity)
        : "",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
    };
  },

  toJSON(message: DerivativePosition): unknown {
    const obj: any = {};
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.direction !== undefined && (obj.direction = message.direction);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.entryPrice !== undefined && (obj.entryPrice = message.entryPrice);
    message.margin !== undefined && (obj.margin = message.margin);
    message.liquidationPrice !== undefined && (obj.liquidationPrice = message.liquidationPrice);
    message.markPrice !== undefined && (obj.markPrice = message.markPrice);
    message.aggregateReduceOnlyQuantity !== undefined &&
      (obj.aggregateReduceOnlyQuantity = message.aggregateReduceOnlyQuantity);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    return obj;
  },

  create(base?: DeepPartial<DerivativePosition>): DerivativePosition {
    return DerivativePosition.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativePosition>): DerivativePosition {
    const message = createBaseDerivativePosition();
    message.ticker = object.ticker ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.direction = object.direction ?? "";
    message.quantity = object.quantity ?? "";
    message.entryPrice = object.entryPrice ?? "";
    message.margin = object.margin ?? "";
    message.liquidationPrice = object.liquidationPrice ?? "";
    message.markPrice = object.markPrice ?? "";
    message.aggregateReduceOnlyQuantity = object.aggregateReduceOnlyQuantity ?? "";
    message.updatedAt = object.updatedAt ?? "0";
    message.createdAt = object.createdAt ?? "0";
    return message;
  },
};

function createBaseLiquidablePositionsRequest(): LiquidablePositionsRequest {
  return { marketId: "", skip: "0", limit: 0 };
}

export const LiquidablePositionsRequest = {
  encode(message: LiquidablePositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(16).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(24).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LiquidablePositionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiquidablePositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LiquidablePositionsRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: LiquidablePositionsRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<LiquidablePositionsRequest>): LiquidablePositionsRequest {
    return LiquidablePositionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<LiquidablePositionsRequest>): LiquidablePositionsRequest {
    const message = createBaseLiquidablePositionsRequest();
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseLiquidablePositionsResponse(): LiquidablePositionsResponse {
  return { positions: [] };
}

export const LiquidablePositionsResponse = {
  encode(message: LiquidablePositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.positions) {
      DerivativePosition.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LiquidablePositionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiquidablePositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.positions.push(DerivativePosition.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LiquidablePositionsResponse {
    return {
      positions: Array.isArray(object?.positions)
        ? object.positions.map((e: any) => DerivativePosition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LiquidablePositionsResponse): unknown {
    const obj: any = {};
    if (message.positions) {
      obj.positions = message.positions.map((e) => e ? DerivativePosition.toJSON(e) : undefined);
    } else {
      obj.positions = [];
    }
    return obj;
  },

  create(base?: DeepPartial<LiquidablePositionsResponse>): LiquidablePositionsResponse {
    return LiquidablePositionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<LiquidablePositionsResponse>): LiquidablePositionsResponse {
    const message = createBaseLiquidablePositionsResponse();
    message.positions = object.positions?.map((e) => DerivativePosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFundingPaymentsRequest(): FundingPaymentsRequest {
  return { subaccountId: "", marketId: "", skip: "0", limit: 0, endTime: "0", marketIds: [] };
}

export const FundingPaymentsRequest = {
  encode(message: FundingPaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    if (message.endTime !== "0") {
      writer.uint32(40).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingPaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        case 5:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 6:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingPaymentsRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: FundingPaymentsRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<FundingPaymentsRequest>): FundingPaymentsRequest {
    return FundingPaymentsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingPaymentsRequest>): FundingPaymentsRequest {
    const message = createBaseFundingPaymentsRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFundingPaymentsResponse(): FundingPaymentsResponse {
  return { payments: [], paging: undefined };
}

export const FundingPaymentsResponse = {
  encode(message: FundingPaymentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payments) {
      FundingPayment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingPaymentsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.payments.push(FundingPayment.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingPaymentsResponse {
    return {
      payments: Array.isArray(object?.payments) ? object.payments.map((e: any) => FundingPayment.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: FundingPaymentsResponse): unknown {
    const obj: any = {};
    if (message.payments) {
      obj.payments = message.payments.map((e) => e ? FundingPayment.toJSON(e) : undefined);
    } else {
      obj.payments = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<FundingPaymentsResponse>): FundingPaymentsResponse {
    return FundingPaymentsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingPaymentsResponse>): FundingPaymentsResponse {
    const message = createBaseFundingPaymentsResponse();
    message.payments = object.payments?.map((e) => FundingPayment.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseFundingPayment(): FundingPayment {
  return { marketId: "", subaccountId: "", amount: "", timestamp: "0" };
}

export const FundingPayment = {
  encode(message: FundingPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingPayment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.amount = reader.string();
          break;
        case 4:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingPayment {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: FundingPayment): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.amount !== undefined && (obj.amount = message.amount);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<FundingPayment>): FundingPayment {
    return FundingPayment.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingPayment>): FundingPayment {
    const message = createBaseFundingPayment();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.amount = object.amount ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseFundingRatesRequest(): FundingRatesRequest {
  return { marketId: "", skip: "0", limit: 0, endTime: "0" };
}

export const FundingRatesRequest = {
  encode(message: FundingRatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(16).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(24).sint32(message.limit);
    }
    if (message.endTime !== "0") {
      writer.uint32(32).sint64(message.endTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingRatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingRatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.limit = reader.sint32();
          break;
        case 4:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingRatesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
    };
  },

  toJSON(message: FundingRatesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.endTime !== undefined && (obj.endTime = message.endTime);
    return obj;
  },

  create(base?: DeepPartial<FundingRatesRequest>): FundingRatesRequest {
    return FundingRatesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingRatesRequest>): FundingRatesRequest {
    const message = createBaseFundingRatesRequest();
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.endTime = object.endTime ?? "0";
    return message;
  },
};

function createBaseFundingRatesResponse(): FundingRatesResponse {
  return { fundingRates: [], paging: undefined };
}

export const FundingRatesResponse = {
  encode(message: FundingRatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fundingRates) {
      FundingRate.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingRatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingRatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fundingRates.push(FundingRate.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingRatesResponse {
    return {
      fundingRates: Array.isArray(object?.fundingRates)
        ? object.fundingRates.map((e: any) => FundingRate.fromJSON(e))
        : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: FundingRatesResponse): unknown {
    const obj: any = {};
    if (message.fundingRates) {
      obj.fundingRates = message.fundingRates.map((e) => e ? FundingRate.toJSON(e) : undefined);
    } else {
      obj.fundingRates = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<FundingRatesResponse>): FundingRatesResponse {
    return FundingRatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingRatesResponse>): FundingRatesResponse {
    const message = createBaseFundingRatesResponse();
    message.fundingRates = object.fundingRates?.map((e) => FundingRate.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseFundingRate(): FundingRate {
  return { marketId: "", rate: "", timestamp: "0" };
}

export const FundingRate = {
  encode(message: FundingRate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.rate !== "") {
      writer.uint32(18).string(message.rate);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FundingRate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundingRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.rate = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FundingRate {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      rate: isSet(object.rate) ? String(object.rate) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: FundingRate): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.rate !== undefined && (obj.rate = message.rate);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<FundingRate>): FundingRate {
    return FundingRate.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FundingRate>): FundingRate {
    const message = createBaseFundingRate();
    message.marketId = object.marketId ?? "";
    message.rate = object.rate ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseStreamPositionsRequest(): StreamPositionsRequest {
  return { subaccountId: "", marketId: "", marketIds: [], subaccountIds: [] };
}

export const StreamPositionsRequest = {
  encode(message: StreamPositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    for (const v of message.marketIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.subaccountIds) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPositionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.marketIds.push(reader.string());
          break;
        case 4:
          message.subaccountIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamPositionsRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      subaccountIds: Array.isArray(object?.subaccountIds) ? object.subaccountIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamPositionsRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => e);
    } else {
      obj.subaccountIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamPositionsRequest>): StreamPositionsRequest {
    return StreamPositionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamPositionsRequest>): StreamPositionsRequest {
    const message = createBaseStreamPositionsRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamPositionsResponse(): StreamPositionsResponse {
  return { position: undefined, timestamp: "0" };
}

export const StreamPositionsResponse = {
  encode(message: StreamPositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      DerivativePosition.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPositionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.position = DerivativePosition.decode(reader, reader.uint32());
          break;
        case 2:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamPositionsResponse {
    return {
      position: isSet(object.position) ? DerivativePosition.fromJSON(object.position) : undefined,
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamPositionsResponse): unknown {
    const obj: any = {};
    message.position !== undefined &&
      (obj.position = message.position ? DerivativePosition.toJSON(message.position) : undefined);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamPositionsResponse>): StreamPositionsResponse {
    return StreamPositionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamPositionsResponse>): StreamPositionsResponse {
    const message = createBaseStreamPositionsResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? DerivativePosition.fromPartial(object.position)
      : undefined;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseStreamOrdersRequest(): StreamOrdersRequest {
  return {
    marketId: "",
    orderSide: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    isConditional: "",
    orderType: "",
    includeInactive: false,
    subaccountTotalOrders: false,
  };
}

export const StreamOrdersRequest = {
  encode(message: StreamOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderSide !== "") {
      writer.uint32(18).string(message.orderSide);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(32).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(40).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(48).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(56).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(66).string(v!);
    }
    if (message.isConditional !== "") {
      writer.uint32(74).string(message.isConditional);
    }
    if (message.orderType !== "") {
      writer.uint32(82).string(message.orderType);
    }
    if (message.includeInactive === true) {
      writer.uint32(88).bool(message.includeInactive);
    }
    if (message.subaccountTotalOrders === true) {
      writer.uint32(96).bool(message.subaccountTotalOrders);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderSide = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.limit = reader.sint32();
          break;
        case 6:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 7:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.marketIds.push(reader.string());
          break;
        case 9:
          message.isConditional = reader.string();
          break;
        case 10:
          message.orderType = reader.string();
          break;
        case 11:
          message.includeInactive = reader.bool();
          break;
        case 12:
          message.subaccountTotalOrders = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderSide: isSet(object.orderSide) ? String(object.orderSide) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      isConditional: isSet(object.isConditional) ? String(object.isConditional) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      includeInactive: isSet(object.includeInactive) ? Boolean(object.includeInactive) : false,
      subaccountTotalOrders: isSet(object.subaccountTotalOrders) ? Boolean(object.subaccountTotalOrders) : false,
    };
  },

  toJSON(message: StreamOrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderSide !== undefined && (obj.orderSide = message.orderSide);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    message.isConditional !== undefined && (obj.isConditional = message.isConditional);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.includeInactive !== undefined && (obj.includeInactive = message.includeInactive);
    message.subaccountTotalOrders !== undefined && (obj.subaccountTotalOrders = message.subaccountTotalOrders);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersRequest>): StreamOrdersRequest {
    return StreamOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersRequest>): StreamOrdersRequest {
    const message = createBaseStreamOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.orderSide = object.orderSide ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.isConditional = object.isConditional ?? "";
    message.orderType = object.orderType ?? "";
    message.includeInactive = object.includeInactive ?? false;
    message.subaccountTotalOrders = object.subaccountTotalOrders ?? false;
    return message;
  },
};

function createBaseStreamOrdersResponse(): StreamOrdersResponse {
  return { order: undefined, operationType: "", timestamp: "0" };
}

export const StreamOrdersResponse = {
  encode(message: StreamOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      DerivativeLimitOrder.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order = DerivativeLimitOrder.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersResponse {
    return {
      order: isSet(object.order) ? DerivativeLimitOrder.fromJSON(object.order) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamOrdersResponse): unknown {
    const obj: any = {};
    message.order !== undefined && (obj.order = message.order ? DerivativeLimitOrder.toJSON(message.order) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersResponse>): StreamOrdersResponse {
    return StreamOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersResponse>): StreamOrdersResponse {
    const message = createBaseStreamOrdersResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeLimitOrder.fromPartial(object.order)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseTradesRequest(): TradesRequest {
  return {
    marketId: "",
    executionSide: "",
    direction: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    subaccountIds: [],
    executionTypes: [],
  };
}

export const TradesRequest = {
  encode(message: TradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.executionSide !== "") {
      writer.uint32(18).string(message.executionSide);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.subaccountIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.executionTypes) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.executionSide = reader.string();
          break;
        case 3:
          message.direction = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.marketIds.push(reader.string());
          break;
        case 10:
          message.subaccountIds.push(reader.string());
          break;
        case 11:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      subaccountIds: Array.isArray(object?.subaccountIds) ? object.subaccountIds.map((e: any) => String(e)) : [],
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: TradesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    message.direction !== undefined && (obj.direction = message.direction);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => e);
    } else {
      obj.subaccountIds = [];
    }
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradesRequest>): TradesRequest {
    return TradesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradesRequest>): TradesRequest {
    const message = createBaseTradesRequest();
    message.marketId = object.marketId ?? "";
    message.executionSide = object.executionSide ?? "";
    message.direction = object.direction ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseTradesResponse(): TradesResponse {
  return { trades: [], paging: undefined };
}

export const TradesResponse = {
  encode(message: TradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trades) {
      DerivativeTrade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trades.push(DerivativeTrade.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradesResponse {
    return {
      trades: Array.isArray(object?.trades) ? object.trades.map((e: any) => DerivativeTrade.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: TradesResponse): unknown {
    const obj: any = {};
    if (message.trades) {
      obj.trades = message.trades.map((e) => e ? DerivativeTrade.toJSON(e) : undefined);
    } else {
      obj.trades = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<TradesResponse>): TradesResponse {
    return TradesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradesResponse>): TradesResponse {
    const message = createBaseTradesResponse();
    message.trades = object.trades?.map((e) => DerivativeTrade.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseDerivativeTrade(): DerivativeTrade {
  return {
    orderHash: "",
    subaccountId: "",
    marketId: "",
    tradeExecutionType: "",
    isLiquidation: false,
    positionDelta: undefined,
    payout: "",
    fee: "",
    executedAt: "0",
    feeRecipient: "",
    tradeId: "",
    executionSide: "",
  };
}

export const DerivativeTrade = {
  encode(message: DerivativeTrade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.tradeExecutionType !== "") {
      writer.uint32(34).string(message.tradeExecutionType);
    }
    if (message.isLiquidation === true) {
      writer.uint32(40).bool(message.isLiquidation);
    }
    if (message.positionDelta !== undefined) {
      PositionDelta.encode(message.positionDelta, writer.uint32(50).fork()).ldelim();
    }
    if (message.payout !== "") {
      writer.uint32(58).string(message.payout);
    }
    if (message.fee !== "") {
      writer.uint32(66).string(message.fee);
    }
    if (message.executedAt !== "0") {
      writer.uint32(72).sint64(message.executedAt);
    }
    if (message.feeRecipient !== "") {
      writer.uint32(82).string(message.feeRecipient);
    }
    if (message.tradeId !== "") {
      writer.uint32(90).string(message.tradeId);
    }
    if (message.executionSide !== "") {
      writer.uint32(98).string(message.executionSide);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeTrade {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.tradeExecutionType = reader.string();
          break;
        case 5:
          message.isLiquidation = reader.bool();
          break;
        case 6:
          message.positionDelta = PositionDelta.decode(reader, reader.uint32());
          break;
        case 7:
          message.payout = reader.string();
          break;
        case 8:
          message.fee = reader.string();
          break;
        case 9:
          message.executedAt = longToString(reader.sint64() as Long);
          break;
        case 10:
          message.feeRecipient = reader.string();
          break;
        case 11:
          message.tradeId = reader.string();
          break;
        case 12:
          message.executionSide = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeTrade {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      tradeExecutionType: isSet(object.tradeExecutionType) ? String(object.tradeExecutionType) : "",
      isLiquidation: isSet(object.isLiquidation) ? Boolean(object.isLiquidation) : false,
      positionDelta: isSet(object.positionDelta) ? PositionDelta.fromJSON(object.positionDelta) : undefined,
      payout: isSet(object.payout) ? String(object.payout) : "",
      fee: isSet(object.fee) ? String(object.fee) : "",
      executedAt: isSet(object.executedAt) ? String(object.executedAt) : "0",
      feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
      tradeId: isSet(object.tradeId) ? String(object.tradeId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
    };
  },

  toJSON(message: DerivativeTrade): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.tradeExecutionType !== undefined && (obj.tradeExecutionType = message.tradeExecutionType);
    message.isLiquidation !== undefined && (obj.isLiquidation = message.isLiquidation);
    message.positionDelta !== undefined &&
      (obj.positionDelta = message.positionDelta ? PositionDelta.toJSON(message.positionDelta) : undefined);
    message.payout !== undefined && (obj.payout = message.payout);
    message.fee !== undefined && (obj.fee = message.fee);
    message.executedAt !== undefined && (obj.executedAt = message.executedAt);
    message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
    message.tradeId !== undefined && (obj.tradeId = message.tradeId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    return obj;
  },

  create(base?: DeepPartial<DerivativeTrade>): DerivativeTrade {
    return DerivativeTrade.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeTrade>): DerivativeTrade {
    const message = createBaseDerivativeTrade();
    message.orderHash = object.orderHash ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.tradeExecutionType = object.tradeExecutionType ?? "";
    message.isLiquidation = object.isLiquidation ?? false;
    message.positionDelta = (object.positionDelta !== undefined && object.positionDelta !== null)
      ? PositionDelta.fromPartial(object.positionDelta)
      : undefined;
    message.payout = object.payout ?? "";
    message.fee = object.fee ?? "";
    message.executedAt = object.executedAt ?? "0";
    message.feeRecipient = object.feeRecipient ?? "";
    message.tradeId = object.tradeId ?? "";
    message.executionSide = object.executionSide ?? "";
    return message;
  },
};

function createBasePositionDelta(): PositionDelta {
  return { tradeDirection: "", executionPrice: "", executionQuantity: "", executionMargin: "" };
}

export const PositionDelta = {
  encode(message: PositionDelta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tradeDirection !== "") {
      writer.uint32(10).string(message.tradeDirection);
    }
    if (message.executionPrice !== "") {
      writer.uint32(18).string(message.executionPrice);
    }
    if (message.executionQuantity !== "") {
      writer.uint32(26).string(message.executionQuantity);
    }
    if (message.executionMargin !== "") {
      writer.uint32(34).string(message.executionMargin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PositionDelta {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tradeDirection = reader.string();
          break;
        case 2:
          message.executionPrice = reader.string();
          break;
        case 3:
          message.executionQuantity = reader.string();
          break;
        case 4:
          message.executionMargin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PositionDelta {
    return {
      tradeDirection: isSet(object.tradeDirection) ? String(object.tradeDirection) : "",
      executionPrice: isSet(object.executionPrice) ? String(object.executionPrice) : "",
      executionQuantity: isSet(object.executionQuantity) ? String(object.executionQuantity) : "",
      executionMargin: isSet(object.executionMargin) ? String(object.executionMargin) : "",
    };
  },

  toJSON(message: PositionDelta): unknown {
    const obj: any = {};
    message.tradeDirection !== undefined && (obj.tradeDirection = message.tradeDirection);
    message.executionPrice !== undefined && (obj.executionPrice = message.executionPrice);
    message.executionQuantity !== undefined && (obj.executionQuantity = message.executionQuantity);
    message.executionMargin !== undefined && (obj.executionMargin = message.executionMargin);
    return obj;
  },

  create(base?: DeepPartial<PositionDelta>): PositionDelta {
    return PositionDelta.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PositionDelta>): PositionDelta {
    const message = createBasePositionDelta();
    message.tradeDirection = object.tradeDirection ?? "";
    message.executionPrice = object.executionPrice ?? "";
    message.executionQuantity = object.executionQuantity ?? "";
    message.executionMargin = object.executionMargin ?? "";
    return message;
  },
};

function createBaseStreamTradesRequest(): StreamTradesRequest {
  return {
    marketId: "",
    executionSide: "",
    direction: "",
    subaccountId: "",
    skip: "0",
    limit: 0,
    startTime: "0",
    endTime: "0",
    marketIds: [],
    subaccountIds: [],
    executionTypes: [],
  };
}

export const StreamTradesRequest = {
  encode(message: StreamTradesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.executionSide !== "") {
      writer.uint32(18).string(message.executionSide);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    for (const v of message.marketIds) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.subaccountIds) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.executionTypes) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTradesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.executionSide = reader.string();
          break;
        case 3:
          message.direction = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.marketIds.push(reader.string());
          break;
        case 10:
          message.subaccountIds.push(reader.string());
          break;
        case 11:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamTradesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionSide: isSet(object.executionSide) ? String(object.executionSide) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
      subaccountIds: Array.isArray(object?.subaccountIds) ? object.subaccountIds.map((e: any) => String(e)) : [],
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamTradesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionSide !== undefined && (obj.executionSide = message.executionSide);
    message.direction !== undefined && (obj.direction = message.direction);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => e);
    } else {
      obj.subaccountIds = [];
    }
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamTradesRequest>): StreamTradesRequest {
    return StreamTradesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamTradesRequest>): StreamTradesRequest {
    const message = createBaseStreamTradesRequest();
    message.marketId = object.marketId ?? "";
    message.executionSide = object.executionSide ?? "";
    message.direction = object.direction ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.marketIds = object.marketIds?.map((e) => e) || [];
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamTradesResponse(): StreamTradesResponse {
  return { trade: undefined, operationType: "", timestamp: "0" };
}

export const StreamTradesResponse = {
  encode(message: StreamTradesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trade !== undefined) {
      DerivativeTrade.encode(message.trade, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTradesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trade = DerivativeTrade.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamTradesResponse {
    return {
      trade: isSet(object.trade) ? DerivativeTrade.fromJSON(object.trade) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamTradesResponse): unknown {
    const obj: any = {};
    message.trade !== undefined && (obj.trade = message.trade ? DerivativeTrade.toJSON(message.trade) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamTradesResponse>): StreamTradesResponse {
    return StreamTradesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamTradesResponse>): StreamTradesResponse {
    const message = createBaseStreamTradesResponse();
    message.trade = (object.trade !== undefined && object.trade !== null)
      ? DerivativeTrade.fromPartial(object.trade)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseSubaccountOrdersListRequest(): SubaccountOrdersListRequest {
  return { subaccountId: "", marketId: "", skip: "0", limit: 0 };
}

export const SubaccountOrdersListRequest = {
  encode(message: SubaccountOrdersListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrdersListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrdersListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrdersListRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: SubaccountOrdersListRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
    return SubaccountOrdersListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrdersListRequest>): SubaccountOrdersListRequest {
    const message = createBaseSubaccountOrdersListRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSubaccountOrdersListResponse(): SubaccountOrdersListResponse {
  return { orders: [], paging: undefined };
}

export const SubaccountOrdersListResponse = {
  encode(message: SubaccountOrdersListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      DerivativeLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrdersListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrdersListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(DerivativeLimitOrder.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrdersListResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => DerivativeLimitOrder.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: SubaccountOrdersListResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? DerivativeLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
    return SubaccountOrdersListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrdersListResponse>): SubaccountOrdersListResponse {
    const message = createBaseSubaccountOrdersListResponse();
    message.orders = object.orders?.map((e) => DerivativeLimitOrder.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseSubaccountTradesListRequest(): SubaccountTradesListRequest {
  return { subaccountId: "", marketId: "", executionType: "", direction: "", skip: "0", limit: 0 };
}

export const SubaccountTradesListRequest = {
  encode(message: SubaccountTradesListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.executionType !== "") {
      writer.uint32(26).string(message.executionType);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.skip !== "0") {
      writer.uint32(40).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(48).sint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradesListRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountTradesListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.executionType = reader.string();
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.limit = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountTradesListRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      executionType: isSet(object.executionType) ? String(object.executionType) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
    };
  },

  toJSON(message: SubaccountTradesListRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.executionType !== undefined && (obj.executionType = message.executionType);
    message.direction !== undefined && (obj.direction = message.direction);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    return obj;
  },

  create(base?: DeepPartial<SubaccountTradesListRequest>): SubaccountTradesListRequest {
    return SubaccountTradesListRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountTradesListRequest>): SubaccountTradesListRequest {
    const message = createBaseSubaccountTradesListRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.executionType = object.executionType ?? "";
    message.direction = object.direction ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSubaccountTradesListResponse(): SubaccountTradesListResponse {
  return { trades: [] };
}

export const SubaccountTradesListResponse = {
  encode(message: SubaccountTradesListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.trades) {
      DerivativeTrade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradesListResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountTradesListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trades.push(DerivativeTrade.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountTradesListResponse {
    return { trades: Array.isArray(object?.trades) ? object.trades.map((e: any) => DerivativeTrade.fromJSON(e)) : [] };
  },

  toJSON(message: SubaccountTradesListResponse): unknown {
    const obj: any = {};
    if (message.trades) {
      obj.trades = message.trades.map((e) => e ? DerivativeTrade.toJSON(e) : undefined);
    } else {
      obj.trades = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountTradesListResponse>): SubaccountTradesListResponse {
    return SubaccountTradesListResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountTradesListResponse>): SubaccountTradesListResponse {
    const message = createBaseSubaccountTradesListResponse();
    message.trades = object.trades?.map((e) => DerivativeTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrdersHistoryRequest(): OrdersHistoryRequest {
  return {
    subaccountId: "",
    marketId: "",
    skip: "0",
    limit: 0,
    orderTypes: [],
    direction: "",
    startTime: "0",
    endTime: "0",
    isConditional: "",
    orderType: "",
    state: "",
    executionTypes: [],
    marketIds: [],
  };
}

export const OrdersHistoryRequest = {
  encode(message: OrdersHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.skip !== "0") {
      writer.uint32(24).uint64(message.skip);
    }
    if (message.limit !== 0) {
      writer.uint32(32).sint32(message.limit);
    }
    for (const v of message.orderTypes) {
      writer.uint32(42).string(v!);
    }
    if (message.direction !== "") {
      writer.uint32(50).string(message.direction);
    }
    if (message.startTime !== "0") {
      writer.uint32(56).sint64(message.startTime);
    }
    if (message.endTime !== "0") {
      writer.uint32(64).sint64(message.endTime);
    }
    if (message.isConditional !== "") {
      writer.uint32(74).string(message.isConditional);
    }
    if (message.orderType !== "") {
      writer.uint32(82).string(message.orderType);
    }
    if (message.state !== "") {
      writer.uint32(90).string(message.state);
    }
    for (const v of message.executionTypes) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.marketIds) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.skip = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.limit = reader.sint32();
          break;
        case 5:
          message.orderTypes.push(reader.string());
          break;
        case 6:
          message.direction = reader.string();
          break;
        case 7:
          message.startTime = longToString(reader.sint64() as Long);
          break;
        case 8:
          message.endTime = longToString(reader.sint64() as Long);
          break;
        case 9:
          message.isConditional = reader.string();
          break;
        case 10:
          message.orderType = reader.string();
          break;
        case 11:
          message.state = reader.string();
          break;
        case 12:
          message.executionTypes.push(reader.string());
          break;
        case 13:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersHistoryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      skip: isSet(object.skip) ? String(object.skip) : "0",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      orderTypes: Array.isArray(object?.orderTypes) ? object.orderTypes.map((e: any) => String(e)) : [],
      direction: isSet(object.direction) ? String(object.direction) : "",
      startTime: isSet(object.startTime) ? String(object.startTime) : "0",
      endTime: isSet(object.endTime) ? String(object.endTime) : "0",
      isConditional: isSet(object.isConditional) ? String(object.isConditional) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      state: isSet(object.state) ? String(object.state) : "",
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: OrdersHistoryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.skip !== undefined && (obj.skip = message.skip);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    if (message.orderTypes) {
      obj.orderTypes = message.orderTypes.map((e) => e);
    } else {
      obj.orderTypes = [];
    }
    message.direction !== undefined && (obj.direction = message.direction);
    message.startTime !== undefined && (obj.startTime = message.startTime);
    message.endTime !== undefined && (obj.endTime = message.endTime);
    message.isConditional !== undefined && (obj.isConditional = message.isConditional);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.state !== undefined && (obj.state = message.state);
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<OrdersHistoryRequest>): OrdersHistoryRequest {
    return OrdersHistoryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersHistoryRequest>): OrdersHistoryRequest {
    const message = createBaseOrdersHistoryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.skip = object.skip ?? "0";
    message.limit = object.limit ?? 0;
    message.orderTypes = object.orderTypes?.map((e) => e) || [];
    message.direction = object.direction ?? "";
    message.startTime = object.startTime ?? "0";
    message.endTime = object.endTime ?? "0";
    message.isConditional = object.isConditional ?? "";
    message.orderType = object.orderType ?? "";
    message.state = object.state ?? "";
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrdersHistoryResponse(): OrdersHistoryResponse {
  return { orders: [], paging: undefined };
}

export const OrdersHistoryResponse = {
  encode(message: OrdersHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      DerivativeOrderHistory.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.paging !== undefined) {
      Paging.encode(message.paging, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrdersHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(DerivativeOrderHistory.decode(reader, reader.uint32()));
          break;
        case 2:
          message.paging = Paging.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrdersHistoryResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => DerivativeOrderHistory.fromJSON(e)) : [],
      paging: isSet(object.paging) ? Paging.fromJSON(object.paging) : undefined,
    };
  },

  toJSON(message: OrdersHistoryResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? DerivativeOrderHistory.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    message.paging !== undefined && (obj.paging = message.paging ? Paging.toJSON(message.paging) : undefined);
    return obj;
  },

  create(base?: DeepPartial<OrdersHistoryResponse>): OrdersHistoryResponse {
    return OrdersHistoryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrdersHistoryResponse>): OrdersHistoryResponse {
    const message = createBaseOrdersHistoryResponse();
    message.orders = object.orders?.map((e) => DerivativeOrderHistory.fromPartial(e)) || [];
    message.paging = (object.paging !== undefined && object.paging !== null)
      ? Paging.fromPartial(object.paging)
      : undefined;
    return message;
  },
};

function createBaseDerivativeOrderHistory(): DerivativeOrderHistory {
  return {
    orderHash: "",
    marketId: "",
    isActive: false,
    subaccountId: "",
    executionType: "",
    orderType: "",
    price: "",
    triggerPrice: "",
    quantity: "",
    filledQuantity: "",
    state: "",
    createdAt: "0",
    updatedAt: "0",
    isReduceOnly: false,
    direction: "",
    isConditional: false,
    triggerAt: "0",
    placedOrderHash: "",
    margin: "",
  };
}

export const DerivativeOrderHistory = {
  encode(message: DerivativeOrderHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.isActive === true) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    if (message.executionType !== "") {
      writer.uint32(42).string(message.executionType);
    }
    if (message.orderType !== "") {
      writer.uint32(50).string(message.orderType);
    }
    if (message.price !== "") {
      writer.uint32(58).string(message.price);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(66).string(message.triggerPrice);
    }
    if (message.quantity !== "") {
      writer.uint32(74).string(message.quantity);
    }
    if (message.filledQuantity !== "") {
      writer.uint32(82).string(message.filledQuantity);
    }
    if (message.state !== "") {
      writer.uint32(90).string(message.state);
    }
    if (message.createdAt !== "0") {
      writer.uint32(96).sint64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(104).sint64(message.updatedAt);
    }
    if (message.isReduceOnly === true) {
      writer.uint32(112).bool(message.isReduceOnly);
    }
    if (message.direction !== "") {
      writer.uint32(122).string(message.direction);
    }
    if (message.isConditional === true) {
      writer.uint32(128).bool(message.isConditional);
    }
    if (message.triggerAt !== "0") {
      writer.uint32(136).uint64(message.triggerAt);
    }
    if (message.placedOrderHash !== "") {
      writer.uint32(146).string(message.placedOrderHash);
    }
    if (message.margin !== "") {
      writer.uint32(154).string(message.margin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeOrderHistory {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeOrderHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.isActive = reader.bool();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        case 5:
          message.executionType = reader.string();
          break;
        case 6:
          message.orderType = reader.string();
          break;
        case 7:
          message.price = reader.string();
          break;
        case 8:
          message.triggerPrice = reader.string();
          break;
        case 9:
          message.quantity = reader.string();
          break;
        case 10:
          message.filledQuantity = reader.string();
          break;
        case 11:
          message.state = reader.string();
          break;
        case 12:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        case 13:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        case 14:
          message.isReduceOnly = reader.bool();
          break;
        case 15:
          message.direction = reader.string();
          break;
        case 16:
          message.isConditional = reader.bool();
          break;
        case 17:
          message.triggerAt = longToString(reader.uint64() as Long);
          break;
        case 18:
          message.placedOrderHash = reader.string();
          break;
        case 19:
          message.margin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeOrderHistory {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      isActive: isSet(object.isActive) ? Boolean(object.isActive) : false,
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      executionType: isSet(object.executionType) ? String(object.executionType) : "",
      orderType: isSet(object.orderType) ? String(object.orderType) : "",
      price: isSet(object.price) ? String(object.price) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      filledQuantity: isSet(object.filledQuantity) ? String(object.filledQuantity) : "",
      state: isSet(object.state) ? String(object.state) : "",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
      isReduceOnly: isSet(object.isReduceOnly) ? Boolean(object.isReduceOnly) : false,
      direction: isSet(object.direction) ? String(object.direction) : "",
      isConditional: isSet(object.isConditional) ? Boolean(object.isConditional) : false,
      triggerAt: isSet(object.triggerAt) ? String(object.triggerAt) : "0",
      placedOrderHash: isSet(object.placedOrderHash) ? String(object.placedOrderHash) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
    };
  },

  toJSON(message: DerivativeOrderHistory): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.isActive !== undefined && (obj.isActive = message.isActive);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.executionType !== undefined && (obj.executionType = message.executionType);
    message.orderType !== undefined && (obj.orderType = message.orderType);
    message.price !== undefined && (obj.price = message.price);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.filledQuantity !== undefined && (obj.filledQuantity = message.filledQuantity);
    message.state !== undefined && (obj.state = message.state);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    message.isReduceOnly !== undefined && (obj.isReduceOnly = message.isReduceOnly);
    message.direction !== undefined && (obj.direction = message.direction);
    message.isConditional !== undefined && (obj.isConditional = message.isConditional);
    message.triggerAt !== undefined && (obj.triggerAt = message.triggerAt);
    message.placedOrderHash !== undefined && (obj.placedOrderHash = message.placedOrderHash);
    message.margin !== undefined && (obj.margin = message.margin);
    return obj;
  },

  create(base?: DeepPartial<DerivativeOrderHistory>): DerivativeOrderHistory {
    return DerivativeOrderHistory.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeOrderHistory>): DerivativeOrderHistory {
    const message = createBaseDerivativeOrderHistory();
    message.orderHash = object.orderHash ?? "";
    message.marketId = object.marketId ?? "";
    message.isActive = object.isActive ?? false;
    message.subaccountId = object.subaccountId ?? "";
    message.executionType = object.executionType ?? "";
    message.orderType = object.orderType ?? "";
    message.price = object.price ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.quantity = object.quantity ?? "";
    message.filledQuantity = object.filledQuantity ?? "";
    message.state = object.state ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.isReduceOnly = object.isReduceOnly ?? false;
    message.direction = object.direction ?? "";
    message.isConditional = object.isConditional ?? false;
    message.triggerAt = object.triggerAt ?? "0";
    message.placedOrderHash = object.placedOrderHash ?? "";
    message.margin = object.margin ?? "";
    return message;
  },
};

function createBaseStreamOrdersHistoryRequest(): StreamOrdersHistoryRequest {
  return { subaccountId: "", marketId: "", orderTypes: [], direction: "", state: "", executionTypes: [] };
}

export const StreamOrdersHistoryRequest = {
  encode(message: StreamOrdersHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    for (const v of message.orderTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    for (const v of message.executionTypes) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.orderTypes.push(reader.string());
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.state = reader.string();
          break;
        case 6:
          message.executionTypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersHistoryRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderTypes: Array.isArray(object?.orderTypes) ? object.orderTypes.map((e: any) => String(e)) : [],
      direction: isSet(object.direction) ? String(object.direction) : "",
      state: isSet(object.state) ? String(object.state) : "",
      executionTypes: Array.isArray(object?.executionTypes) ? object.executionTypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: StreamOrdersHistoryRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    if (message.orderTypes) {
      obj.orderTypes = message.orderTypes.map((e) => e);
    } else {
      obj.orderTypes = [];
    }
    message.direction !== undefined && (obj.direction = message.direction);
    message.state !== undefined && (obj.state = message.state);
    if (message.executionTypes) {
      obj.executionTypes = message.executionTypes.map((e) => e);
    } else {
      obj.executionTypes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
    return StreamOrdersHistoryRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersHistoryRequest>): StreamOrdersHistoryRequest {
    const message = createBaseStreamOrdersHistoryRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.orderTypes = object.orderTypes?.map((e) => e) || [];
    message.direction = object.direction ?? "";
    message.state = object.state ?? "";
    message.executionTypes = object.executionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamOrdersHistoryResponse(): StreamOrdersHistoryResponse {
  return { order: undefined, operationType: "", timestamp: "0" };
}

export const StreamOrdersHistoryResponse = {
  encode(message: StreamOrdersHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      DerivativeOrderHistory.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.operationType !== "") {
      writer.uint32(18).string(message.operationType);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOrdersHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOrdersHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order = DerivativeOrderHistory.decode(reader, reader.uint32());
          break;
        case 2:
          message.operationType = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamOrdersHistoryResponse {
    return {
      order: isSet(object.order) ? DerivativeOrderHistory.fromJSON(object.order) : undefined,
      operationType: isSet(object.operationType) ? String(object.operationType) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamOrdersHistoryResponse): unknown {
    const obj: any = {};
    message.order !== undefined &&
      (obj.order = message.order ? DerivativeOrderHistory.toJSON(message.order) : undefined);
    message.operationType !== undefined && (obj.operationType = message.operationType);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
    return StreamOrdersHistoryResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamOrdersHistoryResponse>): StreamOrdersHistoryResponse {
    const message = createBaseStreamOrdersHistoryResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrderHistory.fromPartial(object.order)
      : undefined;
    message.operationType = object.operationType ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

/**
 * InjectiveDerivativeExchangeRPC defines gRPC API of Derivative Markets
 * provider.
 */
export interface InjectiveDerivativeExchangeRPC {
  /** Markets gets a list of Derivative Markets */
  Markets(request: DeepPartial<MarketsRequest>, metadata?: grpc.Metadata): Promise<MarketsResponse>;
  /** Market gets details of a single derivative market */
  Market(request: DeepPartial<MarketRequest>, metadata?: grpc.Metadata): Promise<MarketResponse>;
  /** StreamMarket streams live updates of selected derivative markets */
  StreamMarket(request: DeepPartial<StreamMarketRequest>, metadata?: grpc.Metadata): Observable<StreamMarketResponse>;
  /** BinaryOptionsMarkets gets a list of Binary Options Markets */
  BinaryOptionsMarkets(
    request: DeepPartial<BinaryOptionsMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BinaryOptionsMarketsResponse>;
  /** BinaryOptionMarket gets details of a single binary options market */
  BinaryOptionsMarket(
    request: DeepPartial<BinaryOptionsMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BinaryOptionsMarketResponse>;
  /** Orderbook gets the Orderbook of a Derivative Market */
  Orderbook(request: DeepPartial<OrderbookRequest>, metadata?: grpc.Metadata): Promise<OrderbookResponse>;
  /** Orderbook gets the Orderbook of a Derivative Market */
  OrderbookV2(request: DeepPartial<OrderbookV2Request>, metadata?: grpc.Metadata): Promise<OrderbookV2Response>;
  /** Orderbooks gets the Orderbooks of requested derivative markets */
  Orderbooks(request: DeepPartial<OrderbooksRequest>, metadata?: grpc.Metadata): Promise<OrderbooksResponse>;
  /** Orderbooks gets the Orderbooks of requested derivative markets */
  OrderbooksV2(request: DeepPartial<OrderbooksV2Request>, metadata?: grpc.Metadata): Promise<OrderbooksV2Response>;
  /** Stream live snapshot updates of selected derivative market orderbook */
  StreamOrderbook(
    request: DeepPartial<StreamOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookResponse>;
  /** Stream live snapshot updates of selected derivative market orderbook */
  StreamOrderbookV2(
    request: DeepPartial<StreamOrderbookV2Request>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookV2Response>;
  /** Stream live level updates of selected derivative market orderbook */
  StreamOrderbookUpdate(
    request: DeepPartial<StreamOrderbookUpdateRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookUpdateResponse>;
  /** DerivativeLimitOrders gets the limit orders of a derivative Market. */
  Orders(request: DeepPartial<OrdersRequest>, metadata?: grpc.Metadata): Promise<OrdersResponse>;
  /** Positions gets the positions for a trader. */
  Positions(request: DeepPartial<PositionsRequest>, metadata?: grpc.Metadata): Promise<PositionsResponse>;
  /** LiquidablePositions gets all the liquidable positions. */
  LiquidablePositions(
    request: DeepPartial<LiquidablePositionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LiquidablePositionsResponse>;
  /** FundingPayments gets the funding payments for a trader. */
  FundingPayments(
    request: DeepPartial<FundingPaymentsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<FundingPaymentsResponse>;
  /** FundingRates gets the historical funding rates for a market. */
  FundingRates(request: DeepPartial<FundingRatesRequest>, metadata?: grpc.Metadata): Promise<FundingRatesResponse>;
  /** StreamPositions streams derivatives position updates. */
  StreamPositions(
    request: DeepPartial<StreamPositionsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamPositionsResponse>;
  /** StreamOrders streams updates to individual orders of a Derivative Market. */
  StreamOrders(request: DeepPartial<StreamOrdersRequest>, metadata?: grpc.Metadata): Observable<StreamOrdersResponse>;
  /** Trades gets the trades of a Derivative Market. */
  Trades(request: DeepPartial<TradesRequest>, metadata?: grpc.Metadata): Promise<TradesResponse>;
  /** StreamTrades streams newly executed trades from Derivative Market. */
  StreamTrades(request: DeepPartial<StreamTradesRequest>, metadata?: grpc.Metadata): Observable<StreamTradesResponse>;
  /** SubaccountOrdersList lists orders posted from this subaccount. */
  SubaccountOrdersList(
    request: DeepPartial<SubaccountOrdersListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrdersListResponse>;
  /**
   * SubaccountTradesList gets a list of derivatives trades executed by this
   * subaccount.
   */
  SubaccountTradesList(
    request: DeepPartial<SubaccountTradesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountTradesListResponse>;
  /** Lists history orders posted from a subaccount */
  OrdersHistory(request: DeepPartial<OrdersHistoryRequest>, metadata?: grpc.Metadata): Promise<OrdersHistoryResponse>;
  /** Stream updates to historical orders of a derivative Market */
  StreamOrdersHistory(
    request: DeepPartial<StreamOrdersHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrdersHistoryResponse>;
}

export class InjectiveDerivativeExchangeRPCClientImpl implements InjectiveDerivativeExchangeRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Markets = this.Markets.bind(this);
    this.Market = this.Market.bind(this);
    this.StreamMarket = this.StreamMarket.bind(this);
    this.BinaryOptionsMarkets = this.BinaryOptionsMarkets.bind(this);
    this.BinaryOptionsMarket = this.BinaryOptionsMarket.bind(this);
    this.Orderbook = this.Orderbook.bind(this);
    this.OrderbookV2 = this.OrderbookV2.bind(this);
    this.Orderbooks = this.Orderbooks.bind(this);
    this.OrderbooksV2 = this.OrderbooksV2.bind(this);
    this.StreamOrderbook = this.StreamOrderbook.bind(this);
    this.StreamOrderbookV2 = this.StreamOrderbookV2.bind(this);
    this.StreamOrderbookUpdate = this.StreamOrderbookUpdate.bind(this);
    this.Orders = this.Orders.bind(this);
    this.Positions = this.Positions.bind(this);
    this.LiquidablePositions = this.LiquidablePositions.bind(this);
    this.FundingPayments = this.FundingPayments.bind(this);
    this.FundingRates = this.FundingRates.bind(this);
    this.StreamPositions = this.StreamPositions.bind(this);
    this.StreamOrders = this.StreamOrders.bind(this);
    this.Trades = this.Trades.bind(this);
    this.StreamTrades = this.StreamTrades.bind(this);
    this.SubaccountOrdersList = this.SubaccountOrdersList.bind(this);
    this.SubaccountTradesList = this.SubaccountTradesList.bind(this);
    this.OrdersHistory = this.OrdersHistory.bind(this);
    this.StreamOrdersHistory = this.StreamOrdersHistory.bind(this);
  }

  Markets(request: DeepPartial<MarketsRequest>, metadata?: grpc.Metadata): Promise<MarketsResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCMarketsDesc, MarketsRequest.fromPartial(request), metadata);
  }

  Market(request: DeepPartial<MarketRequest>, metadata?: grpc.Metadata): Promise<MarketResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCMarketDesc, MarketRequest.fromPartial(request), metadata);
  }

  StreamMarket(request: DeepPartial<StreamMarketRequest>, metadata?: grpc.Metadata): Observable<StreamMarketResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamMarketDesc,
      StreamMarketRequest.fromPartial(request),
      metadata,
    );
  }

  BinaryOptionsMarkets(
    request: DeepPartial<BinaryOptionsMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BinaryOptionsMarketsResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCBinaryOptionsMarketsDesc,
      BinaryOptionsMarketsRequest.fromPartial(request),
      metadata,
    );
  }

  BinaryOptionsMarket(
    request: DeepPartial<BinaryOptionsMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BinaryOptionsMarketResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCBinaryOptionsMarketDesc,
      BinaryOptionsMarketRequest.fromPartial(request),
      metadata,
    );
  }

  Orderbook(request: DeepPartial<OrderbookRequest>, metadata?: grpc.Metadata): Promise<OrderbookResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCOrderbookDesc, OrderbookRequest.fromPartial(request), metadata);
  }

  OrderbookV2(request: DeepPartial<OrderbookV2Request>, metadata?: grpc.Metadata): Promise<OrderbookV2Response> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCOrderbookV2Desc,
      OrderbookV2Request.fromPartial(request),
      metadata,
    );
  }

  Orderbooks(request: DeepPartial<OrderbooksRequest>, metadata?: grpc.Metadata): Promise<OrderbooksResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCOrderbooksDesc,
      OrderbooksRequest.fromPartial(request),
      metadata,
    );
  }

  OrderbooksV2(request: DeepPartial<OrderbooksV2Request>, metadata?: grpc.Metadata): Promise<OrderbooksV2Response> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCOrderbooksV2Desc,
      OrderbooksV2Request.fromPartial(request),
      metadata,
    );
  }

  StreamOrderbook(
    request: DeepPartial<StreamOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamOrderbookDesc,
      StreamOrderbookRequest.fromPartial(request),
      metadata,
    );
  }

  StreamOrderbookV2(
    request: DeepPartial<StreamOrderbookV2Request>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookV2Response> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamOrderbookV2Desc,
      StreamOrderbookV2Request.fromPartial(request),
      metadata,
    );
  }

  StreamOrderbookUpdate(
    request: DeepPartial<StreamOrderbookUpdateRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrderbookUpdateResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamOrderbookUpdateDesc,
      StreamOrderbookUpdateRequest.fromPartial(request),
      metadata,
    );
  }

  Orders(request: DeepPartial<OrdersRequest>, metadata?: grpc.Metadata): Promise<OrdersResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCOrdersDesc, OrdersRequest.fromPartial(request), metadata);
  }

  Positions(request: DeepPartial<PositionsRequest>, metadata?: grpc.Metadata): Promise<PositionsResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCPositionsDesc, PositionsRequest.fromPartial(request), metadata);
  }

  LiquidablePositions(
    request: DeepPartial<LiquidablePositionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LiquidablePositionsResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCLiquidablePositionsDesc,
      LiquidablePositionsRequest.fromPartial(request),
      metadata,
    );
  }

  FundingPayments(
    request: DeepPartial<FundingPaymentsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<FundingPaymentsResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCFundingPaymentsDesc,
      FundingPaymentsRequest.fromPartial(request),
      metadata,
    );
  }

  FundingRates(request: DeepPartial<FundingRatesRequest>, metadata?: grpc.Metadata): Promise<FundingRatesResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCFundingRatesDesc,
      FundingRatesRequest.fromPartial(request),
      metadata,
    );
  }

  StreamPositions(
    request: DeepPartial<StreamPositionsRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamPositionsResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamPositionsDesc,
      StreamPositionsRequest.fromPartial(request),
      metadata,
    );
  }

  StreamOrders(request: DeepPartial<StreamOrdersRequest>, metadata?: grpc.Metadata): Observable<StreamOrdersResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamOrdersDesc,
      StreamOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  Trades(request: DeepPartial<TradesRequest>, metadata?: grpc.Metadata): Promise<TradesResponse> {
    return this.rpc.unary(InjectiveDerivativeExchangeRPCTradesDesc, TradesRequest.fromPartial(request), metadata);
  }

  StreamTrades(request: DeepPartial<StreamTradesRequest>, metadata?: grpc.Metadata): Observable<StreamTradesResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamTradesDesc,
      StreamTradesRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountOrdersList(
    request: DeepPartial<SubaccountOrdersListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountOrdersListResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCSubaccountOrdersListDesc,
      SubaccountOrdersListRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountTradesList(
    request: DeepPartial<SubaccountTradesListRequest>,
    metadata?: grpc.Metadata,
  ): Promise<SubaccountTradesListResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCSubaccountTradesListDesc,
      SubaccountTradesListRequest.fromPartial(request),
      metadata,
    );
  }

  OrdersHistory(request: DeepPartial<OrdersHistoryRequest>, metadata?: grpc.Metadata): Promise<OrdersHistoryResponse> {
    return this.rpc.unary(
      InjectiveDerivativeExchangeRPCOrdersHistoryDesc,
      OrdersHistoryRequest.fromPartial(request),
      metadata,
    );
  }

  StreamOrdersHistory(
    request: DeepPartial<StreamOrdersHistoryRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamOrdersHistoryResponse> {
    return this.rpc.invoke(
      InjectiveDerivativeExchangeRPCStreamOrdersHistoryDesc,
      StreamOrdersHistoryRequest.fromPartial(request),
      metadata,
    );
  }
}

export const InjectiveDerivativeExchangeRPCDesc = {
  serviceName: "injective_derivative_exchange_rpc.InjectiveDerivativeExchangeRPC",
};

export const InjectiveDerivativeExchangeRPCMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "Markets",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCMarketDesc: UnaryMethodDefinitionish = {
  methodName: "Market",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamMarketDesc: UnaryMethodDefinitionish = {
  methodName: "StreamMarket",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCBinaryOptionsMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "BinaryOptionsMarkets",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BinaryOptionsMarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BinaryOptionsMarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCBinaryOptionsMarketDesc: UnaryMethodDefinitionish = {
  methodName: "BinaryOptionsMarket",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BinaryOptionsMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BinaryOptionsMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "Orderbook",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrderbookV2Desc: UnaryMethodDefinitionish = {
  methodName: "OrderbookV2",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbookV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbookV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrderbooksDesc: UnaryMethodDefinitionish = {
  methodName: "Orderbooks",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbooksRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbooksResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrderbooksV2Desc: UnaryMethodDefinitionish = {
  methodName: "OrderbooksV2",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrderbooksV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrderbooksV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbook",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamOrderbookV2Desc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbookV2",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookV2Request.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookV2Response.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamOrderbookUpdateDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrderbookUpdate",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrderbookUpdateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrderbookUpdateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "Orders",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCPositionsDesc: UnaryMethodDefinitionish = {
  methodName: "Positions",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PositionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PositionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCLiquidablePositionsDesc: UnaryMethodDefinitionish = {
  methodName: "LiquidablePositions",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LiquidablePositionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LiquidablePositionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCFundingPaymentsDesc: UnaryMethodDefinitionish = {
  methodName: "FundingPayments",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return FundingPaymentsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = FundingPaymentsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCFundingRatesDesc: UnaryMethodDefinitionish = {
  methodName: "FundingRates",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return FundingRatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = FundingRatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamPositionsDesc: UnaryMethodDefinitionish = {
  methodName: "StreamPositions",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamPositionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamPositionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrders",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCTradesDesc: UnaryMethodDefinitionish = {
  methodName: "Trades",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamTradesDesc: UnaryMethodDefinitionish = {
  methodName: "StreamTrades",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamTradesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamTradesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCSubaccountOrdersListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountOrdersList",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountOrdersListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountOrdersListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCSubaccountTradesListDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountTradesList",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubaccountTradesListRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SubaccountTradesListResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCOrdersHistoryDesc: UnaryMethodDefinitionish = {
  methodName: "OrdersHistory",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return OrdersHistoryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OrdersHistoryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveDerivativeExchangeRPCStreamOrdersHistoryDesc: UnaryMethodDefinitionish = {
  methodName: "StreamOrdersHistory",
  service: InjectiveDerivativeExchangeRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamOrdersHistoryRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamOrdersHistoryResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes || [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Observable((observer) => {
      const upStream = (() => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          transport: this.options.streamingTransport || this.options.transport,
          metadata: maybeCombinedMetadata,
          debug: this.options.debug,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      });
      upStream();
    }).pipe(share());
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
