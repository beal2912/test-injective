/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "injective_meta_rpc";

export interface PingRequest {
}

export interface PingResponse {
}

export interface VersionRequest {
}

export interface VersionResponse {
  /** injective-exchange code version. */
  version: string;
  /** Additional build meta info. */
  build: { [key: string]: string };
}

export interface VersionResponse_BuildEntry {
  key: string;
  value: string;
}

export interface InfoRequest {
  /** Provide current system UNIX timestamp in millis */
  timestamp: string;
}

export interface InfoResponse {
  /** The original timestamp value in millis. */
  timestamp: string;
  /** UNIX time on the server in millis. */
  serverTime: string;
  /** injective-exchange code version. */
  version: string;
  /** Additional build meta info. */
  build: { [key: string]: string };
  /** Server's location region */
  region: string;
}

export interface InfoResponse_BuildEntry {
  key: string;
  value: string;
}

export interface StreamKeepaliveRequest {
}

export interface StreamKeepaliveResponse {
  /** Server event */
  event: string;
  /** New conection endpoint for the gRPC API */
  newEndpoint: string;
  /** Operation timestamp in UNIX millis. */
  timestamp: string;
}

function createBasePingRequest(): PingRequest {
  return {};
}

export const PingRequest = {
  encode(_: PingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): PingRequest {
    return {};
  },

  toJSON(_: PingRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingRequest>): PingRequest {
    return PingRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<PingRequest>): PingRequest {
    const message = createBasePingRequest();
    return message;
  },
};

function createBasePingResponse(): PingResponse {
  return {};
}

export const PingResponse = {
  encode(_: PingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): PingResponse {
    return {};
  },

  toJSON(_: PingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingResponse>): PingResponse {
    return PingResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<PingResponse>): PingResponse {
    const message = createBasePingResponse();
    return message;
  },
};

function createBaseVersionRequest(): VersionRequest {
  return {};
}

export const VersionRequest = {
  encode(_: VersionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VersionRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): VersionRequest {
    return {};
  },

  toJSON(_: VersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<VersionRequest>): VersionRequest {
    return VersionRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<VersionRequest>): VersionRequest {
    const message = createBaseVersionRequest();
    return message;
  },
};

function createBaseVersionResponse(): VersionResponse {
  return { version: "", build: {} };
}

export const VersionResponse = {
  encode(message: VersionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    Object.entries(message.build).forEach(([key, value]) => {
      VersionResponse_BuildEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VersionResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.string();
          break;
        case 2:
          const entry2 = VersionResponse_BuildEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.build[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VersionResponse {
    return {
      version: isSet(object.version) ? String(object.version) : "",
      build: isObject(object.build)
        ? Object.entries(object.build).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: VersionResponse): unknown {
    const obj: any = {};
    message.version !== undefined && (obj.version = message.version);
    obj.build = {};
    if (message.build) {
      Object.entries(message.build).forEach(([k, v]) => {
        obj.build[k] = v;
      });
    }
    return obj;
  },

  create(base?: DeepPartial<VersionResponse>): VersionResponse {
    return VersionResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<VersionResponse>): VersionResponse {
    const message = createBaseVersionResponse();
    message.version = object.version ?? "";
    message.build = Object.entries(object.build ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseVersionResponse_BuildEntry(): VersionResponse_BuildEntry {
  return { key: "", value: "" };
}

export const VersionResponse_BuildEntry = {
  encode(message: VersionResponse_BuildEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VersionResponse_BuildEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionResponse_BuildEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VersionResponse_BuildEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: VersionResponse_BuildEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create(base?: DeepPartial<VersionResponse_BuildEntry>): VersionResponse_BuildEntry {
    return VersionResponse_BuildEntry.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<VersionResponse_BuildEntry>): VersionResponse_BuildEntry {
    const message = createBaseVersionResponse_BuildEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInfoRequest(): InfoRequest {
  return { timestamp: "0" };
}

export const InfoRequest = {
  encode(message: InfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== "0") {
      writer.uint32(8).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InfoRequest {
    return { timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0" };
  },

  toJSON(message: InfoRequest): unknown {
    const obj: any = {};
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<InfoRequest>): InfoRequest {
    return InfoRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<InfoRequest>): InfoRequest {
    const message = createBaseInfoRequest();
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseInfoResponse(): InfoResponse {
  return { timestamp: "0", serverTime: "0", version: "", build: {}, region: "" };
}

export const InfoResponse = {
  encode(message: InfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== "0") {
      writer.uint32(8).sint64(message.timestamp);
    }
    if (message.serverTime !== "0") {
      writer.uint32(16).sint64(message.serverTime);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    Object.entries(message.build).forEach(([key, value]) => {
      InfoResponse_BuildEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.region !== "") {
      writer.uint32(42).string(message.region);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        case 2:
          message.serverTime = longToString(reader.sint64() as Long);
          break;
        case 3:
          message.version = reader.string();
          break;
        case 4:
          const entry4 = InfoResponse_BuildEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.build[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.region = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InfoResponse {
    return {
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      serverTime: isSet(object.serverTime) ? String(object.serverTime) : "0",
      version: isSet(object.version) ? String(object.version) : "",
      build: isObject(object.build)
        ? Object.entries(object.build).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      region: isSet(object.region) ? String(object.region) : "",
    };
  },

  toJSON(message: InfoResponse): unknown {
    const obj: any = {};
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.serverTime !== undefined && (obj.serverTime = message.serverTime);
    message.version !== undefined && (obj.version = message.version);
    obj.build = {};
    if (message.build) {
      Object.entries(message.build).forEach(([k, v]) => {
        obj.build[k] = v;
      });
    }
    message.region !== undefined && (obj.region = message.region);
    return obj;
  },

  create(base?: DeepPartial<InfoResponse>): InfoResponse {
    return InfoResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<InfoResponse>): InfoResponse {
    const message = createBaseInfoResponse();
    message.timestamp = object.timestamp ?? "0";
    message.serverTime = object.serverTime ?? "0";
    message.version = object.version ?? "";
    message.build = Object.entries(object.build ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseInfoResponse_BuildEntry(): InfoResponse_BuildEntry {
  return { key: "", value: "" };
}

export const InfoResponse_BuildEntry = {
  encode(message: InfoResponse_BuildEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfoResponse_BuildEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoResponse_BuildEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InfoResponse_BuildEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: InfoResponse_BuildEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create(base?: DeepPartial<InfoResponse_BuildEntry>): InfoResponse_BuildEntry {
    return InfoResponse_BuildEntry.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<InfoResponse_BuildEntry>): InfoResponse_BuildEntry {
    const message = createBaseInfoResponse_BuildEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStreamKeepaliveRequest(): StreamKeepaliveRequest {
  return {};
}

export const StreamKeepaliveRequest = {
  encode(_: StreamKeepaliveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamKeepaliveRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamKeepaliveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): StreamKeepaliveRequest {
    return {};
  },

  toJSON(_: StreamKeepaliveRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StreamKeepaliveRequest>): StreamKeepaliveRequest {
    return StreamKeepaliveRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<StreamKeepaliveRequest>): StreamKeepaliveRequest {
    const message = createBaseStreamKeepaliveRequest();
    return message;
  },
};

function createBaseStreamKeepaliveResponse(): StreamKeepaliveResponse {
  return { event: "", newEndpoint: "", timestamp: "0" };
}

export const StreamKeepaliveResponse = {
  encode(message: StreamKeepaliveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    if (message.newEndpoint !== "") {
      writer.uint32(18).string(message.newEndpoint);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).sint64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamKeepaliveResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamKeepaliveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.event = reader.string();
          break;
        case 2:
          message.newEndpoint = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamKeepaliveResponse {
    return {
      event: isSet(object.event) ? String(object.event) : "",
      newEndpoint: isSet(object.newEndpoint) ? String(object.newEndpoint) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: StreamKeepaliveResponse): unknown {
    const obj: any = {};
    message.event !== undefined && (obj.event = message.event);
    message.newEndpoint !== undefined && (obj.newEndpoint = message.newEndpoint);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<StreamKeepaliveResponse>): StreamKeepaliveResponse {
    return StreamKeepaliveResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamKeepaliveResponse>): StreamKeepaliveResponse {
    const message = createBaseStreamKeepaliveResponse();
    message.event = object.event ?? "";
    message.newEndpoint = object.newEndpoint ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

/** InjectiveMetaRPC is a special API subset to get info about server. */
export interface InjectiveMetaRPC {
  /** Endpoint for checking server health. */
  Ping(request: DeepPartial<PingRequest>, metadata?: grpc.Metadata): Promise<PingResponse>;
  /** Returns injective-exchange version. */
  Version(request: DeepPartial<VersionRequest>, metadata?: grpc.Metadata): Promise<VersionResponse>;
  /** Gets connection info */
  Info(request: DeepPartial<InfoRequest>, metadata?: grpc.Metadata): Promise<InfoResponse>;
  /**
   * Stream keepalive, if server exits, a shutdown event will be sent over this
   * channel.
   */
  StreamKeepalive(
    request: DeepPartial<StreamKeepaliveRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamKeepaliveResponse>;
}

export class InjectiveMetaRPCClientImpl implements InjectiveMetaRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Ping = this.Ping.bind(this);
    this.Version = this.Version.bind(this);
    this.Info = this.Info.bind(this);
    this.StreamKeepalive = this.StreamKeepalive.bind(this);
  }

  Ping(request: DeepPartial<PingRequest>, metadata?: grpc.Metadata): Promise<PingResponse> {
    return this.rpc.unary(InjectiveMetaRPCPingDesc, PingRequest.fromPartial(request), metadata);
  }

  Version(request: DeepPartial<VersionRequest>, metadata?: grpc.Metadata): Promise<VersionResponse> {
    return this.rpc.unary(InjectiveMetaRPCVersionDesc, VersionRequest.fromPartial(request), metadata);
  }

  Info(request: DeepPartial<InfoRequest>, metadata?: grpc.Metadata): Promise<InfoResponse> {
    return this.rpc.unary(InjectiveMetaRPCInfoDesc, InfoRequest.fromPartial(request), metadata);
  }

  StreamKeepalive(
    request: DeepPartial<StreamKeepaliveRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamKeepaliveResponse> {
    return this.rpc.invoke(InjectiveMetaRPCStreamKeepaliveDesc, StreamKeepaliveRequest.fromPartial(request), metadata);
  }
}

export const InjectiveMetaRPCDesc = { serviceName: "injective_meta_rpc.InjectiveMetaRPC" };

export const InjectiveMetaRPCPingDesc: UnaryMethodDefinitionish = {
  methodName: "Ping",
  service: InjectiveMetaRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PingRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PingResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveMetaRPCVersionDesc: UnaryMethodDefinitionish = {
  methodName: "Version",
  service: InjectiveMetaRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return VersionRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = VersionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveMetaRPCInfoDesc: UnaryMethodDefinitionish = {
  methodName: "Info",
  service: InjectiveMetaRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return InfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = InfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveMetaRPCStreamKeepaliveDesc: UnaryMethodDefinitionish = {
  methodName: "StreamKeepalive",
  service: InjectiveMetaRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamKeepaliveRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamKeepaliveResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes || [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Observable((observer) => {
      const upStream = (() => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          transport: this.options.streamingTransport || this.options.transport,
          metadata: maybeCombinedMetadata,
          debug: this.options.debug,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      });
      upStream();
    }).pipe(share());
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
