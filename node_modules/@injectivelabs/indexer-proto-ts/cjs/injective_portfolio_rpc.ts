/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "injective_portfolio_rpc";

export interface AccountPortfolioRequest {
  /** Account address */
  accountAddress: string;
}

export interface AccountPortfolioResponse {
  /** The portfolio of this account */
  portfolio: Portfolio | undefined;
}

export interface Portfolio {
  /** The account's portfolio address */
  accountAddress: string;
  /** Account available bank balances */
  bankBalances: Coin[];
  /** Subaccounts list */
  subaccounts: SubaccountBalanceV2[];
  /** All positions for all subaccounts, with unrealized PNL */
  positionsWithUpnl: PositionsWithUPNL[];
}

export interface Coin {
  /** Denom of the coin */
  denom: string;
  amount: string;
}

export interface SubaccountBalanceV2 {
  /** Related subaccount ID */
  subaccountId: string;
  /** Coin denom on the chain. */
  denom: string;
  deposit: SubaccountDeposit | undefined;
}

export interface SubaccountDeposit {
  totalBalance: string;
  availableBalance: string;
}

export interface PositionsWithUPNL {
  position:
    | DerivativePosition
    | undefined;
  /** Unrealized PNL */
  unrealizedPnl: string;
}

export interface DerivativePosition {
  /** Ticker of the derivative market */
  ticker: string;
  /** Derivative Market ID */
  marketId: string;
  /** The subaccountId that the position belongs to */
  subaccountId: string;
  /** Direction of the position */
  direction: string;
  /** Quantity of the position */
  quantity: string;
  /** Price of the position */
  entryPrice: string;
  /** Margin of the position */
  margin: string;
  /** LiquidationPrice of the position */
  liquidationPrice: string;
  /** MarkPrice of the position */
  markPrice: string;
  /** Aggregate Quantity of the Reduce Only orders associated with the position */
  aggregateReduceOnlyQuantity: string;
  /** Position updated timestamp in UNIX millis. */
  updatedAt: string;
  /** Position created timestamp in UNIX millis. */
  createdAt: string;
}

export interface StreamAccountPortfolioRequest {
  /** The account's portfolio address */
  accountAddress: string;
  /** Related subaccount ID */
  subaccountId: string;
  type: string;
}

export interface StreamAccountPortfolioResponse {
  /** type of portfolio entry */
  type: string;
  /** denom of portfolio entry */
  denom: string;
  /** amount of portfolio entry */
  amount: string;
  /** subaccount id of portfolio entry */
  subaccountId: string;
}

function createBaseAccountPortfolioRequest(): AccountPortfolioRequest {
  return { accountAddress: "" };
}

export const AccountPortfolioRequest = {
  encode(message: AccountPortfolioRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountPortfolioRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPortfolioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccountPortfolioRequest {
    return { accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "" };
  },

  toJSON(message: AccountPortfolioRequest): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    return obj;
  },

  create(base?: DeepPartial<AccountPortfolioRequest>): AccountPortfolioRequest {
    return AccountPortfolioRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AccountPortfolioRequest>): AccountPortfolioRequest {
    const message = createBaseAccountPortfolioRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseAccountPortfolioResponse(): AccountPortfolioResponse {
  return { portfolio: undefined };
}

export const AccountPortfolioResponse = {
  encode(message: AccountPortfolioResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.portfolio !== undefined) {
      Portfolio.encode(message.portfolio, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountPortfolioResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPortfolioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.portfolio = Portfolio.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccountPortfolioResponse {
    return { portfolio: isSet(object.portfolio) ? Portfolio.fromJSON(object.portfolio) : undefined };
  },

  toJSON(message: AccountPortfolioResponse): unknown {
    const obj: any = {};
    message.portfolio !== undefined &&
      (obj.portfolio = message.portfolio ? Portfolio.toJSON(message.portfolio) : undefined);
    return obj;
  },

  create(base?: DeepPartial<AccountPortfolioResponse>): AccountPortfolioResponse {
    return AccountPortfolioResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AccountPortfolioResponse>): AccountPortfolioResponse {
    const message = createBaseAccountPortfolioResponse();
    message.portfolio = (object.portfolio !== undefined && object.portfolio !== null)
      ? Portfolio.fromPartial(object.portfolio)
      : undefined;
    return message;
  },
};

function createBasePortfolio(): Portfolio {
  return { accountAddress: "", bankBalances: [], subaccounts: [], positionsWithUpnl: [] };
}

export const Portfolio = {
  encode(message: Portfolio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    for (const v of message.bankBalances) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.subaccounts) {
      SubaccountBalanceV2.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.positionsWithUpnl) {
      PositionsWithUPNL.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Portfolio {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        case 2:
          message.bankBalances.push(Coin.decode(reader, reader.uint32()));
          break;
        case 3:
          message.subaccounts.push(SubaccountBalanceV2.decode(reader, reader.uint32()));
          break;
        case 4:
          message.positionsWithUpnl.push(PositionsWithUPNL.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Portfolio {
    return {
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
      bankBalances: Array.isArray(object?.bankBalances) ? object.bankBalances.map((e: any) => Coin.fromJSON(e)) : [],
      subaccounts: Array.isArray(object?.subaccounts)
        ? object.subaccounts.map((e: any) => SubaccountBalanceV2.fromJSON(e))
        : [],
      positionsWithUpnl: Array.isArray(object?.positionsWithUpnl)
        ? object.positionsWithUpnl.map((e: any) => PositionsWithUPNL.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Portfolio): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    if (message.bankBalances) {
      obj.bankBalances = message.bankBalances.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.bankBalances = [];
    }
    if (message.subaccounts) {
      obj.subaccounts = message.subaccounts.map((e) => e ? SubaccountBalanceV2.toJSON(e) : undefined);
    } else {
      obj.subaccounts = [];
    }
    if (message.positionsWithUpnl) {
      obj.positionsWithUpnl = message.positionsWithUpnl.map((e) => e ? PositionsWithUPNL.toJSON(e) : undefined);
    } else {
      obj.positionsWithUpnl = [];
    }
    return obj;
  },

  create(base?: DeepPartial<Portfolio>): Portfolio {
    return Portfolio.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Portfolio>): Portfolio {
    const message = createBasePortfolio();
    message.accountAddress = object.accountAddress ?? "";
    message.bankBalances = object.bankBalances?.map((e) => Coin.fromPartial(e)) || [];
    message.subaccounts = object.subaccounts?.map((e) => SubaccountBalanceV2.fromPartial(e)) || [];
    message.positionsWithUpnl = object.positionsWithUpnl?.map((e) => PositionsWithUPNL.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCoin(): Coin {
  return { denom: "", amount: "" };
}

export const Coin = {
  encode(message: Coin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Coin {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Coin {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: Coin): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  create(base?: DeepPartial<Coin>): Coin {
    return Coin.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Coin>): Coin {
    const message = createBaseCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseSubaccountBalanceV2(): SubaccountBalanceV2 {
  return { subaccountId: "", denom: "", deposit: undefined };
}

export const SubaccountBalanceV2 = {
  encode(message: SubaccountBalanceV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.deposit !== undefined) {
      SubaccountDeposit.encode(message.deposit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountBalanceV2 {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountBalanceV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.deposit = SubaccountDeposit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountBalanceV2 {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      deposit: isSet(object.deposit) ? SubaccountDeposit.fromJSON(object.deposit) : undefined,
    };
  },

  toJSON(message: SubaccountBalanceV2): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    message.deposit !== undefined &&
      (obj.deposit = message.deposit ? SubaccountDeposit.toJSON(message.deposit) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountBalanceV2>): SubaccountBalanceV2 {
    return SubaccountBalanceV2.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountBalanceV2>): SubaccountBalanceV2 {
    const message = createBaseSubaccountBalanceV2();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    message.deposit = (object.deposit !== undefined && object.deposit !== null)
      ? SubaccountDeposit.fromPartial(object.deposit)
      : undefined;
    return message;
  },
};

function createBaseSubaccountDeposit(): SubaccountDeposit {
  return { totalBalance: "", availableBalance: "" };
}

export const SubaccountDeposit = {
  encode(message: SubaccountDeposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalBalance !== "") {
      writer.uint32(10).string(message.totalBalance);
    }
    if (message.availableBalance !== "") {
      writer.uint32(18).string(message.availableBalance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountDeposit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.totalBalance = reader.string();
          break;
        case 2:
          message.availableBalance = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountDeposit {
    return {
      totalBalance: isSet(object.totalBalance) ? String(object.totalBalance) : "",
      availableBalance: isSet(object.availableBalance) ? String(object.availableBalance) : "",
    };
  },

  toJSON(message: SubaccountDeposit): unknown {
    const obj: any = {};
    message.totalBalance !== undefined && (obj.totalBalance = message.totalBalance);
    message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
    return obj;
  },

  create(base?: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    return SubaccountDeposit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    const message = createBaseSubaccountDeposit();
    message.totalBalance = object.totalBalance ?? "";
    message.availableBalance = object.availableBalance ?? "";
    return message;
  },
};

function createBasePositionsWithUPNL(): PositionsWithUPNL {
  return { position: undefined, unrealizedPnl: "" };
}

export const PositionsWithUPNL = {
  encode(message: PositionsWithUPNL, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      DerivativePosition.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.unrealizedPnl !== "") {
      writer.uint32(18).string(message.unrealizedPnl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PositionsWithUPNL {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsWithUPNL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.position = DerivativePosition.decode(reader, reader.uint32());
          break;
        case 2:
          message.unrealizedPnl = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PositionsWithUPNL {
    return {
      position: isSet(object.position) ? DerivativePosition.fromJSON(object.position) : undefined,
      unrealizedPnl: isSet(object.unrealizedPnl) ? String(object.unrealizedPnl) : "",
    };
  },

  toJSON(message: PositionsWithUPNL): unknown {
    const obj: any = {};
    message.position !== undefined &&
      (obj.position = message.position ? DerivativePosition.toJSON(message.position) : undefined);
    message.unrealizedPnl !== undefined && (obj.unrealizedPnl = message.unrealizedPnl);
    return obj;
  },

  create(base?: DeepPartial<PositionsWithUPNL>): PositionsWithUPNL {
    return PositionsWithUPNL.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PositionsWithUPNL>): PositionsWithUPNL {
    const message = createBasePositionsWithUPNL();
    message.position = (object.position !== undefined && object.position !== null)
      ? DerivativePosition.fromPartial(object.position)
      : undefined;
    message.unrealizedPnl = object.unrealizedPnl ?? "";
    return message;
  },
};

function createBaseDerivativePosition(): DerivativePosition {
  return {
    ticker: "",
    marketId: "",
    subaccountId: "",
    direction: "",
    quantity: "",
    entryPrice: "",
    margin: "",
    liquidationPrice: "",
    markPrice: "",
    aggregateReduceOnlyQuantity: "",
    updatedAt: "0",
    createdAt: "0",
  };
}

export const DerivativePosition = {
  encode(message: DerivativePosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticker !== "") {
      writer.uint32(10).string(message.ticker);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.direction !== "") {
      writer.uint32(34).string(message.direction);
    }
    if (message.quantity !== "") {
      writer.uint32(42).string(message.quantity);
    }
    if (message.entryPrice !== "") {
      writer.uint32(50).string(message.entryPrice);
    }
    if (message.margin !== "") {
      writer.uint32(58).string(message.margin);
    }
    if (message.liquidationPrice !== "") {
      writer.uint32(66).string(message.liquidationPrice);
    }
    if (message.markPrice !== "") {
      writer.uint32(74).string(message.markPrice);
    }
    if (message.aggregateReduceOnlyQuantity !== "") {
      writer.uint32(90).string(message.aggregateReduceOnlyQuantity);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(96).sint64(message.updatedAt);
    }
    if (message.createdAt !== "0") {
      writer.uint32(104).sint64(message.createdAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativePosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ticker = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.direction = reader.string();
          break;
        case 5:
          message.quantity = reader.string();
          break;
        case 6:
          message.entryPrice = reader.string();
          break;
        case 7:
          message.margin = reader.string();
          break;
        case 8:
          message.liquidationPrice = reader.string();
          break;
        case 9:
          message.markPrice = reader.string();
          break;
        case 11:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case 12:
          message.updatedAt = longToString(reader.sint64() as Long);
          break;
        case 13:
          message.createdAt = longToString(reader.sint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativePosition {
    return {
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      direction: isSet(object.direction) ? String(object.direction) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      entryPrice: isSet(object.entryPrice) ? String(object.entryPrice) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
      liquidationPrice: isSet(object.liquidationPrice) ? String(object.liquidationPrice) : "",
      markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
      aggregateReduceOnlyQuantity: isSet(object.aggregateReduceOnlyQuantity)
        ? String(object.aggregateReduceOnlyQuantity)
        : "",
      updatedAt: isSet(object.updatedAt) ? String(object.updatedAt) : "0",
      createdAt: isSet(object.createdAt) ? String(object.createdAt) : "0",
    };
  },

  toJSON(message: DerivativePosition): unknown {
    const obj: any = {};
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.direction !== undefined && (obj.direction = message.direction);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.entryPrice !== undefined && (obj.entryPrice = message.entryPrice);
    message.margin !== undefined && (obj.margin = message.margin);
    message.liquidationPrice !== undefined && (obj.liquidationPrice = message.liquidationPrice);
    message.markPrice !== undefined && (obj.markPrice = message.markPrice);
    message.aggregateReduceOnlyQuantity !== undefined &&
      (obj.aggregateReduceOnlyQuantity = message.aggregateReduceOnlyQuantity);
    message.updatedAt !== undefined && (obj.updatedAt = message.updatedAt);
    message.createdAt !== undefined && (obj.createdAt = message.createdAt);
    return obj;
  },

  create(base?: DeepPartial<DerivativePosition>): DerivativePosition {
    return DerivativePosition.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativePosition>): DerivativePosition {
    const message = createBaseDerivativePosition();
    message.ticker = object.ticker ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.direction = object.direction ?? "";
    message.quantity = object.quantity ?? "";
    message.entryPrice = object.entryPrice ?? "";
    message.margin = object.margin ?? "";
    message.liquidationPrice = object.liquidationPrice ?? "";
    message.markPrice = object.markPrice ?? "";
    message.aggregateReduceOnlyQuantity = object.aggregateReduceOnlyQuantity ?? "";
    message.updatedAt = object.updatedAt ?? "0";
    message.createdAt = object.createdAt ?? "0";
    return message;
  },
};

function createBaseStreamAccountPortfolioRequest(): StreamAccountPortfolioRequest {
  return { accountAddress: "", subaccountId: "", type: "" };
}

export const StreamAccountPortfolioRequest = {
  encode(message: StreamAccountPortfolioRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamAccountPortfolioRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccountPortfolioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.type = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamAccountPortfolioRequest {
    return {
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      type: isSet(object.type) ? String(object.type) : "",
    };
  },

  toJSON(message: StreamAccountPortfolioRequest): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.type !== undefined && (obj.type = message.type);
    return obj;
  },

  create(base?: DeepPartial<StreamAccountPortfolioRequest>): StreamAccountPortfolioRequest {
    return StreamAccountPortfolioRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamAccountPortfolioRequest>): StreamAccountPortfolioRequest {
    const message = createBaseStreamAccountPortfolioRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseStreamAccountPortfolioResponse(): StreamAccountPortfolioResponse {
  return { type: "", denom: "", amount: "", subaccountId: "" };
}

export const StreamAccountPortfolioResponse = {
  encode(message: StreamAccountPortfolioResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.subaccountId !== "") {
      writer.uint32(34).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamAccountPortfolioResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAccountPortfolioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.amount = reader.string();
          break;
        case 4:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StreamAccountPortfolioResponse {
    return {
      type: isSet(object.type) ? String(object.type) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
    };
  },

  toJSON(message: StreamAccountPortfolioResponse): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type);
    message.denom !== undefined && (obj.denom = message.denom);
    message.amount !== undefined && (obj.amount = message.amount);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<StreamAccountPortfolioResponse>): StreamAccountPortfolioResponse {
    return StreamAccountPortfolioResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<StreamAccountPortfolioResponse>): StreamAccountPortfolioResponse {
    const message = createBaseStreamAccountPortfolioResponse();
    message.type = object.type ?? "";
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

/** InjectivePortfolioRPC defines gRPC API of Exchange Portfolio provider. */
export interface InjectivePortfolioRPC {
  /** Provide the account's portfolio */
  AccountPortfolio(
    request: DeepPartial<AccountPortfolioRequest>,
    metadata?: grpc.Metadata,
  ): Promise<AccountPortfolioResponse>;
  /** Stream the account's portfolio */
  StreamAccountPortfolio(
    request: DeepPartial<StreamAccountPortfolioRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamAccountPortfolioResponse>;
}

export class InjectivePortfolioRPCClientImpl implements InjectivePortfolioRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.AccountPortfolio = this.AccountPortfolio.bind(this);
    this.StreamAccountPortfolio = this.StreamAccountPortfolio.bind(this);
  }

  AccountPortfolio(
    request: DeepPartial<AccountPortfolioRequest>,
    metadata?: grpc.Metadata,
  ): Promise<AccountPortfolioResponse> {
    return this.rpc.unary(
      InjectivePortfolioRPCAccountPortfolioDesc,
      AccountPortfolioRequest.fromPartial(request),
      metadata,
    );
  }

  StreamAccountPortfolio(
    request: DeepPartial<StreamAccountPortfolioRequest>,
    metadata?: grpc.Metadata,
  ): Observable<StreamAccountPortfolioResponse> {
    return this.rpc.invoke(
      InjectivePortfolioRPCStreamAccountPortfolioDesc,
      StreamAccountPortfolioRequest.fromPartial(request),
      metadata,
    );
  }
}

export const InjectivePortfolioRPCDesc = { serviceName: "injective_portfolio_rpc.InjectivePortfolioRPC" };

export const InjectivePortfolioRPCAccountPortfolioDesc: UnaryMethodDefinitionish = {
  methodName: "AccountPortfolio",
  service: InjectivePortfolioRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AccountPortfolioRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AccountPortfolioResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectivePortfolioRPCStreamAccountPortfolioDesc: UnaryMethodDefinitionish = {
  methodName: "StreamAccountPortfolio",
  service: InjectivePortfolioRPCDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return StreamAccountPortfolioRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StreamAccountPortfolioResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes || [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Observable((observer) => {
      const upStream = (() => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          transport: this.options.streamingTransport || this.options.transport,
          metadata: maybeCombinedMetadata,
          debug: this.options.debug,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      });
      upStream();
    }).pipe(share());
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
