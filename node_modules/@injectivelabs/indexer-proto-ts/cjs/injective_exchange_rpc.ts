/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "injective_exchange_rpc";

export interface GetTxRequest {
  /** Transaction hash in hex without 0x prefix (Cosmos-like). */
  hash: string;
}

export interface GetTxResponse {
  /** Hex-encoded Tendermint transaction hash */
  txHash: string;
  /** The block height */
  height: string;
  /** Tx index in the block */
  index: number;
  /** Namespace for the resp code */
  codespace: string;
  /** Response code */
  code: number;
  /** Result bytes, if any */
  data: Uint8Array;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   */
  rawLog: string;
  /** Time of the previous block. */
  timestamp: string;
}

export interface PrepareTxRequest {
  /** Specify chainID for the target tx */
  chainId: string;
  /** Specify Ethereum address of a signer */
  signerAddress: string;
  /** Account sequence number (nonce) of signer */
  sequence: string;
  /** Textual memo information to attach with tx */
  memo: string;
  /** Block height until which the transaction is valid. */
  timeoutHeight: string;
  /** Transaction fee details. */
  fee:
    | CosmosTxFee
    | undefined;
  /** List of Cosmos proto3-encoded Msgs to include in a single tx */
  msgs: Uint8Array[];
}

export interface CosmosTxFee {
  /** Transaction gas price */
  price: CosmosCoin[];
  /** Transaction gas limit */
  gas: string;
  /**
   * Explicitly require fee delegation when set to true. Or don't care = false.
   * Will be replaced by other flag in the next version.
   */
  delegateFee: boolean;
}

export interface CosmosCoin {
  /** Coin denominator */
  denom: string;
  /** Coin amount (big int) */
  amount: string;
}

export interface PrepareTxResponse {
  /** EIP712-compatible message suitable for signing with eth_signTypedData_v4 */
  data: string;
  /** Account tx sequence (nonce) */
  sequence: string;
  /** Sign mode for the resulting tx */
  signMode: string;
  /** Specify proto-URL of a public key, which defines the signature format */
  pubKeyType: string;
  /** Fee payer address provided by service */
  feePayer: string;
  /** Hex-encoded ethsecp256k1 signature bytes from fee payer */
  feePayerSig: string;
}

export interface BroadcastTxRequest {
  /** Specify Web3 chainID (from prepateTx) for the target Tx */
  chainId: string;
  /** Amino-encoded Tx JSON data (except Msgs) */
  tx: Uint8Array;
  /** List of Cosmos proto3-encoded Msgs from tx */
  msgs: Uint8Array[];
  /** Specify ethsecp256k1 pubkey of the signer */
  pubKey:
    | CosmosPubKey
    | undefined;
  /** Hex-encoded ethsecp256k1 signature bytes */
  signature: string;
  /** Fee payer address provided by service */
  feePayer: string;
  /** Hex-encoded ethsecp256k1 signature bytes from fee payer */
  feePayerSig: string;
  /** Broadcast mode */
  mode: string;
}

export interface CosmosPubKey {
  /** Pubkey type URL */
  type: string;
  /** Hex-encoded string of the public key */
  key: string;
}

export interface BroadcastTxResponse {
  /** Hex-encoded Tendermint transaction hash */
  txHash: string;
  /** The block height */
  height: string;
  /** Tx index in the block */
  index: number;
  /** Namespace for the resp code */
  codespace: string;
  /** Response code */
  code: number;
  /** Result bytes, if any */
  data: Uint8Array;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   */
  rawLog: string;
  /** Time of the previous block. */
  timestamp: string;
}

export interface PrepareCosmosTxRequest {
  /** Specify chainID for the target tx */
  chainId: string;
  /** sender address provided */
  senderAddress: string;
  /** Textual memo information to attach with tx */
  memo: string;
  /** Block height until which the transaction is valid. */
  timeoutHeight: string;
  /** Transaction fee details. */
  fee:
    | CosmosTxFee
    | undefined;
  /** List of Cosmos proto3-encoded Msgs to include in a single tx */
  msgs: Uint8Array[];
}

export interface PrepareCosmosTxResponse {
  /** proto encoded tx */
  tx: Uint8Array;
  /** Sign mode for the resulting tx */
  signMode: string;
  /** Specify proto-URL of a public key, which defines the signature format */
  pubKeyType: string;
  /** Fee payer address provided by service */
  feePayer: string;
  /** Hex-encoded ethsecp256k1 signature bytes from fee payer */
  feePayerSig: string;
  /** ethsecp256k1 feePayer pubkey */
  feePayerPubKey: CosmosPubKey | undefined;
}

export interface BroadcastCosmosTxRequest {
  /** proto encoded tx */
  tx: Uint8Array;
  /** Specify ethsecp256k1 sender pubkey */
  pubKey:
    | CosmosPubKey
    | undefined;
  /** Hex-encoded ethsecp256k1 sender signature bytes */
  signature: string;
  /** sender address */
  senderAddress: string;
}

export interface BroadcastCosmosTxResponse {
  /** Hex-encoded Tendermint transaction hash */
  txHash: string;
  /** The block height */
  height: string;
  /** Tx index in the block */
  index: number;
  /** Namespace for the resp code */
  codespace: string;
  /** Response code */
  code: number;
  /** Result bytes, if any */
  data: Uint8Array;
  /**
   * The output of the application's logger (raw string). May be
   * non-deterministic.
   */
  rawLog: string;
  /** Time of the previous block. */
  timestamp: string;
}

export interface GetFeePayerRequest {
}

export interface GetFeePayerResponse {
  /** Fee payer address provided by service */
  feePayer: string;
  /** ethsecp256k1 feePayer pubkey */
  feePayerPubKey: CosmosPubKey | undefined;
}

function createBaseGetTxRequest(): GetTxRequest {
  return { hash: "" };
}

export const GetTxRequest = {
  encode(message: GetTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTxRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetTxRequest {
    return { hash: isSet(object.hash) ? String(object.hash) : "" };
  },

  toJSON(message: GetTxRequest): unknown {
    const obj: any = {};
    message.hash !== undefined && (obj.hash = message.hash);
    return obj;
  },

  create(base?: DeepPartial<GetTxRequest>): GetTxRequest {
    return GetTxRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetTxRequest>): GetTxRequest {
    const message = createBaseGetTxRequest();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseGetTxResponse(): GetTxResponse {
  return {
    txHash: "",
    height: "0",
    index: 0,
    codespace: "",
    code: 0,
    data: new Uint8Array(),
    rawLog: "",
    timestamp: "",
  };
}

export const GetTxResponse = {
  encode(message: GetTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.height !== "0") {
      writer.uint32(16).sint64(message.height);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.codespace !== "") {
      writer.uint32(34).string(message.codespace);
    }
    if (message.code !== 0) {
      writer.uint32(40).uint32(message.code);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.rawLog !== "") {
      writer.uint32(58).string(message.rawLog);
    }
    if (message.timestamp !== "") {
      writer.uint32(66).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTxResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txHash = reader.string();
          break;
        case 2:
          message.height = longToString(reader.sint64() as Long);
          break;
        case 3:
          message.index = reader.uint32();
          break;
        case 4:
          message.codespace = reader.string();
          break;
        case 5:
          message.code = reader.uint32();
          break;
        case 6:
          message.data = reader.bytes();
          break;
        case 7:
          message.rawLog = reader.string();
          break;
        case 8:
          message.timestamp = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetTxResponse {
    return {
      txHash: isSet(object.txHash) ? String(object.txHash) : "",
      height: isSet(object.height) ? String(object.height) : "0",
      index: isSet(object.index) ? Number(object.index) : 0,
      codespace: isSet(object.codespace) ? String(object.codespace) : "",
      code: isSet(object.code) ? Number(object.code) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      rawLog: isSet(object.rawLog) ? String(object.rawLog) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "",
    };
  },

  toJSON(message: GetTxResponse): unknown {
    const obj: any = {};
    message.txHash !== undefined && (obj.txHash = message.txHash);
    message.height !== undefined && (obj.height = message.height);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.codespace !== undefined && (obj.codespace = message.codespace);
    message.code !== undefined && (obj.code = Math.round(message.code));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    message.rawLog !== undefined && (obj.rawLog = message.rawLog);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<GetTxResponse>): GetTxResponse {
    return GetTxResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetTxResponse>): GetTxResponse {
    const message = createBaseGetTxResponse();
    message.txHash = object.txHash ?? "";
    message.height = object.height ?? "0";
    message.index = object.index ?? 0;
    message.codespace = object.codespace ?? "";
    message.code = object.code ?? 0;
    message.data = object.data ?? new Uint8Array();
    message.rawLog = object.rawLog ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBasePrepareTxRequest(): PrepareTxRequest {
  return { chainId: "0", signerAddress: "", sequence: "0", memo: "", timeoutHeight: "0", fee: undefined, msgs: [] };
}

export const PrepareTxRequest = {
  encode(message: PrepareTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "0") {
      writer.uint32(8).uint64(message.chainId);
    }
    if (message.signerAddress !== "") {
      writer.uint32(18).string(message.signerAddress);
    }
    if (message.sequence !== "0") {
      writer.uint32(24).uint64(message.sequence);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    if (message.timeoutHeight !== "0") {
      writer.uint32(40).uint64(message.timeoutHeight);
    }
    if (message.fee !== undefined) {
      CosmosTxFee.encode(message.fee, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.msgs) {
      writer.uint32(58).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrepareTxRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chainId = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.signerAddress = reader.string();
          break;
        case 3:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.memo = reader.string();
          break;
        case 5:
          message.timeoutHeight = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.fee = CosmosTxFee.decode(reader, reader.uint32());
          break;
        case 7:
          message.msgs.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrepareTxRequest {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "0",
      signerAddress: isSet(object.signerAddress) ? String(object.signerAddress) : "",
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      memo: isSet(object.memo) ? String(object.memo) : "",
      timeoutHeight: isSet(object.timeoutHeight) ? String(object.timeoutHeight) : "0",
      fee: isSet(object.fee) ? CosmosTxFee.fromJSON(object.fee) : undefined,
      msgs: Array.isArray(object?.msgs) ? object.msgs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: PrepareTxRequest): unknown {
    const obj: any = {};
    message.chainId !== undefined && (obj.chainId = message.chainId);
    message.signerAddress !== undefined && (obj.signerAddress = message.signerAddress);
    message.sequence !== undefined && (obj.sequence = message.sequence);
    message.memo !== undefined && (obj.memo = message.memo);
    message.timeoutHeight !== undefined && (obj.timeoutHeight = message.timeoutHeight);
    message.fee !== undefined && (obj.fee = message.fee ? CosmosTxFee.toJSON(message.fee) : undefined);
    if (message.msgs) {
      obj.msgs = message.msgs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.msgs = [];
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareTxRequest>): PrepareTxRequest {
    return PrepareTxRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PrepareTxRequest>): PrepareTxRequest {
    const message = createBasePrepareTxRequest();
    message.chainId = object.chainId ?? "0";
    message.signerAddress = object.signerAddress ?? "";
    message.sequence = object.sequence ?? "0";
    message.memo = object.memo ?? "";
    message.timeoutHeight = object.timeoutHeight ?? "0";
    message.fee = (object.fee !== undefined && object.fee !== null) ? CosmosTxFee.fromPartial(object.fee) : undefined;
    message.msgs = object.msgs?.map((e) => e) || [];
    return message;
  },
};

function createBaseCosmosTxFee(): CosmosTxFee {
  return { price: [], gas: "0", delegateFee: false };
}

export const CosmosTxFee = {
  encode(message: CosmosTxFee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.price) {
      CosmosCoin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.gas !== "0") {
      writer.uint32(16).uint64(message.gas);
    }
    if (message.delegateFee === true) {
      writer.uint32(24).bool(message.delegateFee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosTxFee {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosTxFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price.push(CosmosCoin.decode(reader, reader.uint32()));
          break;
        case 2:
          message.gas = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.delegateFee = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CosmosTxFee {
    return {
      price: Array.isArray(object?.price) ? object.price.map((e: any) => CosmosCoin.fromJSON(e)) : [],
      gas: isSet(object.gas) ? String(object.gas) : "0",
      delegateFee: isSet(object.delegateFee) ? Boolean(object.delegateFee) : false,
    };
  },

  toJSON(message: CosmosTxFee): unknown {
    const obj: any = {};
    if (message.price) {
      obj.price = message.price.map((e) => e ? CosmosCoin.toJSON(e) : undefined);
    } else {
      obj.price = [];
    }
    message.gas !== undefined && (obj.gas = message.gas);
    message.delegateFee !== undefined && (obj.delegateFee = message.delegateFee);
    return obj;
  },

  create(base?: DeepPartial<CosmosTxFee>): CosmosTxFee {
    return CosmosTxFee.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CosmosTxFee>): CosmosTxFee {
    const message = createBaseCosmosTxFee();
    message.price = object.price?.map((e) => CosmosCoin.fromPartial(e)) || [];
    message.gas = object.gas ?? "0";
    message.delegateFee = object.delegateFee ?? false;
    return message;
  },
};

function createBaseCosmosCoin(): CosmosCoin {
  return { denom: "", amount: "" };
}

export const CosmosCoin = {
  encode(message: CosmosCoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosCoin {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CosmosCoin {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: CosmosCoin): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  create(base?: DeepPartial<CosmosCoin>): CosmosCoin {
    return CosmosCoin.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CosmosCoin>): CosmosCoin {
    const message = createBaseCosmosCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBasePrepareTxResponse(): PrepareTxResponse {
  return { data: "", sequence: "0", signMode: "", pubKeyType: "", feePayer: "", feePayerSig: "" };
}

export const PrepareTxResponse = {
  encode(message: PrepareTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.sequence !== "0") {
      writer.uint32(16).uint64(message.sequence);
    }
    if (message.signMode !== "") {
      writer.uint32(26).string(message.signMode);
    }
    if (message.pubKeyType !== "") {
      writer.uint32(34).string(message.pubKeyType);
    }
    if (message.feePayer !== "") {
      writer.uint32(42).string(message.feePayer);
    }
    if (message.feePayerSig !== "") {
      writer.uint32(50).string(message.feePayerSig);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrepareTxResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.string();
          break;
        case 2:
          message.sequence = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.signMode = reader.string();
          break;
        case 4:
          message.pubKeyType = reader.string();
          break;
        case 5:
          message.feePayer = reader.string();
          break;
        case 6:
          message.feePayerSig = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrepareTxResponse {
    return {
      data: isSet(object.data) ? String(object.data) : "",
      sequence: isSet(object.sequence) ? String(object.sequence) : "0",
      signMode: isSet(object.signMode) ? String(object.signMode) : "",
      pubKeyType: isSet(object.pubKeyType) ? String(object.pubKeyType) : "",
      feePayer: isSet(object.feePayer) ? String(object.feePayer) : "",
      feePayerSig: isSet(object.feePayerSig) ? String(object.feePayerSig) : "",
    };
  },

  toJSON(message: PrepareTxResponse): unknown {
    const obj: any = {};
    message.data !== undefined && (obj.data = message.data);
    message.sequence !== undefined && (obj.sequence = message.sequence);
    message.signMode !== undefined && (obj.signMode = message.signMode);
    message.pubKeyType !== undefined && (obj.pubKeyType = message.pubKeyType);
    message.feePayer !== undefined && (obj.feePayer = message.feePayer);
    message.feePayerSig !== undefined && (obj.feePayerSig = message.feePayerSig);
    return obj;
  },

  create(base?: DeepPartial<PrepareTxResponse>): PrepareTxResponse {
    return PrepareTxResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PrepareTxResponse>): PrepareTxResponse {
    const message = createBasePrepareTxResponse();
    message.data = object.data ?? "";
    message.sequence = object.sequence ?? "0";
    message.signMode = object.signMode ?? "";
    message.pubKeyType = object.pubKeyType ?? "";
    message.feePayer = object.feePayer ?? "";
    message.feePayerSig = object.feePayerSig ?? "";
    return message;
  },
};

function createBaseBroadcastTxRequest(): BroadcastTxRequest {
  return {
    chainId: "0",
    tx: new Uint8Array(),
    msgs: [],
    pubKey: undefined,
    signature: "",
    feePayer: "",
    feePayerSig: "",
    mode: "",
  };
}

export const BroadcastTxRequest = {
  encode(message: BroadcastTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "0") {
      writer.uint32(8).uint64(message.chainId);
    }
    if (message.tx.length !== 0) {
      writer.uint32(18).bytes(message.tx);
    }
    for (const v of message.msgs) {
      writer.uint32(26).bytes(v!);
    }
    if (message.pubKey !== undefined) {
      CosmosPubKey.encode(message.pubKey, writer.uint32(34).fork()).ldelim();
    }
    if (message.signature !== "") {
      writer.uint32(42).string(message.signature);
    }
    if (message.feePayer !== "") {
      writer.uint32(50).string(message.feePayer);
    }
    if (message.feePayerSig !== "") {
      writer.uint32(58).string(message.feePayerSig);
    }
    if (message.mode !== "") {
      writer.uint32(66).string(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastTxRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chainId = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.tx = reader.bytes();
          break;
        case 3:
          message.msgs.push(reader.bytes());
          break;
        case 4:
          message.pubKey = CosmosPubKey.decode(reader, reader.uint32());
          break;
        case 5:
          message.signature = reader.string();
          break;
        case 6:
          message.feePayer = reader.string();
          break;
        case 7:
          message.feePayerSig = reader.string();
          break;
        case 8:
          message.mode = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BroadcastTxRequest {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "0",
      tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(),
      msgs: Array.isArray(object?.msgs) ? object.msgs.map((e: any) => bytesFromBase64(e)) : [],
      pubKey: isSet(object.pubKey) ? CosmosPubKey.fromJSON(object.pubKey) : undefined,
      signature: isSet(object.signature) ? String(object.signature) : "",
      feePayer: isSet(object.feePayer) ? String(object.feePayer) : "",
      feePayerSig: isSet(object.feePayerSig) ? String(object.feePayerSig) : "",
      mode: isSet(object.mode) ? String(object.mode) : "",
    };
  },

  toJSON(message: BroadcastTxRequest): unknown {
    const obj: any = {};
    message.chainId !== undefined && (obj.chainId = message.chainId);
    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));
    if (message.msgs) {
      obj.msgs = message.msgs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.msgs = [];
    }
    message.pubKey !== undefined && (obj.pubKey = message.pubKey ? CosmosPubKey.toJSON(message.pubKey) : undefined);
    message.signature !== undefined && (obj.signature = message.signature);
    message.feePayer !== undefined && (obj.feePayer = message.feePayer);
    message.feePayerSig !== undefined && (obj.feePayerSig = message.feePayerSig);
    message.mode !== undefined && (obj.mode = message.mode);
    return obj;
  },

  create(base?: DeepPartial<BroadcastTxRequest>): BroadcastTxRequest {
    return BroadcastTxRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BroadcastTxRequest>): BroadcastTxRequest {
    const message = createBaseBroadcastTxRequest();
    message.chainId = object.chainId ?? "0";
    message.tx = object.tx ?? new Uint8Array();
    message.msgs = object.msgs?.map((e) => e) || [];
    message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
      ? CosmosPubKey.fromPartial(object.pubKey)
      : undefined;
    message.signature = object.signature ?? "";
    message.feePayer = object.feePayer ?? "";
    message.feePayerSig = object.feePayerSig ?? "";
    message.mode = object.mode ?? "";
    return message;
  },
};

function createBaseCosmosPubKey(): CosmosPubKey {
  return { type: "", key: "" };
}

export const CosmosPubKey = {
  encode(message: CosmosPubKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosPubKey {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosPubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CosmosPubKey {
    return { type: isSet(object.type) ? String(object.type) : "", key: isSet(object.key) ? String(object.key) : "" };
  },

  toJSON(message: CosmosPubKey): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  create(base?: DeepPartial<CosmosPubKey>): CosmosPubKey {
    return CosmosPubKey.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CosmosPubKey>): CosmosPubKey {
    const message = createBaseCosmosPubKey();
    message.type = object.type ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseBroadcastTxResponse(): BroadcastTxResponse {
  return {
    txHash: "",
    height: "0",
    index: 0,
    codespace: "",
    code: 0,
    data: new Uint8Array(),
    rawLog: "",
    timestamp: "",
  };
}

export const BroadcastTxResponse = {
  encode(message: BroadcastTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.height !== "0") {
      writer.uint32(16).sint64(message.height);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.codespace !== "") {
      writer.uint32(34).string(message.codespace);
    }
    if (message.code !== 0) {
      writer.uint32(40).uint32(message.code);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.rawLog !== "") {
      writer.uint32(58).string(message.rawLog);
    }
    if (message.timestamp !== "") {
      writer.uint32(66).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastTxResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txHash = reader.string();
          break;
        case 2:
          message.height = longToString(reader.sint64() as Long);
          break;
        case 3:
          message.index = reader.uint32();
          break;
        case 4:
          message.codespace = reader.string();
          break;
        case 5:
          message.code = reader.uint32();
          break;
        case 6:
          message.data = reader.bytes();
          break;
        case 7:
          message.rawLog = reader.string();
          break;
        case 8:
          message.timestamp = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BroadcastTxResponse {
    return {
      txHash: isSet(object.txHash) ? String(object.txHash) : "",
      height: isSet(object.height) ? String(object.height) : "0",
      index: isSet(object.index) ? Number(object.index) : 0,
      codespace: isSet(object.codespace) ? String(object.codespace) : "",
      code: isSet(object.code) ? Number(object.code) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      rawLog: isSet(object.rawLog) ? String(object.rawLog) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "",
    };
  },

  toJSON(message: BroadcastTxResponse): unknown {
    const obj: any = {};
    message.txHash !== undefined && (obj.txHash = message.txHash);
    message.height !== undefined && (obj.height = message.height);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.codespace !== undefined && (obj.codespace = message.codespace);
    message.code !== undefined && (obj.code = Math.round(message.code));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    message.rawLog !== undefined && (obj.rawLog = message.rawLog);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<BroadcastTxResponse>): BroadcastTxResponse {
    return BroadcastTxResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BroadcastTxResponse>): BroadcastTxResponse {
    const message = createBaseBroadcastTxResponse();
    message.txHash = object.txHash ?? "";
    message.height = object.height ?? "0";
    message.index = object.index ?? 0;
    message.codespace = object.codespace ?? "";
    message.code = object.code ?? 0;
    message.data = object.data ?? new Uint8Array();
    message.rawLog = object.rawLog ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBasePrepareCosmosTxRequest(): PrepareCosmosTxRequest {
  return { chainId: "0", senderAddress: "", memo: "", timeoutHeight: "0", fee: undefined, msgs: [] };
}

export const PrepareCosmosTxRequest = {
  encode(message: PrepareCosmosTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "0") {
      writer.uint32(8).uint64(message.chainId);
    }
    if (message.senderAddress !== "") {
      writer.uint32(18).string(message.senderAddress);
    }
    if (message.memo !== "") {
      writer.uint32(26).string(message.memo);
    }
    if (message.timeoutHeight !== "0") {
      writer.uint32(32).uint64(message.timeoutHeight);
    }
    if (message.fee !== undefined) {
      CosmosTxFee.encode(message.fee, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.msgs) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrepareCosmosTxRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareCosmosTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chainId = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.senderAddress = reader.string();
          break;
        case 3:
          message.memo = reader.string();
          break;
        case 4:
          message.timeoutHeight = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.fee = CosmosTxFee.decode(reader, reader.uint32());
          break;
        case 6:
          message.msgs.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrepareCosmosTxRequest {
    return {
      chainId: isSet(object.chainId) ? String(object.chainId) : "0",
      senderAddress: isSet(object.senderAddress) ? String(object.senderAddress) : "",
      memo: isSet(object.memo) ? String(object.memo) : "",
      timeoutHeight: isSet(object.timeoutHeight) ? String(object.timeoutHeight) : "0",
      fee: isSet(object.fee) ? CosmosTxFee.fromJSON(object.fee) : undefined,
      msgs: Array.isArray(object?.msgs) ? object.msgs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: PrepareCosmosTxRequest): unknown {
    const obj: any = {};
    message.chainId !== undefined && (obj.chainId = message.chainId);
    message.senderAddress !== undefined && (obj.senderAddress = message.senderAddress);
    message.memo !== undefined && (obj.memo = message.memo);
    message.timeoutHeight !== undefined && (obj.timeoutHeight = message.timeoutHeight);
    message.fee !== undefined && (obj.fee = message.fee ? CosmosTxFee.toJSON(message.fee) : undefined);
    if (message.msgs) {
      obj.msgs = message.msgs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.msgs = [];
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareCosmosTxRequest>): PrepareCosmosTxRequest {
    return PrepareCosmosTxRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PrepareCosmosTxRequest>): PrepareCosmosTxRequest {
    const message = createBasePrepareCosmosTxRequest();
    message.chainId = object.chainId ?? "0";
    message.senderAddress = object.senderAddress ?? "";
    message.memo = object.memo ?? "";
    message.timeoutHeight = object.timeoutHeight ?? "0";
    message.fee = (object.fee !== undefined && object.fee !== null) ? CosmosTxFee.fromPartial(object.fee) : undefined;
    message.msgs = object.msgs?.map((e) => e) || [];
    return message;
  },
};

function createBasePrepareCosmosTxResponse(): PrepareCosmosTxResponse {
  return {
    tx: new Uint8Array(),
    signMode: "",
    pubKeyType: "",
    feePayer: "",
    feePayerSig: "",
    feePayerPubKey: undefined,
  };
}

export const PrepareCosmosTxResponse = {
  encode(message: PrepareCosmosTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx.length !== 0) {
      writer.uint32(10).bytes(message.tx);
    }
    if (message.signMode !== "") {
      writer.uint32(18).string(message.signMode);
    }
    if (message.pubKeyType !== "") {
      writer.uint32(26).string(message.pubKeyType);
    }
    if (message.feePayer !== "") {
      writer.uint32(34).string(message.feePayer);
    }
    if (message.feePayerSig !== "") {
      writer.uint32(42).string(message.feePayerSig);
    }
    if (message.feePayerPubKey !== undefined) {
      CosmosPubKey.encode(message.feePayerPubKey, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrepareCosmosTxResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareCosmosTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = reader.bytes();
          break;
        case 2:
          message.signMode = reader.string();
          break;
        case 3:
          message.pubKeyType = reader.string();
          break;
        case 4:
          message.feePayer = reader.string();
          break;
        case 5:
          message.feePayerSig = reader.string();
          break;
        case 6:
          message.feePayerPubKey = CosmosPubKey.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrepareCosmosTxResponse {
    return {
      tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(),
      signMode: isSet(object.signMode) ? String(object.signMode) : "",
      pubKeyType: isSet(object.pubKeyType) ? String(object.pubKeyType) : "",
      feePayer: isSet(object.feePayer) ? String(object.feePayer) : "",
      feePayerSig: isSet(object.feePayerSig) ? String(object.feePayerSig) : "",
      feePayerPubKey: isSet(object.feePayerPubKey) ? CosmosPubKey.fromJSON(object.feePayerPubKey) : undefined,
    };
  },

  toJSON(message: PrepareCosmosTxResponse): unknown {
    const obj: any = {};
    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));
    message.signMode !== undefined && (obj.signMode = message.signMode);
    message.pubKeyType !== undefined && (obj.pubKeyType = message.pubKeyType);
    message.feePayer !== undefined && (obj.feePayer = message.feePayer);
    message.feePayerSig !== undefined && (obj.feePayerSig = message.feePayerSig);
    message.feePayerPubKey !== undefined &&
      (obj.feePayerPubKey = message.feePayerPubKey ? CosmosPubKey.toJSON(message.feePayerPubKey) : undefined);
    return obj;
  },

  create(base?: DeepPartial<PrepareCosmosTxResponse>): PrepareCosmosTxResponse {
    return PrepareCosmosTxResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PrepareCosmosTxResponse>): PrepareCosmosTxResponse {
    const message = createBasePrepareCosmosTxResponse();
    message.tx = object.tx ?? new Uint8Array();
    message.signMode = object.signMode ?? "";
    message.pubKeyType = object.pubKeyType ?? "";
    message.feePayer = object.feePayer ?? "";
    message.feePayerSig = object.feePayerSig ?? "";
    message.feePayerPubKey = (object.feePayerPubKey !== undefined && object.feePayerPubKey !== null)
      ? CosmosPubKey.fromPartial(object.feePayerPubKey)
      : undefined;
    return message;
  },
};

function createBaseBroadcastCosmosTxRequest(): BroadcastCosmosTxRequest {
  return { tx: new Uint8Array(), pubKey: undefined, signature: "", senderAddress: "" };
}

export const BroadcastCosmosTxRequest = {
  encode(message: BroadcastCosmosTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx.length !== 0) {
      writer.uint32(10).bytes(message.tx);
    }
    if (message.pubKey !== undefined) {
      CosmosPubKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.senderAddress !== "") {
      writer.uint32(34).string(message.senderAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastCosmosTxRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastCosmosTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = reader.bytes();
          break;
        case 2:
          message.pubKey = CosmosPubKey.decode(reader, reader.uint32());
          break;
        case 3:
          message.signature = reader.string();
          break;
        case 4:
          message.senderAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BroadcastCosmosTxRequest {
    return {
      tx: isSet(object.tx) ? bytesFromBase64(object.tx) : new Uint8Array(),
      pubKey: isSet(object.pubKey) ? CosmosPubKey.fromJSON(object.pubKey) : undefined,
      signature: isSet(object.signature) ? String(object.signature) : "",
      senderAddress: isSet(object.senderAddress) ? String(object.senderAddress) : "",
    };
  },

  toJSON(message: BroadcastCosmosTxRequest): unknown {
    const obj: any = {};
    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));
    message.pubKey !== undefined && (obj.pubKey = message.pubKey ? CosmosPubKey.toJSON(message.pubKey) : undefined);
    message.signature !== undefined && (obj.signature = message.signature);
    message.senderAddress !== undefined && (obj.senderAddress = message.senderAddress);
    return obj;
  },

  create(base?: DeepPartial<BroadcastCosmosTxRequest>): BroadcastCosmosTxRequest {
    return BroadcastCosmosTxRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BroadcastCosmosTxRequest>): BroadcastCosmosTxRequest {
    const message = createBaseBroadcastCosmosTxRequest();
    message.tx = object.tx ?? new Uint8Array();
    message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
      ? CosmosPubKey.fromPartial(object.pubKey)
      : undefined;
    message.signature = object.signature ?? "";
    message.senderAddress = object.senderAddress ?? "";
    return message;
  },
};

function createBaseBroadcastCosmosTxResponse(): BroadcastCosmosTxResponse {
  return {
    txHash: "",
    height: "0",
    index: 0,
    codespace: "",
    code: 0,
    data: new Uint8Array(),
    rawLog: "",
    timestamp: "",
  };
}

export const BroadcastCosmosTxResponse = {
  encode(message: BroadcastCosmosTxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.height !== "0") {
      writer.uint32(16).sint64(message.height);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.codespace !== "") {
      writer.uint32(34).string(message.codespace);
    }
    if (message.code !== 0) {
      writer.uint32(40).uint32(message.code);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.rawLog !== "") {
      writer.uint32(58).string(message.rawLog);
    }
    if (message.timestamp !== "") {
      writer.uint32(66).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastCosmosTxResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastCosmosTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txHash = reader.string();
          break;
        case 2:
          message.height = longToString(reader.sint64() as Long);
          break;
        case 3:
          message.index = reader.uint32();
          break;
        case 4:
          message.codespace = reader.string();
          break;
        case 5:
          message.code = reader.uint32();
          break;
        case 6:
          message.data = reader.bytes();
          break;
        case 7:
          message.rawLog = reader.string();
          break;
        case 8:
          message.timestamp = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BroadcastCosmosTxResponse {
    return {
      txHash: isSet(object.txHash) ? String(object.txHash) : "",
      height: isSet(object.height) ? String(object.height) : "0",
      index: isSet(object.index) ? Number(object.index) : 0,
      codespace: isSet(object.codespace) ? String(object.codespace) : "",
      code: isSet(object.code) ? Number(object.code) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      rawLog: isSet(object.rawLog) ? String(object.rawLog) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "",
    };
  },

  toJSON(message: BroadcastCosmosTxResponse): unknown {
    const obj: any = {};
    message.txHash !== undefined && (obj.txHash = message.txHash);
    message.height !== undefined && (obj.height = message.height);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.codespace !== undefined && (obj.codespace = message.codespace);
    message.code !== undefined && (obj.code = Math.round(message.code));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    message.rawLog !== undefined && (obj.rawLog = message.rawLog);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<BroadcastCosmosTxResponse>): BroadcastCosmosTxResponse {
    return BroadcastCosmosTxResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BroadcastCosmosTxResponse>): BroadcastCosmosTxResponse {
    const message = createBaseBroadcastCosmosTxResponse();
    message.txHash = object.txHash ?? "";
    message.height = object.height ?? "0";
    message.index = object.index ?? 0;
    message.codespace = object.codespace ?? "";
    message.code = object.code ?? 0;
    message.data = object.data ?? new Uint8Array();
    message.rawLog = object.rawLog ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseGetFeePayerRequest(): GetFeePayerRequest {
  return {};
}

export const GetFeePayerRequest = {
  encode(_: GetFeePayerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFeePayerRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeePayerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetFeePayerRequest {
    return {};
  },

  toJSON(_: GetFeePayerRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetFeePayerRequest>): GetFeePayerRequest {
    return GetFeePayerRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<GetFeePayerRequest>): GetFeePayerRequest {
    const message = createBaseGetFeePayerRequest();
    return message;
  },
};

function createBaseGetFeePayerResponse(): GetFeePayerResponse {
  return { feePayer: "", feePayerPubKey: undefined };
}

export const GetFeePayerResponse = {
  encode(message: GetFeePayerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feePayer !== "") {
      writer.uint32(10).string(message.feePayer);
    }
    if (message.feePayerPubKey !== undefined) {
      CosmosPubKey.encode(message.feePayerPubKey, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFeePayerResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFeePayerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feePayer = reader.string();
          break;
        case 2:
          message.feePayerPubKey = CosmosPubKey.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFeePayerResponse {
    return {
      feePayer: isSet(object.feePayer) ? String(object.feePayer) : "",
      feePayerPubKey: isSet(object.feePayerPubKey) ? CosmosPubKey.fromJSON(object.feePayerPubKey) : undefined,
    };
  },

  toJSON(message: GetFeePayerResponse): unknown {
    const obj: any = {};
    message.feePayer !== undefined && (obj.feePayer = message.feePayer);
    message.feePayerPubKey !== undefined &&
      (obj.feePayerPubKey = message.feePayerPubKey ? CosmosPubKey.toJSON(message.feePayerPubKey) : undefined);
    return obj;
  },

  create(base?: DeepPartial<GetFeePayerResponse>): GetFeePayerResponse {
    return GetFeePayerResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<GetFeePayerResponse>): GetFeePayerResponse {
    const message = createBaseGetFeePayerResponse();
    message.feePayer = object.feePayer ?? "";
    message.feePayerPubKey = (object.feePayerPubKey !== undefined && object.feePayerPubKey !== null)
      ? CosmosPubKey.fromPartial(object.feePayerPubKey)
      : undefined;
    return message;
  },
};

/** InjectiveExchangeRPC defines gRPC API of an Injective Exchange service. */
export interface InjectiveExchangeRPC {
  /** GetTx gets transaction details by hash. */
  GetTx(request: DeepPartial<GetTxRequest>, metadata?: grpc.Metadata): Promise<GetTxResponse>;
  /** PrepareTx generates a Web3-signable body for a Cosmos transaction */
  PrepareTx(request: DeepPartial<PrepareTxRequest>, metadata?: grpc.Metadata): Promise<PrepareTxResponse>;
  /** BroadcastTx broadcasts a signed Web3 transaction */
  BroadcastTx(request: DeepPartial<BroadcastTxRequest>, metadata?: grpc.Metadata): Promise<BroadcastTxResponse>;
  /** PrepareCosmosTx generates a Web3-signable body for a Cosmos transaction */
  PrepareCosmosTx(
    request: DeepPartial<PrepareCosmosTxRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PrepareCosmosTxResponse>;
  /** BroadcastCosmosTx broadcasts a signed Web3 transaction */
  BroadcastCosmosTx(
    request: DeepPartial<BroadcastCosmosTxRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BroadcastCosmosTxResponse>;
  /** Return fee payer information's */
  GetFeePayer(request: DeepPartial<GetFeePayerRequest>, metadata?: grpc.Metadata): Promise<GetFeePayerResponse>;
}

export class InjectiveExchangeRPCClientImpl implements InjectiveExchangeRPC {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetTx = this.GetTx.bind(this);
    this.PrepareTx = this.PrepareTx.bind(this);
    this.BroadcastTx = this.BroadcastTx.bind(this);
    this.PrepareCosmosTx = this.PrepareCosmosTx.bind(this);
    this.BroadcastCosmosTx = this.BroadcastCosmosTx.bind(this);
    this.GetFeePayer = this.GetFeePayer.bind(this);
  }

  GetTx(request: DeepPartial<GetTxRequest>, metadata?: grpc.Metadata): Promise<GetTxResponse> {
    return this.rpc.unary(InjectiveExchangeRPCGetTxDesc, GetTxRequest.fromPartial(request), metadata);
  }

  PrepareTx(request: DeepPartial<PrepareTxRequest>, metadata?: grpc.Metadata): Promise<PrepareTxResponse> {
    return this.rpc.unary(InjectiveExchangeRPCPrepareTxDesc, PrepareTxRequest.fromPartial(request), metadata);
  }

  BroadcastTx(request: DeepPartial<BroadcastTxRequest>, metadata?: grpc.Metadata): Promise<BroadcastTxResponse> {
    return this.rpc.unary(InjectiveExchangeRPCBroadcastTxDesc, BroadcastTxRequest.fromPartial(request), metadata);
  }

  PrepareCosmosTx(
    request: DeepPartial<PrepareCosmosTxRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PrepareCosmosTxResponse> {
    return this.rpc.unary(
      InjectiveExchangeRPCPrepareCosmosTxDesc,
      PrepareCosmosTxRequest.fromPartial(request),
      metadata,
    );
  }

  BroadcastCosmosTx(
    request: DeepPartial<BroadcastCosmosTxRequest>,
    metadata?: grpc.Metadata,
  ): Promise<BroadcastCosmosTxResponse> {
    return this.rpc.unary(
      InjectiveExchangeRPCBroadcastCosmosTxDesc,
      BroadcastCosmosTxRequest.fromPartial(request),
      metadata,
    );
  }

  GetFeePayer(request: DeepPartial<GetFeePayerRequest>, metadata?: grpc.Metadata): Promise<GetFeePayerResponse> {
    return this.rpc.unary(InjectiveExchangeRPCGetFeePayerDesc, GetFeePayerRequest.fromPartial(request), metadata);
  }
}

export const InjectiveExchangeRPCDesc = { serviceName: "injective_exchange_rpc.InjectiveExchangeRPC" };

export const InjectiveExchangeRPCGetTxDesc: UnaryMethodDefinitionish = {
  methodName: "GetTx",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveExchangeRPCPrepareTxDesc: UnaryMethodDefinitionish = {
  methodName: "PrepareTx",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PrepareTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PrepareTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveExchangeRPCBroadcastTxDesc: UnaryMethodDefinitionish = {
  methodName: "BroadcastTx",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BroadcastTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BroadcastTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveExchangeRPCPrepareCosmosTxDesc: UnaryMethodDefinitionish = {
  methodName: "PrepareCosmosTx",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PrepareCosmosTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PrepareCosmosTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveExchangeRPCBroadcastCosmosTxDesc: UnaryMethodDefinitionish = {
  methodName: "BroadcastCosmosTx",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BroadcastCosmosTxRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = BroadcastCosmosTxResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const InjectiveExchangeRPCGetFeePayerDesc: UnaryMethodDefinitionish = {
  methodName: "GetFeePayer",
  service: InjectiveExchangeRPCDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetFeePayerRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetFeePayerResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
