/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { OracleType, oracleTypeFromJSON, oracleTypeToJSON } from "../../oracle/v1beta1/oracle";

export enum AtomicMarketOrderAccessLevel {
  Nobody = 0,
  /** BeginBlockerSmartContractsOnly - currently unsupported */
  BeginBlockerSmartContractsOnly = 1,
  SmartContractsOnly = 2,
  Everyone = 3,
  UNRECOGNIZED = -1,
}

export function atomicMarketOrderAccessLevelFromJSON(object: any): AtomicMarketOrderAccessLevel {
  switch (object) {
    case 0:
    case "Nobody":
      return AtomicMarketOrderAccessLevel.Nobody;
    case 1:
    case "BeginBlockerSmartContractsOnly":
      return AtomicMarketOrderAccessLevel.BeginBlockerSmartContractsOnly;
    case 2:
    case "SmartContractsOnly":
      return AtomicMarketOrderAccessLevel.SmartContractsOnly;
    case 3:
    case "Everyone":
      return AtomicMarketOrderAccessLevel.Everyone;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AtomicMarketOrderAccessLevel.UNRECOGNIZED;
  }
}

export function atomicMarketOrderAccessLevelToJSON(object: AtomicMarketOrderAccessLevel): string {
  switch (object) {
    case AtomicMarketOrderAccessLevel.Nobody:
      return "Nobody";
    case AtomicMarketOrderAccessLevel.BeginBlockerSmartContractsOnly:
      return "BeginBlockerSmartContractsOnly";
    case AtomicMarketOrderAccessLevel.SmartContractsOnly:
      return "SmartContractsOnly";
    case AtomicMarketOrderAccessLevel.Everyone:
      return "Everyone";
    case AtomicMarketOrderAccessLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MarketStatus {
  Unspecified = 0,
  Active = 1,
  Paused = 2,
  Demolished = 3,
  Expired = 4,
  UNRECOGNIZED = -1,
}

export function marketStatusFromJSON(object: any): MarketStatus {
  switch (object) {
    case 0:
    case "Unspecified":
      return MarketStatus.Unspecified;
    case 1:
    case "Active":
      return MarketStatus.Active;
    case 2:
    case "Paused":
      return MarketStatus.Paused;
    case 3:
    case "Demolished":
      return MarketStatus.Demolished;
    case 4:
    case "Expired":
      return MarketStatus.Expired;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarketStatus.UNRECOGNIZED;
  }
}

export function marketStatusToJSON(object: MarketStatus): string {
  switch (object) {
    case MarketStatus.Unspecified:
      return "Unspecified";
    case MarketStatus.Active:
      return "Active";
    case MarketStatus.Paused:
      return "Paused";
    case MarketStatus.Demolished:
      return "Demolished";
    case MarketStatus.Expired:
      return "Expired";
    case MarketStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderType {
  UNSPECIFIED = 0,
  BUY = 1,
  SELL = 2,
  STOP_BUY = 3,
  STOP_SELL = 4,
  TAKE_BUY = 5,
  TAKE_SELL = 6,
  BUY_PO = 7,
  SELL_PO = 8,
  BUY_ATOMIC = 9,
  SELL_ATOMIC = 10,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return OrderType.UNSPECIFIED;
    case 1:
    case "BUY":
      return OrderType.BUY;
    case 2:
    case "SELL":
      return OrderType.SELL;
    case 3:
    case "STOP_BUY":
      return OrderType.STOP_BUY;
    case 4:
    case "STOP_SELL":
      return OrderType.STOP_SELL;
    case 5:
    case "TAKE_BUY":
      return OrderType.TAKE_BUY;
    case 6:
    case "TAKE_SELL":
      return OrderType.TAKE_SELL;
    case 7:
    case "BUY_PO":
      return OrderType.BUY_PO;
    case 8:
    case "SELL_PO":
      return OrderType.SELL_PO;
    case 9:
    case "BUY_ATOMIC":
      return OrderType.BUY_ATOMIC;
    case 10:
    case "SELL_ATOMIC":
      return OrderType.SELL_ATOMIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.UNSPECIFIED:
      return "UNSPECIFIED";
    case OrderType.BUY:
      return "BUY";
    case OrderType.SELL:
      return "SELL";
    case OrderType.STOP_BUY:
      return "STOP_BUY";
    case OrderType.STOP_SELL:
      return "STOP_SELL";
    case OrderType.TAKE_BUY:
      return "TAKE_BUY";
    case OrderType.TAKE_SELL:
      return "TAKE_SELL";
    case OrderType.BUY_PO:
      return "BUY_PO";
    case OrderType.SELL_PO:
      return "SELL_PO";
    case OrderType.BUY_ATOMIC:
      return "BUY_ATOMIC";
    case OrderType.SELL_ATOMIC:
      return "SELL_ATOMIC";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExecutionType {
  UnspecifiedExecutionType = 0,
  Market = 1,
  LimitFill = 2,
  LimitMatchRestingOrder = 3,
  LimitMatchNewOrder = 4,
  MarketLiquidation = 5,
  ExpiryMarketSettlement = 6,
  UNRECOGNIZED = -1,
}

export function executionTypeFromJSON(object: any): ExecutionType {
  switch (object) {
    case 0:
    case "UnspecifiedExecutionType":
      return ExecutionType.UnspecifiedExecutionType;
    case 1:
    case "Market":
      return ExecutionType.Market;
    case 2:
    case "LimitFill":
      return ExecutionType.LimitFill;
    case 3:
    case "LimitMatchRestingOrder":
      return ExecutionType.LimitMatchRestingOrder;
    case 4:
    case "LimitMatchNewOrder":
      return ExecutionType.LimitMatchNewOrder;
    case 5:
    case "MarketLiquidation":
      return ExecutionType.MarketLiquidation;
    case 6:
    case "ExpiryMarketSettlement":
      return ExecutionType.ExpiryMarketSettlement;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionType.UNRECOGNIZED;
  }
}

export function executionTypeToJSON(object: ExecutionType): string {
  switch (object) {
    case ExecutionType.UnspecifiedExecutionType:
      return "UnspecifiedExecutionType";
    case ExecutionType.Market:
      return "Market";
    case ExecutionType.LimitFill:
      return "LimitFill";
    case ExecutionType.LimitMatchRestingOrder:
      return "LimitMatchRestingOrder";
    case ExecutionType.LimitMatchNewOrder:
      return "LimitMatchNewOrder";
    case ExecutionType.MarketLiquidation:
      return "MarketLiquidation";
    case ExecutionType.ExpiryMarketSettlement:
      return "ExpiryMarketSettlement";
    case ExecutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderMask {
  UNUSED = 0,
  ANY = 1,
  REGULAR = 2,
  CONDITIONAL = 4,
  /** DIRECTION_BUY_OR_HIGHER - for conditional orders means HIGHER */
  DIRECTION_BUY_OR_HIGHER = 8,
  /** DIRECTION_SELL_OR_LOWER - for conditional orders means LOWER */
  DIRECTION_SELL_OR_LOWER = 16,
  TYPE_MARKET = 32,
  TYPE_LIMIT = 64,
  UNRECOGNIZED = -1,
}

export function orderMaskFromJSON(object: any): OrderMask {
  switch (object) {
    case 0:
    case "UNUSED":
      return OrderMask.UNUSED;
    case 1:
    case "ANY":
      return OrderMask.ANY;
    case 2:
    case "REGULAR":
      return OrderMask.REGULAR;
    case 4:
    case "CONDITIONAL":
      return OrderMask.CONDITIONAL;
    case 8:
    case "DIRECTION_BUY_OR_HIGHER":
      return OrderMask.DIRECTION_BUY_OR_HIGHER;
    case 16:
    case "DIRECTION_SELL_OR_LOWER":
      return OrderMask.DIRECTION_SELL_OR_LOWER;
    case 32:
    case "TYPE_MARKET":
      return OrderMask.TYPE_MARKET;
    case 64:
    case "TYPE_LIMIT":
      return OrderMask.TYPE_LIMIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderMask.UNRECOGNIZED;
  }
}

export function orderMaskToJSON(object: OrderMask): string {
  switch (object) {
    case OrderMask.UNUSED:
      return "UNUSED";
    case OrderMask.ANY:
      return "ANY";
    case OrderMask.REGULAR:
      return "REGULAR";
    case OrderMask.CONDITIONAL:
      return "CONDITIONAL";
    case OrderMask.DIRECTION_BUY_OR_HIGHER:
      return "DIRECTION_BUY_OR_HIGHER";
    case OrderMask.DIRECTION_SELL_OR_LOWER:
      return "DIRECTION_SELL_OR_LOWER";
    case OrderMask.TYPE_MARKET:
      return "TYPE_MARKET";
    case OrderMask.TYPE_LIMIT:
      return "TYPE_LIMIT";
    case OrderMask.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Params {
  /** spot_market_instant_listing_fee defines the expedited fee in INJ required to create a spot market by bypassing governance */
  spotMarketInstantListingFee:
    | Coin
    | undefined;
  /** derivative_market_instant_listing_fee defines the expedited fee in INJ required to create a derivative market by bypassing governance */
  derivativeMarketInstantListingFee:
    | Coin
    | undefined;
  /** default_spot_maker_fee defines the default exchange trade fee for makers on a spot market */
  defaultSpotMakerFeeRate: string;
  /** default_spot_taker_fee_rate defines the default exchange trade fee rate for takers on a new spot market */
  defaultSpotTakerFeeRate: string;
  /** default_derivative_maker_fee defines the default exchange trade fee for makers on a new derivative market */
  defaultDerivativeMakerFeeRate: string;
  /** default_derivative_taker_fee defines the default exchange trade fee for takers on a new derivative market */
  defaultDerivativeTakerFeeRate: string;
  /** default_initial_margin_ratio defines the default initial margin ratio on a new derivative market */
  defaultInitialMarginRatio: string;
  /** default_maintenance_margin_ratio defines the default maintenance margin ratio on a new derivative market */
  defaultMaintenanceMarginRatio: string;
  /** default_funding_interval defines the default funding interval on a derivative market */
  defaultFundingInterval: string;
  /** funding_multiple defines the timestamp multiple that the funding timestamp should be a multiple of */
  fundingMultiple: string;
  /** relayer_fee_share_rate defines the trade fee share percentage that goes to relayers */
  relayerFeeShareRate: string;
  /** default_hourly_funding_rate_cap defines the default maximum absolute value of the hourly funding rate */
  defaultHourlyFundingRateCap: string;
  /** hourly_interest_rate defines the hourly interest rate */
  defaultHourlyInterestRate: string;
  /** max_derivative_order_side_count defines the maximum number of derivative active orders a subaccount can have for a given orderbook side */
  maxDerivativeOrderSideCount: number;
  /** inj_reward_staked_requirement_threshold defines the threshold on INJ rewards after which one also needs staked INJ to receive more */
  injRewardStakedRequirementThreshold: string;
  /** the trading_rewards_vesting_duration defines the vesting times for trading rewards */
  tradingRewardsVestingDuration: string;
  /** liquidator_reward_share_rate defines the ratio of the split of the surplus collateral that goes to the liquidator */
  liquidatorRewardShareRate: string;
  /** binary_options_market_instant_listing_fee defines the expedited fee in INJ required to create a derivative market by bypassing governance */
  binaryOptionsMarketInstantListingFee:
    | Coin
    | undefined;
  /** atomic_market_order_access_level defines the required access permissions for executing atomic market orders */
  atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevel;
  /** spot_atomic_market_order_fee_multiplier defines the default multiplier for executing atomic market orders in spot markets */
  spotAtomicMarketOrderFeeMultiplier: string;
  /** derivative_atomic_market_order_fee_multiplier defines the default multiplier for executing atomic market orders in derivative markets */
  derivativeAtomicMarketOrderFeeMultiplier: string;
  /** binary_options_atomic_market_order_fee_multiplier defines the default multiplier for executing atomic market orders in binary markets */
  binaryOptionsAtomicMarketOrderFeeMultiplier: string;
  /** minimal_protocol_fee_rate defines the minimal protocol fee rate */
  minimalProtocolFeeRate: string;
  /** is_instant_derivative_market_launch_enabled defines whether instant derivative market launch is enabled */
  isInstantDerivativeMarketLaunchEnabled: boolean;
}

export interface MarketFeeMultiplier {
  marketId: string;
  feeMultiplier: string;
}

/** An object describing a derivative market in the Injective Futures Protocol. */
export interface DerivativeMarket {
  /** Ticker for the derivative contract. */
  ticker: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Oracle type */
  oracleType: OracleType;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Address of the quote currency denomination for the derivative contract */
  quoteDenom: string;
  /** Unique market ID. */
  marketId: string;
  /** initial_margin_ratio defines the initial margin ratio of a derivative market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio of a derivative market */
  maintenanceMarginRatio: string;
  /** maker_fee_rate defines the maker fee rate of a derivative market */
  makerFeeRate: string;
  /** taker_fee_rate defines the taker fee rate of a derivative market */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the percentage of the transaction fee shared with the relayer in a derivative market */
  relayerFeeShareRate: string;
  /** true if the market is a perpetual market. false if the market is an expiry futures market */
  isPerpetual: boolean;
  /** Status of the market */
  status: MarketStatus;
  /** min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market */
  minQuantityTickSize: string;
}

/** An object describing a binary options market in Injective Protocol. */
export interface BinaryOptionsMarket {
  /** Ticker for the derivative contract. */
  ticker: string;
  /** Oracle symbol */
  oracleSymbol: string;
  /** Oracle Provider */
  oracleProvider: string;
  /** Oracle type */
  oracleType: OracleType;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** expiration timestamp */
  expirationTimestamp: string;
  /** expiration timestamp */
  settlementTimestamp: string;
  /** admin of the market */
  admin: string;
  /** Address of the quote currency denomination for the binary options contract */
  quoteDenom: string;
  /** Unique market ID. */
  marketId: string;
  /** maker_fee_rate defines the maker fee rate of a binary options market */
  makerFeeRate: string;
  /** taker_fee_rate defines the taker fee rate of a derivative market */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the percentage of the transaction fee shared with the relayer in a derivative market */
  relayerFeeShareRate: string;
  /** Status of the market */
  status: MarketStatus;
  /** min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market */
  minQuantityTickSize: string;
  settlementPrice: string;
}

export interface ExpiryFuturesMarketInfo {
  /** market ID. */
  marketId: string;
  /** expiration_timestamp defines the expiration time for a time expiry futures market. */
  expirationTimestamp: string;
  /** expiration_twap_start_timestamp defines the start time of the TWAP calculation window */
  twapStartTimestamp: string;
  /** expiration_twap_start_price_cumulative defines the cumulative price for the start of the TWAP window */
  expirationTwapStartPriceCumulative: string;
  /** settlement_price defines the settlement price for a time expiry futures market. */
  settlementPrice: string;
}

export interface PerpetualMarketInfo {
  /** market ID. */
  marketId: string;
  /** hourly_funding_rate_cap defines the maximum absolute value of the hourly funding rate */
  hourlyFundingRateCap: string;
  /** hourly_interest_rate defines the hourly interest rate */
  hourlyInterestRate: string;
  /** next_funding_timestamp defines the next funding timestamp in seconds of a perpetual market */
  nextFundingTimestamp: string;
  /** funding_interval defines the next funding interval in seconds of a perpetual market. */
  fundingInterval: string;
}

export interface PerpetualMarketFunding {
  /** cumulative_funding defines the cumulative funding of a perpetual market. */
  cumulativeFunding: string;
  /** cumulative_price defines the cumulative price for the current hour up to the last timestamp */
  cumulativePrice: string;
  lastTimestamp: string;
}

export interface DerivativeMarketSettlementInfo {
  /** market ID. */
  marketId: string;
  /** settlement_price defines the settlement price */
  settlementPrice: string;
}

export interface NextFundingTimestamp {
  nextTimestamp: string;
}

/** An object describing trade pair of two assets. */
export interface SpotMarket {
  /** A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote asset. */
  ticker: string;
  /** Coin denom used for the base asset */
  baseDenom: string;
  /** Coin used for the quote asset */
  quoteDenom: string;
  /** maker_fee_rate defines the fee percentage makers pay when trading */
  makerFeeRate: string;
  /** taker_fee_rate defines the fee percentage takers pay when trading */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the percentage of the transaction fee shared with the relayer in a derivative market */
  relayerFeeShareRate: string;
  /** Unique market ID. */
  marketId: string;
  /** Status of the market */
  status: MarketStatus;
  /** min_price_tick_size defines the minimum tick size that the price required for orders in the market */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market */
  minQuantityTickSize: string;
}

/** A subaccount's deposit for a given base currency */
export interface Deposit {
  availableBalance: string;
  totalBalance: string;
}

export interface SubaccountTradeNonce {
  nonce: number;
}

export interface OrderInfo {
  /** bytes32 subaccount ID that created the order */
  subaccountId: string;
  /** address fee_recipient address that will receive fees for the order */
  feeRecipient: string;
  /** price of the order */
  price: string;
  /** quantity of the order */
  quantity: string;
}

export interface SpotOrder {
  /** market_id represents the unique ID of the market */
  marketId: string;
  /** order_info contains the information of the order */
  orderInfo:
    | OrderInfo
    | undefined;
  /** order types */
  orderType: OrderType;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
}

/** A valid Spot limit order with Metadata. */
export interface SpotLimitOrder {
  /** order_info contains the information of the order */
  orderInfo:
    | OrderInfo
    | undefined;
  /** order types */
  orderType: OrderType;
  /** the amount of the quantity remaining fillable */
  fillable: string;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
  orderHash: Uint8Array;
}

/** A valid Spot market order with Metadata. */
export interface SpotMarketOrder {
  /** order_info contains the information of the order */
  orderInfo: OrderInfo | undefined;
  balanceHold: string;
  orderHash: Uint8Array;
  /** order types */
  orderType: OrderType;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
}

export interface DerivativeOrder {
  /** market_id represents the unique ID of the market */
  marketId: string;
  /** order_info contains the information of the order */
  orderInfo:
    | OrderInfo
    | undefined;
  /** order types */
  orderType: OrderType;
  /** margin is the margin used by the limit order */
  margin: string;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
}

export interface SubaccountOrderbookMetadata {
  vanillaLimitOrderCount: number;
  reduceOnlyLimitOrderCount: number;
  /** AggregateReduceOnlyQuantity is the aggregate fillable quantity of the subaccount's reduce-only limit orders in the given direction. */
  aggregateReduceOnlyQuantity: string;
  /** AggregateVanillaQuantity is the aggregate fillable quantity of the subaccount's vanilla limit orders in the given direction. */
  aggregateVanillaQuantity: string;
  vanillaConditionalOrderCount: number;
  reduceOnlyConditionalOrderCount: number;
}

export interface SubaccountOrder {
  /** price of the order */
  price: string;
  /** the amount of the quantity remaining fillable */
  quantity: string;
  isReduceOnly: boolean;
}

export interface SubaccountOrderData {
  order: SubaccountOrder | undefined;
  orderHash: Uint8Array;
}

/** A valid Derivative limit order with Metadata. */
export interface DerivativeLimitOrder {
  /** order_info contains the information of the order */
  orderInfo:
    | OrderInfo
    | undefined;
  /** order types */
  orderType: OrderType;
  /** margin is the margin used by the limit order */
  margin: string;
  /** the amount of the quantity remaining fillable */
  fillable: string;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
  orderHash: Uint8Array;
}

/** A valid Derivative market order with Metadata. */
export interface DerivativeMarketOrder {
  /** order_info contains the information of the order */
  orderInfo:
    | OrderInfo
    | undefined;
  /** order types */
  orderType: OrderType;
  margin: string;
  marginHold: string;
  /** trigger_price is the trigger price used by stop/take orders */
  triggerPrice: string;
  orderHash: Uint8Array;
}

export interface Position {
  isLong: boolean;
  quantity: string;
  entryPrice: string;
  margin: string;
  cumulativeFundingEntry: string;
}

export interface MarketOrderIndicator {
  /** market_id represents the unique ID of the market */
  marketId: string;
  isBuy: boolean;
}

export interface TradeLog {
  quantity: string;
  price: string;
  /** bytes32 subaccount ID that executed the trade */
  subaccountId: Uint8Array;
  fee: string;
  orderHash: Uint8Array;
  feeRecipientAddress: Uint8Array;
}

export interface PositionDelta {
  isLong: boolean;
  executionQuantity: string;
  executionMargin: string;
  executionPrice: string;
}

export interface DerivativeTradeLog {
  subaccountId: Uint8Array;
  positionDelta: PositionDelta | undefined;
  payout: string;
  fee: string;
  orderHash: Uint8Array;
  feeRecipientAddress: Uint8Array;
}

export interface SubaccountPosition {
  position: Position | undefined;
  subaccountId: Uint8Array;
}

export interface SubaccountDeposit {
  subaccountId: Uint8Array;
  deposit: Deposit | undefined;
}

export interface DepositUpdate {
  denom: string;
  deposits: SubaccountDeposit[];
}

export interface PointsMultiplier {
  makerPointsMultiplier: string;
  takerPointsMultiplier: string;
}

export interface TradingRewardCampaignBoostInfo {
  boostedSpotMarketIds: string[];
  spotMarketMultipliers: PointsMultiplier[];
  boostedDerivativeMarketIds: string[];
  derivativeMarketMultipliers: PointsMultiplier[];
}

export interface CampaignRewardPool {
  startTimestamp: string;
  /** max_campaign_rewards are the maximum reward amounts to be disbursed at the end of the campaign */
  maxCampaignRewards: Coin[];
}

export interface TradingRewardCampaignInfo {
  /** number of seconds of the duration of each campaign */
  campaignDurationSeconds: string;
  /** the trading fee quote denoms which will be counted for the rewards */
  quoteDenoms: string[];
  /** the optional boost info for markets */
  tradingRewardBoostInfo:
    | TradingRewardCampaignBoostInfo
    | undefined;
  /** the marketIDs which are disqualified from being rewarded */
  disqualifiedMarketIds: string[];
}

export interface FeeDiscountTierInfo {
  makerDiscountRate: string;
  takerDiscountRate: string;
  stakedAmount: string;
  volume: string;
}

export interface FeeDiscountSchedule {
  bucketCount: string;
  bucketDuration: string;
  /** the trading fee quote denoms which will be counted for the fee paid contribution */
  quoteDenoms: string[];
  /** the fee discount tiers */
  tierInfos: FeeDiscountTierInfo[];
  /** the marketIDs which are disqualified from contributing to the fee paid amount */
  disqualifiedMarketIds: string[];
}

export interface FeeDiscountTierTTL {
  tier: string;
  ttlTimestamp: string;
}

export interface VolumeRecord {
  makerVolume: string;
  takerVolume: string;
}

export interface AccountRewards {
  account: string;
  rewards: Coin[];
}

export interface TradeRecords {
  marketId: string;
  latestTradeRecords: TradeRecord[];
}

export interface SubaccountIDs {
  subaccountIds: Uint8Array[];
}

export interface TradeRecord {
  timestamp: string;
  price: string;
  quantity: string;
}

export interface Level {
  /** price */
  p: string;
  /** quantity */
  q: string;
}

export interface AggregateSubaccountVolumeRecord {
  subaccountId: string;
  marketVolumes: MarketVolume[];
}

export interface AggregateAccountVolumeRecord {
  account: string;
  marketVolumes: MarketVolume[];
}

export interface MarketVolume {
  marketId: string;
  volume: VolumeRecord | undefined;
}

export interface DenomDecimals {
  denom: string;
  decimals: string;
}

function createBaseParams(): Params {
  return {
    spotMarketInstantListingFee: undefined,
    derivativeMarketInstantListingFee: undefined,
    defaultSpotMakerFeeRate: "",
    defaultSpotTakerFeeRate: "",
    defaultDerivativeMakerFeeRate: "",
    defaultDerivativeTakerFeeRate: "",
    defaultInitialMarginRatio: "",
    defaultMaintenanceMarginRatio: "",
    defaultFundingInterval: "0",
    fundingMultiple: "0",
    relayerFeeShareRate: "",
    defaultHourlyFundingRateCap: "",
    defaultHourlyInterestRate: "",
    maxDerivativeOrderSideCount: 0,
    injRewardStakedRequirementThreshold: "",
    tradingRewardsVestingDuration: "0",
    liquidatorRewardShareRate: "",
    binaryOptionsMarketInstantListingFee: undefined,
    atomicMarketOrderAccessLevel: 0,
    spotAtomicMarketOrderFeeMultiplier: "",
    derivativeAtomicMarketOrderFeeMultiplier: "",
    binaryOptionsAtomicMarketOrderFeeMultiplier: "",
    minimalProtocolFeeRate: "",
    isInstantDerivativeMarketLaunchEnabled: false,
  };
}

export const Params = {
  encode(message: Params, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spotMarketInstantListingFee !== undefined) {
      Coin.encode(message.spotMarketInstantListingFee, writer.uint32(10).fork()).ldelim();
    }
    if (message.derivativeMarketInstantListingFee !== undefined) {
      Coin.encode(message.derivativeMarketInstantListingFee, writer.uint32(18).fork()).ldelim();
    }
    if (message.defaultSpotMakerFeeRate !== "") {
      writer.uint32(26).string(message.defaultSpotMakerFeeRate);
    }
    if (message.defaultSpotTakerFeeRate !== "") {
      writer.uint32(34).string(message.defaultSpotTakerFeeRate);
    }
    if (message.defaultDerivativeMakerFeeRate !== "") {
      writer.uint32(42).string(message.defaultDerivativeMakerFeeRate);
    }
    if (message.defaultDerivativeTakerFeeRate !== "") {
      writer.uint32(50).string(message.defaultDerivativeTakerFeeRate);
    }
    if (message.defaultInitialMarginRatio !== "") {
      writer.uint32(58).string(message.defaultInitialMarginRatio);
    }
    if (message.defaultMaintenanceMarginRatio !== "") {
      writer.uint32(66).string(message.defaultMaintenanceMarginRatio);
    }
    if (message.defaultFundingInterval !== "0") {
      writer.uint32(72).int64(message.defaultFundingInterval);
    }
    if (message.fundingMultiple !== "0") {
      writer.uint32(80).int64(message.fundingMultiple);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(90).string(message.relayerFeeShareRate);
    }
    if (message.defaultHourlyFundingRateCap !== "") {
      writer.uint32(98).string(message.defaultHourlyFundingRateCap);
    }
    if (message.defaultHourlyInterestRate !== "") {
      writer.uint32(106).string(message.defaultHourlyInterestRate);
    }
    if (message.maxDerivativeOrderSideCount !== 0) {
      writer.uint32(112).uint32(message.maxDerivativeOrderSideCount);
    }
    if (message.injRewardStakedRequirementThreshold !== "") {
      writer.uint32(122).string(message.injRewardStakedRequirementThreshold);
    }
    if (message.tradingRewardsVestingDuration !== "0") {
      writer.uint32(128).int64(message.tradingRewardsVestingDuration);
    }
    if (message.liquidatorRewardShareRate !== "") {
      writer.uint32(138).string(message.liquidatorRewardShareRate);
    }
    if (message.binaryOptionsMarketInstantListingFee !== undefined) {
      Coin.encode(message.binaryOptionsMarketInstantListingFee, writer.uint32(146).fork()).ldelim();
    }
    if (message.atomicMarketOrderAccessLevel !== 0) {
      writer.uint32(152).int32(message.atomicMarketOrderAccessLevel);
    }
    if (message.spotAtomicMarketOrderFeeMultiplier !== "") {
      writer.uint32(162).string(message.spotAtomicMarketOrderFeeMultiplier);
    }
    if (message.derivativeAtomicMarketOrderFeeMultiplier !== "") {
      writer.uint32(170).string(message.derivativeAtomicMarketOrderFeeMultiplier);
    }
    if (message.binaryOptionsAtomicMarketOrderFeeMultiplier !== "") {
      writer.uint32(178).string(message.binaryOptionsAtomicMarketOrderFeeMultiplier);
    }
    if (message.minimalProtocolFeeRate !== "") {
      writer.uint32(186).string(message.minimalProtocolFeeRate);
    }
    if (message.isInstantDerivativeMarketLaunchEnabled === true) {
      writer.uint32(192).bool(message.isInstantDerivativeMarketLaunchEnabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Params {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spotMarketInstantListingFee = Coin.decode(reader, reader.uint32());
          break;
        case 2:
          message.derivativeMarketInstantListingFee = Coin.decode(reader, reader.uint32());
          break;
        case 3:
          message.defaultSpotMakerFeeRate = reader.string();
          break;
        case 4:
          message.defaultSpotTakerFeeRate = reader.string();
          break;
        case 5:
          message.defaultDerivativeMakerFeeRate = reader.string();
          break;
        case 6:
          message.defaultDerivativeTakerFeeRate = reader.string();
          break;
        case 7:
          message.defaultInitialMarginRatio = reader.string();
          break;
        case 8:
          message.defaultMaintenanceMarginRatio = reader.string();
          break;
        case 9:
          message.defaultFundingInterval = longToString(reader.int64() as Long);
          break;
        case 10:
          message.fundingMultiple = longToString(reader.int64() as Long);
          break;
        case 11:
          message.relayerFeeShareRate = reader.string();
          break;
        case 12:
          message.defaultHourlyFundingRateCap = reader.string();
          break;
        case 13:
          message.defaultHourlyInterestRate = reader.string();
          break;
        case 14:
          message.maxDerivativeOrderSideCount = reader.uint32();
          break;
        case 15:
          message.injRewardStakedRequirementThreshold = reader.string();
          break;
        case 16:
          message.tradingRewardsVestingDuration = longToString(reader.int64() as Long);
          break;
        case 17:
          message.liquidatorRewardShareRate = reader.string();
          break;
        case 18:
          message.binaryOptionsMarketInstantListingFee = Coin.decode(reader, reader.uint32());
          break;
        case 19:
          message.atomicMarketOrderAccessLevel = reader.int32() as any;
          break;
        case 20:
          message.spotAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case 21:
          message.derivativeAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case 22:
          message.binaryOptionsAtomicMarketOrderFeeMultiplier = reader.string();
          break;
        case 23:
          message.minimalProtocolFeeRate = reader.string();
          break;
        case 24:
          message.isInstantDerivativeMarketLaunchEnabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      spotMarketInstantListingFee: isSet(object.spotMarketInstantListingFee)
        ? Coin.fromJSON(object.spotMarketInstantListingFee)
        : undefined,
      derivativeMarketInstantListingFee: isSet(object.derivativeMarketInstantListingFee)
        ? Coin.fromJSON(object.derivativeMarketInstantListingFee)
        : undefined,
      defaultSpotMakerFeeRate: isSet(object.defaultSpotMakerFeeRate) ? String(object.defaultSpotMakerFeeRate) : "",
      defaultSpotTakerFeeRate: isSet(object.defaultSpotTakerFeeRate) ? String(object.defaultSpotTakerFeeRate) : "",
      defaultDerivativeMakerFeeRate: isSet(object.defaultDerivativeMakerFeeRate)
        ? String(object.defaultDerivativeMakerFeeRate)
        : "",
      defaultDerivativeTakerFeeRate: isSet(object.defaultDerivativeTakerFeeRate)
        ? String(object.defaultDerivativeTakerFeeRate)
        : "",
      defaultInitialMarginRatio: isSet(object.defaultInitialMarginRatio)
        ? String(object.defaultInitialMarginRatio)
        : "",
      defaultMaintenanceMarginRatio: isSet(object.defaultMaintenanceMarginRatio)
        ? String(object.defaultMaintenanceMarginRatio)
        : "",
      defaultFundingInterval: isSet(object.defaultFundingInterval) ? String(object.defaultFundingInterval) : "0",
      fundingMultiple: isSet(object.fundingMultiple) ? String(object.fundingMultiple) : "0",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      defaultHourlyFundingRateCap: isSet(object.defaultHourlyFundingRateCap)
        ? String(object.defaultHourlyFundingRateCap)
        : "",
      defaultHourlyInterestRate: isSet(object.defaultHourlyInterestRate)
        ? String(object.defaultHourlyInterestRate)
        : "",
      maxDerivativeOrderSideCount: isSet(object.maxDerivativeOrderSideCount)
        ? Number(object.maxDerivativeOrderSideCount)
        : 0,
      injRewardStakedRequirementThreshold: isSet(object.injRewardStakedRequirementThreshold)
        ? String(object.injRewardStakedRequirementThreshold)
        : "",
      tradingRewardsVestingDuration: isSet(object.tradingRewardsVestingDuration)
        ? String(object.tradingRewardsVestingDuration)
        : "0",
      liquidatorRewardShareRate: isSet(object.liquidatorRewardShareRate)
        ? String(object.liquidatorRewardShareRate)
        : "",
      binaryOptionsMarketInstantListingFee: isSet(object.binaryOptionsMarketInstantListingFee)
        ? Coin.fromJSON(object.binaryOptionsMarketInstantListingFee)
        : undefined,
      atomicMarketOrderAccessLevel: isSet(object.atomicMarketOrderAccessLevel)
        ? atomicMarketOrderAccessLevelFromJSON(object.atomicMarketOrderAccessLevel)
        : 0,
      spotAtomicMarketOrderFeeMultiplier: isSet(object.spotAtomicMarketOrderFeeMultiplier)
        ? String(object.spotAtomicMarketOrderFeeMultiplier)
        : "",
      derivativeAtomicMarketOrderFeeMultiplier: isSet(object.derivativeAtomicMarketOrderFeeMultiplier)
        ? String(object.derivativeAtomicMarketOrderFeeMultiplier)
        : "",
      binaryOptionsAtomicMarketOrderFeeMultiplier: isSet(object.binaryOptionsAtomicMarketOrderFeeMultiplier)
        ? String(object.binaryOptionsAtomicMarketOrderFeeMultiplier)
        : "",
      minimalProtocolFeeRate: isSet(object.minimalProtocolFeeRate) ? String(object.minimalProtocolFeeRate) : "",
      isInstantDerivativeMarketLaunchEnabled: isSet(object.isInstantDerivativeMarketLaunchEnabled)
        ? Boolean(object.isInstantDerivativeMarketLaunchEnabled)
        : false,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    message.spotMarketInstantListingFee !== undefined &&
      (obj.spotMarketInstantListingFee = message.spotMarketInstantListingFee
        ? Coin.toJSON(message.spotMarketInstantListingFee)
        : undefined);
    message.derivativeMarketInstantListingFee !== undefined &&
      (obj.derivativeMarketInstantListingFee = message.derivativeMarketInstantListingFee
        ? Coin.toJSON(message.derivativeMarketInstantListingFee)
        : undefined);
    message.defaultSpotMakerFeeRate !== undefined && (obj.defaultSpotMakerFeeRate = message.defaultSpotMakerFeeRate);
    message.defaultSpotTakerFeeRate !== undefined && (obj.defaultSpotTakerFeeRate = message.defaultSpotTakerFeeRate);
    message.defaultDerivativeMakerFeeRate !== undefined &&
      (obj.defaultDerivativeMakerFeeRate = message.defaultDerivativeMakerFeeRate);
    message.defaultDerivativeTakerFeeRate !== undefined &&
      (obj.defaultDerivativeTakerFeeRate = message.defaultDerivativeTakerFeeRate);
    message.defaultInitialMarginRatio !== undefined &&
      (obj.defaultInitialMarginRatio = message.defaultInitialMarginRatio);
    message.defaultMaintenanceMarginRatio !== undefined &&
      (obj.defaultMaintenanceMarginRatio = message.defaultMaintenanceMarginRatio);
    message.defaultFundingInterval !== undefined && (obj.defaultFundingInterval = message.defaultFundingInterval);
    message.fundingMultiple !== undefined && (obj.fundingMultiple = message.fundingMultiple);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.defaultHourlyFundingRateCap !== undefined &&
      (obj.defaultHourlyFundingRateCap = message.defaultHourlyFundingRateCap);
    message.defaultHourlyInterestRate !== undefined &&
      (obj.defaultHourlyInterestRate = message.defaultHourlyInterestRate);
    message.maxDerivativeOrderSideCount !== undefined &&
      (obj.maxDerivativeOrderSideCount = Math.round(message.maxDerivativeOrderSideCount));
    message.injRewardStakedRequirementThreshold !== undefined &&
      (obj.injRewardStakedRequirementThreshold = message.injRewardStakedRequirementThreshold);
    message.tradingRewardsVestingDuration !== undefined &&
      (obj.tradingRewardsVestingDuration = message.tradingRewardsVestingDuration);
    message.liquidatorRewardShareRate !== undefined &&
      (obj.liquidatorRewardShareRate = message.liquidatorRewardShareRate);
    message.binaryOptionsMarketInstantListingFee !== undefined &&
      (obj.binaryOptionsMarketInstantListingFee = message.binaryOptionsMarketInstantListingFee
        ? Coin.toJSON(message.binaryOptionsMarketInstantListingFee)
        : undefined);
    message.atomicMarketOrderAccessLevel !== undefined &&
      (obj.atomicMarketOrderAccessLevel = atomicMarketOrderAccessLevelToJSON(message.atomicMarketOrderAccessLevel));
    message.spotAtomicMarketOrderFeeMultiplier !== undefined &&
      (obj.spotAtomicMarketOrderFeeMultiplier = message.spotAtomicMarketOrderFeeMultiplier);
    message.derivativeAtomicMarketOrderFeeMultiplier !== undefined &&
      (obj.derivativeAtomicMarketOrderFeeMultiplier = message.derivativeAtomicMarketOrderFeeMultiplier);
    message.binaryOptionsAtomicMarketOrderFeeMultiplier !== undefined &&
      (obj.binaryOptionsAtomicMarketOrderFeeMultiplier = message.binaryOptionsAtomicMarketOrderFeeMultiplier);
    message.minimalProtocolFeeRate !== undefined && (obj.minimalProtocolFeeRate = message.minimalProtocolFeeRate);
    message.isInstantDerivativeMarketLaunchEnabled !== undefined &&
      (obj.isInstantDerivativeMarketLaunchEnabled = message.isInstantDerivativeMarketLaunchEnabled);
    return obj;
  },

  create(base?: DeepPartial<Params>): Params {
    return Params.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.spotMarketInstantListingFee =
      (object.spotMarketInstantListingFee !== undefined && object.spotMarketInstantListingFee !== null)
        ? Coin.fromPartial(object.spotMarketInstantListingFee)
        : undefined;
    message.derivativeMarketInstantListingFee =
      (object.derivativeMarketInstantListingFee !== undefined && object.derivativeMarketInstantListingFee !== null)
        ? Coin.fromPartial(object.derivativeMarketInstantListingFee)
        : undefined;
    message.defaultSpotMakerFeeRate = object.defaultSpotMakerFeeRate ?? "";
    message.defaultSpotTakerFeeRate = object.defaultSpotTakerFeeRate ?? "";
    message.defaultDerivativeMakerFeeRate = object.defaultDerivativeMakerFeeRate ?? "";
    message.defaultDerivativeTakerFeeRate = object.defaultDerivativeTakerFeeRate ?? "";
    message.defaultInitialMarginRatio = object.defaultInitialMarginRatio ?? "";
    message.defaultMaintenanceMarginRatio = object.defaultMaintenanceMarginRatio ?? "";
    message.defaultFundingInterval = object.defaultFundingInterval ?? "0";
    message.fundingMultiple = object.fundingMultiple ?? "0";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.defaultHourlyFundingRateCap = object.defaultHourlyFundingRateCap ?? "";
    message.defaultHourlyInterestRate = object.defaultHourlyInterestRate ?? "";
    message.maxDerivativeOrderSideCount = object.maxDerivativeOrderSideCount ?? 0;
    message.injRewardStakedRequirementThreshold = object.injRewardStakedRequirementThreshold ?? "";
    message.tradingRewardsVestingDuration = object.tradingRewardsVestingDuration ?? "0";
    message.liquidatorRewardShareRate = object.liquidatorRewardShareRate ?? "";
    message.binaryOptionsMarketInstantListingFee =
      (object.binaryOptionsMarketInstantListingFee !== undefined &&
          object.binaryOptionsMarketInstantListingFee !== null)
        ? Coin.fromPartial(object.binaryOptionsMarketInstantListingFee)
        : undefined;
    message.atomicMarketOrderAccessLevel = object.atomicMarketOrderAccessLevel ?? 0;
    message.spotAtomicMarketOrderFeeMultiplier = object.spotAtomicMarketOrderFeeMultiplier ?? "";
    message.derivativeAtomicMarketOrderFeeMultiplier = object.derivativeAtomicMarketOrderFeeMultiplier ?? "";
    message.binaryOptionsAtomicMarketOrderFeeMultiplier = object.binaryOptionsAtomicMarketOrderFeeMultiplier ?? "";
    message.minimalProtocolFeeRate = object.minimalProtocolFeeRate ?? "";
    message.isInstantDerivativeMarketLaunchEnabled = object.isInstantDerivativeMarketLaunchEnabled ?? false;
    return message;
  },
};

function createBaseMarketFeeMultiplier(): MarketFeeMultiplier {
  return { marketId: "", feeMultiplier: "" };
}

export const MarketFeeMultiplier = {
  encode(message: MarketFeeMultiplier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.feeMultiplier !== "") {
      writer.uint32(18).string(message.feeMultiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketFeeMultiplier {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketFeeMultiplier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.feeMultiplier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketFeeMultiplier {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      feeMultiplier: isSet(object.feeMultiplier) ? String(object.feeMultiplier) : "",
    };
  },

  toJSON(message: MarketFeeMultiplier): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.feeMultiplier !== undefined && (obj.feeMultiplier = message.feeMultiplier);
    return obj;
  },

  create(base?: DeepPartial<MarketFeeMultiplier>): MarketFeeMultiplier {
    return MarketFeeMultiplier.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketFeeMultiplier>): MarketFeeMultiplier {
    const message = createBaseMarketFeeMultiplier();
    message.marketId = object.marketId ?? "";
    message.feeMultiplier = object.feeMultiplier ?? "";
    return message;
  },
};

function createBaseDerivativeMarket(): DerivativeMarket {
  return {
    ticker: "",
    oracleBase: "",
    oracleQuote: "",
    oracleType: 0,
    oracleScaleFactor: 0,
    quoteDenom: "",
    marketId: "",
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    isPerpetual: false,
    status: 0,
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const DerivativeMarket = {
  encode(message: DerivativeMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticker !== "") {
      writer.uint32(10).string(message.ticker);
    }
    if (message.oracleBase !== "") {
      writer.uint32(18).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(26).string(message.oracleQuote);
    }
    if (message.oracleType !== 0) {
      writer.uint32(32).int32(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(40).uint32(message.oracleScaleFactor);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(50).string(message.quoteDenom);
    }
    if (message.marketId !== "") {
      writer.uint32(58).string(message.marketId);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(66).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(74).string(message.maintenanceMarginRatio);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(82).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(90).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(98).string(message.relayerFeeShareRate);
    }
    if (message.isPerpetual === true) {
      writer.uint32(104).bool(message.isPerpetual);
    }
    if (message.status !== 0) {
      writer.uint32(112).int32(message.status);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(122).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(130).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ticker = reader.string();
          break;
        case 2:
          message.oracleBase = reader.string();
          break;
        case 3:
          message.oracleQuote = reader.string();
          break;
        case 4:
          message.oracleType = reader.int32() as any;
          break;
        case 5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 6:
          message.quoteDenom = reader.string();
          break;
        case 7:
          message.marketId = reader.string();
          break;
        case 8:
          message.initialMarginRatio = reader.string();
          break;
        case 9:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 10:
          message.makerFeeRate = reader.string();
          break;
        case 11:
          message.takerFeeRate = reader.string();
          break;
        case 12:
          message.relayerFeeShareRate = reader.string();
          break;
        case 13:
          message.isPerpetual = reader.bool();
          break;
        case 14:
          message.status = reader.int32() as any;
          break;
        case 15:
          message.minPriceTickSize = reader.string();
          break;
        case 16:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarket {
    return {
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      isPerpetual: isSet(object.isPerpetual) ? Boolean(object.isPerpetual) : false,
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: DerivativeMarket): unknown {
    const obj: any = {};
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.isPerpetual !== undefined && (obj.isPerpetual = message.isPerpetual);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarket>): DerivativeMarket {
    return DerivativeMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarket>): DerivativeMarket {
    const message = createBaseDerivativeMarket();
    message.ticker = object.ticker ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.quoteDenom = object.quoteDenom ?? "";
    message.marketId = object.marketId ?? "";
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.isPerpetual = object.isPerpetual ?? false;
    message.status = object.status ?? 0;
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseBinaryOptionsMarket(): BinaryOptionsMarket {
  return {
    ticker: "",
    oracleSymbol: "",
    oracleProvider: "",
    oracleType: 0,
    oracleScaleFactor: 0,
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    admin: "",
    quoteDenom: "",
    marketId: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    status: 0,
    minPriceTickSize: "",
    minQuantityTickSize: "",
    settlementPrice: "",
  };
}

export const BinaryOptionsMarket = {
  encode(message: BinaryOptionsMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticker !== "") {
      writer.uint32(10).string(message.ticker);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(18).string(message.oracleSymbol);
    }
    if (message.oracleProvider !== "") {
      writer.uint32(26).string(message.oracleProvider);
    }
    if (message.oracleType !== 0) {
      writer.uint32(32).int32(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(40).uint32(message.oracleScaleFactor);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(48).int64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(56).int64(message.settlementTimestamp);
    }
    if (message.admin !== "") {
      writer.uint32(66).string(message.admin);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(74).string(message.quoteDenom);
    }
    if (message.marketId !== "") {
      writer.uint32(82).string(message.marketId);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(90).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(98).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(106).string(message.relayerFeeShareRate);
    }
    if (message.status !== 0) {
      writer.uint32(112).int32(message.status);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(122).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(130).string(message.minQuantityTickSize);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(138).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ticker = reader.string();
          break;
        case 2:
          message.oracleSymbol = reader.string();
          break;
        case 3:
          message.oracleProvider = reader.string();
          break;
        case 4:
          message.oracleType = reader.int32() as any;
          break;
        case 5:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 6:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 7:
          message.settlementTimestamp = longToString(reader.int64() as Long);
          break;
        case 8:
          message.admin = reader.string();
          break;
        case 9:
          message.quoteDenom = reader.string();
          break;
        case 10:
          message.marketId = reader.string();
          break;
        case 11:
          message.makerFeeRate = reader.string();
          break;
        case 12:
          message.takerFeeRate = reader.string();
          break;
        case 13:
          message.relayerFeeShareRate = reader.string();
          break;
        case 14:
          message.status = reader.int32() as any;
          break;
        case 15:
          message.minPriceTickSize = reader.string();
          break;
        case 16:
          message.minQuantityTickSize = reader.string();
          break;
        case 17:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarket {
    return {
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? String(object.oracleSymbol) : "",
      oracleProvider: isSet(object.oracleProvider) ? String(object.oracleProvider) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      admin: isSet(object.admin) ? String(object.admin) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: BinaryOptionsMarket): unknown {
    const obj: any = {};
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleSymbol !== undefined && (obj.oracleSymbol = message.oracleSymbol);
    message.oracleProvider !== undefined && (obj.oracleProvider = message.oracleProvider);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.admin !== undefined && (obj.admin = message.admin);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarket>): BinaryOptionsMarket {
    return BinaryOptionsMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarket>): BinaryOptionsMarket {
    const message = createBaseBinaryOptionsMarket();
    message.ticker = object.ticker ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.oracleProvider = object.oracleProvider ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.admin = object.admin ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.marketId = object.marketId ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.status = object.status ?? 0;
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBaseExpiryFuturesMarketInfo(): ExpiryFuturesMarketInfo {
  return {
    marketId: "",
    expirationTimestamp: "0",
    twapStartTimestamp: "0",
    expirationTwapStartPriceCumulative: "",
    settlementPrice: "",
  };
}

export const ExpiryFuturesMarketInfo = {
  encode(message: ExpiryFuturesMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(16).int64(message.expirationTimestamp);
    }
    if (message.twapStartTimestamp !== "0") {
      writer.uint32(24).int64(message.twapStartTimestamp);
    }
    if (message.expirationTwapStartPriceCumulative !== "") {
      writer.uint32(34).string(message.expirationTwapStartPriceCumulative);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(42).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpiryFuturesMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpiryFuturesMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 3:
          message.twapStartTimestamp = longToString(reader.int64() as Long);
          break;
        case 4:
          message.expirationTwapStartPriceCumulative = reader.string();
          break;
        case 5:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpiryFuturesMarketInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      twapStartTimestamp: isSet(object.twapStartTimestamp) ? String(object.twapStartTimestamp) : "0",
      expirationTwapStartPriceCumulative: isSet(object.expirationTwapStartPriceCumulative)
        ? String(object.expirationTwapStartPriceCumulative)
        : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: ExpiryFuturesMarketInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.twapStartTimestamp !== undefined && (obj.twapStartTimestamp = message.twapStartTimestamp);
    message.expirationTwapStartPriceCumulative !== undefined &&
      (obj.expirationTwapStartPriceCumulative = message.expirationTwapStartPriceCumulative);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
    return ExpiryFuturesMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ExpiryFuturesMarketInfo>): ExpiryFuturesMarketInfo {
    const message = createBaseExpiryFuturesMarketInfo();
    message.marketId = object.marketId ?? "";
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.twapStartTimestamp = object.twapStartTimestamp ?? "0";
    message.expirationTwapStartPriceCumulative = object.expirationTwapStartPriceCumulative ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBasePerpetualMarketInfo(): PerpetualMarketInfo {
  return {
    marketId: "",
    hourlyFundingRateCap: "",
    hourlyInterestRate: "",
    nextFundingTimestamp: "0",
    fundingInterval: "0",
  };
}

export const PerpetualMarketInfo = {
  encode(message: PerpetualMarketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.hourlyFundingRateCap !== "") {
      writer.uint32(18).string(message.hourlyFundingRateCap);
    }
    if (message.hourlyInterestRate !== "") {
      writer.uint32(26).string(message.hourlyInterestRate);
    }
    if (message.nextFundingTimestamp !== "0") {
      writer.uint32(32).int64(message.nextFundingTimestamp);
    }
    if (message.fundingInterval !== "0") {
      writer.uint32(40).int64(message.fundingInterval);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.hourlyFundingRateCap = reader.string();
          break;
        case 3:
          message.hourlyInterestRate = reader.string();
          break;
        case 4:
          message.nextFundingTimestamp = longToString(reader.int64() as Long);
          break;
        case 5:
          message.fundingInterval = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      hourlyFundingRateCap: isSet(object.hourlyFundingRateCap) ? String(object.hourlyFundingRateCap) : "",
      hourlyInterestRate: isSet(object.hourlyInterestRate) ? String(object.hourlyInterestRate) : "",
      nextFundingTimestamp: isSet(object.nextFundingTimestamp) ? String(object.nextFundingTimestamp) : "0",
      fundingInterval: isSet(object.fundingInterval) ? String(object.fundingInterval) : "0",
    };
  },

  toJSON(message: PerpetualMarketInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.hourlyFundingRateCap !== undefined && (obj.hourlyFundingRateCap = message.hourlyFundingRateCap);
    message.hourlyInterestRate !== undefined && (obj.hourlyInterestRate = message.hourlyInterestRate);
    message.nextFundingTimestamp !== undefined && (obj.nextFundingTimestamp = message.nextFundingTimestamp);
    message.fundingInterval !== undefined && (obj.fundingInterval = message.fundingInterval);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo {
    return PerpetualMarketInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketInfo>): PerpetualMarketInfo {
    const message = createBasePerpetualMarketInfo();
    message.marketId = object.marketId ?? "";
    message.hourlyFundingRateCap = object.hourlyFundingRateCap ?? "";
    message.hourlyInterestRate = object.hourlyInterestRate ?? "";
    message.nextFundingTimestamp = object.nextFundingTimestamp ?? "0";
    message.fundingInterval = object.fundingInterval ?? "0";
    return message;
  },
};

function createBasePerpetualMarketFunding(): PerpetualMarketFunding {
  return { cumulativeFunding: "", cumulativePrice: "", lastTimestamp: "0" };
}

export const PerpetualMarketFunding = {
  encode(message: PerpetualMarketFunding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cumulativeFunding !== "") {
      writer.uint32(10).string(message.cumulativeFunding);
    }
    if (message.cumulativePrice !== "") {
      writer.uint32(18).string(message.cumulativePrice);
    }
    if (message.lastTimestamp !== "0") {
      writer.uint32(24).int64(message.lastTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketFunding {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketFunding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cumulativeFunding = reader.string();
          break;
        case 2:
          message.cumulativePrice = reader.string();
          break;
        case 3:
          message.lastTimestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketFunding {
    return {
      cumulativeFunding: isSet(object.cumulativeFunding) ? String(object.cumulativeFunding) : "",
      cumulativePrice: isSet(object.cumulativePrice) ? String(object.cumulativePrice) : "",
      lastTimestamp: isSet(object.lastTimestamp) ? String(object.lastTimestamp) : "0",
    };
  },

  toJSON(message: PerpetualMarketFunding): unknown {
    const obj: any = {};
    message.cumulativeFunding !== undefined && (obj.cumulativeFunding = message.cumulativeFunding);
    message.cumulativePrice !== undefined && (obj.cumulativePrice = message.cumulativePrice);
    message.lastTimestamp !== undefined && (obj.lastTimestamp = message.lastTimestamp);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding {
    return PerpetualMarketFunding.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketFunding>): PerpetualMarketFunding {
    const message = createBasePerpetualMarketFunding();
    message.cumulativeFunding = object.cumulativeFunding ?? "";
    message.cumulativePrice = object.cumulativePrice ?? "";
    message.lastTimestamp = object.lastTimestamp ?? "0";
    return message;
  },
};

function createBaseDerivativeMarketSettlementInfo(): DerivativeMarketSettlementInfo {
  return { marketId: "", settlementPrice: "" };
}

export const DerivativeMarketSettlementInfo = {
  encode(message: DerivativeMarketSettlementInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(18).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketSettlementInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarketSettlementInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarketSettlementInfo {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: DerivativeMarketSettlementInfo): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo {
    return DerivativeMarketSettlementInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarketSettlementInfo>): DerivativeMarketSettlementInfo {
    const message = createBaseDerivativeMarketSettlementInfo();
    message.marketId = object.marketId ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBaseNextFundingTimestamp(): NextFundingTimestamp {
  return { nextTimestamp: "0" };
}

export const NextFundingTimestamp = {
  encode(message: NextFundingTimestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nextTimestamp !== "0") {
      writer.uint32(8).int64(message.nextTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NextFundingTimestamp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextFundingTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nextTimestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NextFundingTimestamp {
    return { nextTimestamp: isSet(object.nextTimestamp) ? String(object.nextTimestamp) : "0" };
  },

  toJSON(message: NextFundingTimestamp): unknown {
    const obj: any = {};
    message.nextTimestamp !== undefined && (obj.nextTimestamp = message.nextTimestamp);
    return obj;
  },

  create(base?: DeepPartial<NextFundingTimestamp>): NextFundingTimestamp {
    return NextFundingTimestamp.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<NextFundingTimestamp>): NextFundingTimestamp {
    const message = createBaseNextFundingTimestamp();
    message.nextTimestamp = object.nextTimestamp ?? "0";
    return message;
  },
};

function createBaseSpotMarket(): SpotMarket {
  return {
    ticker: "",
    baseDenom: "",
    quoteDenom: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    marketId: "",
    status: 0,
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const SpotMarket = {
  encode(message: SpotMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ticker !== "") {
      writer.uint32(10).string(message.ticker);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(26).string(message.quoteDenom);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(34).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(42).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(50).string(message.relayerFeeShareRate);
    }
    if (message.marketId !== "") {
      writer.uint32(58).string(message.marketId);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(74).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(82).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ticker = reader.string();
          break;
        case 2:
          message.baseDenom = reader.string();
          break;
        case 3:
          message.quoteDenom = reader.string();
          break;
        case 4:
          message.makerFeeRate = reader.string();
          break;
        case 5:
          message.takerFeeRate = reader.string();
          break;
        case 6:
          message.relayerFeeShareRate = reader.string();
          break;
        case 7:
          message.marketId = reader.string();
          break;
        case 8:
          message.status = reader.int32() as any;
          break;
        case 9:
          message.minPriceTickSize = reader.string();
          break;
        case 10:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarket {
    return {
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: SpotMarket): unknown {
    const obj: any = {};
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<SpotMarket>): SpotMarket {
    return SpotMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarket>): SpotMarket {
    const message = createBaseSpotMarket();
    message.ticker = object.ticker ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.marketId = object.marketId ?? "";
    message.status = object.status ?? 0;
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseDeposit(): Deposit {
  return { availableBalance: "", totalBalance: "" };
}

export const Deposit = {
  encode(message: Deposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.availableBalance !== "") {
      writer.uint32(10).string(message.availableBalance);
    }
    if (message.totalBalance !== "") {
      writer.uint32(18).string(message.totalBalance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Deposit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.availableBalance = reader.string();
          break;
        case 2:
          message.totalBalance = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Deposit {
    return {
      availableBalance: isSet(object.availableBalance) ? String(object.availableBalance) : "",
      totalBalance: isSet(object.totalBalance) ? String(object.totalBalance) : "",
    };
  },

  toJSON(message: Deposit): unknown {
    const obj: any = {};
    message.availableBalance !== undefined && (obj.availableBalance = message.availableBalance);
    message.totalBalance !== undefined && (obj.totalBalance = message.totalBalance);
    return obj;
  },

  create(base?: DeepPartial<Deposit>): Deposit {
    return Deposit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Deposit>): Deposit {
    const message = createBaseDeposit();
    message.availableBalance = object.availableBalance ?? "";
    message.totalBalance = object.totalBalance ?? "";
    return message;
  },
};

function createBaseSubaccountTradeNonce(): SubaccountTradeNonce {
  return { nonce: 0 };
}

export const SubaccountTradeNonce = {
  encode(message: SubaccountTradeNonce, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonce !== 0) {
      writer.uint32(8).uint32(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountTradeNonce {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountTradeNonce();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountTradeNonce {
    return { nonce: isSet(object.nonce) ? Number(object.nonce) : 0 };
  },

  toJSON(message: SubaccountTradeNonce): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = Math.round(message.nonce));
    return obj;
  },

  create(base?: DeepPartial<SubaccountTradeNonce>): SubaccountTradeNonce {
    return SubaccountTradeNonce.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountTradeNonce>): SubaccountTradeNonce {
    const message = createBaseSubaccountTradeNonce();
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseOrderInfo(): OrderInfo {
  return { subaccountId: "", feeRecipient: "", price: "", quantity: "" };
}

export const OrderInfo = {
  encode(message: OrderInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.feeRecipient !== "") {
      writer.uint32(18).string(message.feeRecipient);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(34).string(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.feeRecipient = reader.string();
          break;
        case 3:
          message.price = reader.string();
          break;
        case 4:
          message.quantity = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderInfo {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      feeRecipient: isSet(object.feeRecipient) ? String(object.feeRecipient) : "",
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
    };
  },

  toJSON(message: OrderInfo): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.feeRecipient !== undefined && (obj.feeRecipient = message.feeRecipient);
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    return obj;
  },

  create(base?: DeepPartial<OrderInfo>): OrderInfo {
    return OrderInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderInfo>): OrderInfo {
    const message = createBaseOrderInfo();
    message.subaccountId = object.subaccountId ?? "";
    message.feeRecipient = object.feeRecipient ?? "";
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    return message;
  },
};

function createBaseSpotOrder(): SpotOrder {
  return { marketId: "", orderInfo: undefined, orderType: 0, triggerPrice: "" };
}

export const SpotOrder = {
  encode(message: SpotOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.orderType !== 0) {
      writer.uint32(24).int32(message.orderType);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(34).string(message.triggerPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.orderType = reader.int32() as any;
          break;
        case 4:
          message.triggerPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotOrder {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
    };
  },

  toJSON(message: SpotOrder): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    return obj;
  },

  create(base?: DeepPartial<SpotOrder>): SpotOrder {
    return SpotOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotOrder>): SpotOrder {
    const message = createBaseSpotOrder();
    message.marketId = object.marketId ?? "";
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.triggerPrice = object.triggerPrice ?? "";
    return message;
  },
};

function createBaseSpotLimitOrder(): SpotLimitOrder {
  return { orderInfo: undefined, orderType: 0, fillable: "", triggerPrice: "", orderHash: new Uint8Array() };
}

export const SpotLimitOrder = {
  encode(message: SpotLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.fillable !== "") {
      writer.uint32(26).string(message.fillable);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(34).string(message.triggerPrice);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(42).bytes(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.orderType = reader.int32() as any;
          break;
        case 3:
          message.fillable = reader.string();
          break;
        case 4:
          message.triggerPrice = reader.string();
          break;
        case 5:
          message.orderHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotLimitOrder {
    return {
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      fillable: isSet(object.fillable) ? String(object.fillable) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
    };
  },

  toJSON(message: SpotLimitOrder): unknown {
    const obj: any = {};
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.fillable !== undefined && (obj.fillable = message.fillable);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<SpotLimitOrder>): SpotLimitOrder {
    return SpotLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotLimitOrder>): SpotLimitOrder {
    const message = createBaseSpotLimitOrder();
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.fillable = object.fillable ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    return message;
  },
};

function createBaseSpotMarketOrder(): SpotMarketOrder {
  return { orderInfo: undefined, balanceHold: "", orderHash: new Uint8Array(), orderType: 0, triggerPrice: "" };
}

export const SpotMarketOrder = {
  encode(message: SpotMarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.balanceHold !== "") {
      writer.uint32(18).string(message.balanceHold);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(26).bytes(message.orderHash);
    }
    if (message.orderType !== 0) {
      writer.uint32(32).int32(message.orderType);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(42).string(message.triggerPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.balanceHold = reader.string();
          break;
        case 3:
          message.orderHash = reader.bytes();
          break;
        case 4:
          message.orderType = reader.int32() as any;
          break;
        case 5:
          message.triggerPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarketOrder {
    return {
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      balanceHold: isSet(object.balanceHold) ? String(object.balanceHold) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
    };
  },

  toJSON(message: SpotMarketOrder): unknown {
    const obj: any = {};
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.balanceHold !== undefined && (obj.balanceHold = message.balanceHold);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    return obj;
  },

  create(base?: DeepPartial<SpotMarketOrder>): SpotMarketOrder {
    return SpotMarketOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarketOrder>): SpotMarketOrder {
    const message = createBaseSpotMarketOrder();
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.balanceHold = object.balanceHold ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    message.orderType = object.orderType ?? 0;
    message.triggerPrice = object.triggerPrice ?? "";
    return message;
  },
};

function createBaseDerivativeOrder(): DerivativeOrder {
  return { marketId: "", orderInfo: undefined, orderType: 0, margin: "", triggerPrice: "" };
}

export const DerivativeOrder = {
  encode(message: DerivativeOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.orderType !== 0) {
      writer.uint32(24).int32(message.orderType);
    }
    if (message.margin !== "") {
      writer.uint32(34).string(message.margin);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(42).string(message.triggerPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.orderType = reader.int32() as any;
          break;
        case 4:
          message.margin = reader.string();
          break;
        case 5:
          message.triggerPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeOrder {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      margin: isSet(object.margin) ? String(object.margin) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
    };
  },

  toJSON(message: DerivativeOrder): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.margin !== undefined && (obj.margin = message.margin);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    return obj;
  },

  create(base?: DeepPartial<DerivativeOrder>): DerivativeOrder {
    return DerivativeOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeOrder>): DerivativeOrder {
    const message = createBaseDerivativeOrder();
    message.marketId = object.marketId ?? "";
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.margin = object.margin ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    return message;
  },
};

function createBaseSubaccountOrderbookMetadata(): SubaccountOrderbookMetadata {
  return {
    vanillaLimitOrderCount: 0,
    reduceOnlyLimitOrderCount: 0,
    aggregateReduceOnlyQuantity: "",
    aggregateVanillaQuantity: "",
    vanillaConditionalOrderCount: 0,
    reduceOnlyConditionalOrderCount: 0,
  };
}

export const SubaccountOrderbookMetadata = {
  encode(message: SubaccountOrderbookMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vanillaLimitOrderCount !== 0) {
      writer.uint32(8).uint32(message.vanillaLimitOrderCount);
    }
    if (message.reduceOnlyLimitOrderCount !== 0) {
      writer.uint32(16).uint32(message.reduceOnlyLimitOrderCount);
    }
    if (message.aggregateReduceOnlyQuantity !== "") {
      writer.uint32(26).string(message.aggregateReduceOnlyQuantity);
    }
    if (message.aggregateVanillaQuantity !== "") {
      writer.uint32(34).string(message.aggregateVanillaQuantity);
    }
    if (message.vanillaConditionalOrderCount !== 0) {
      writer.uint32(40).uint32(message.vanillaConditionalOrderCount);
    }
    if (message.reduceOnlyConditionalOrderCount !== 0) {
      writer.uint32(48).uint32(message.reduceOnlyConditionalOrderCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderbookMetadata {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrderbookMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vanillaLimitOrderCount = reader.uint32();
          break;
        case 2:
          message.reduceOnlyLimitOrderCount = reader.uint32();
          break;
        case 3:
          message.aggregateReduceOnlyQuantity = reader.string();
          break;
        case 4:
          message.aggregateVanillaQuantity = reader.string();
          break;
        case 5:
          message.vanillaConditionalOrderCount = reader.uint32();
          break;
        case 6:
          message.reduceOnlyConditionalOrderCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrderbookMetadata {
    return {
      vanillaLimitOrderCount: isSet(object.vanillaLimitOrderCount) ? Number(object.vanillaLimitOrderCount) : 0,
      reduceOnlyLimitOrderCount: isSet(object.reduceOnlyLimitOrderCount) ? Number(object.reduceOnlyLimitOrderCount) : 0,
      aggregateReduceOnlyQuantity: isSet(object.aggregateReduceOnlyQuantity)
        ? String(object.aggregateReduceOnlyQuantity)
        : "",
      aggregateVanillaQuantity: isSet(object.aggregateVanillaQuantity) ? String(object.aggregateVanillaQuantity) : "",
      vanillaConditionalOrderCount: isSet(object.vanillaConditionalOrderCount)
        ? Number(object.vanillaConditionalOrderCount)
        : 0,
      reduceOnlyConditionalOrderCount: isSet(object.reduceOnlyConditionalOrderCount)
        ? Number(object.reduceOnlyConditionalOrderCount)
        : 0,
    };
  },

  toJSON(message: SubaccountOrderbookMetadata): unknown {
    const obj: any = {};
    message.vanillaLimitOrderCount !== undefined &&
      (obj.vanillaLimitOrderCount = Math.round(message.vanillaLimitOrderCount));
    message.reduceOnlyLimitOrderCount !== undefined &&
      (obj.reduceOnlyLimitOrderCount = Math.round(message.reduceOnlyLimitOrderCount));
    message.aggregateReduceOnlyQuantity !== undefined &&
      (obj.aggregateReduceOnlyQuantity = message.aggregateReduceOnlyQuantity);
    message.aggregateVanillaQuantity !== undefined && (obj.aggregateVanillaQuantity = message.aggregateVanillaQuantity);
    message.vanillaConditionalOrderCount !== undefined &&
      (obj.vanillaConditionalOrderCount = Math.round(message.vanillaConditionalOrderCount));
    message.reduceOnlyConditionalOrderCount !== undefined &&
      (obj.reduceOnlyConditionalOrderCount = Math.round(message.reduceOnlyConditionalOrderCount));
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrderbookMetadata>): SubaccountOrderbookMetadata {
    return SubaccountOrderbookMetadata.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrderbookMetadata>): SubaccountOrderbookMetadata {
    const message = createBaseSubaccountOrderbookMetadata();
    message.vanillaLimitOrderCount = object.vanillaLimitOrderCount ?? 0;
    message.reduceOnlyLimitOrderCount = object.reduceOnlyLimitOrderCount ?? 0;
    message.aggregateReduceOnlyQuantity = object.aggregateReduceOnlyQuantity ?? "";
    message.aggregateVanillaQuantity = object.aggregateVanillaQuantity ?? "";
    message.vanillaConditionalOrderCount = object.vanillaConditionalOrderCount ?? 0;
    message.reduceOnlyConditionalOrderCount = object.reduceOnlyConditionalOrderCount ?? 0;
    return message;
  },
};

function createBaseSubaccountOrder(): SubaccountOrder {
  return { price: "", quantity: "", isReduceOnly: false };
}

export const SubaccountOrder = {
  encode(message: SubaccountOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.isReduceOnly === true) {
      writer.uint32(24).bool(message.isReduceOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.isReduceOnly = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrder {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      isReduceOnly: isSet(object.isReduceOnly) ? Boolean(object.isReduceOnly) : false,
    };
  },

  toJSON(message: SubaccountOrder): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.isReduceOnly !== undefined && (obj.isReduceOnly = message.isReduceOnly);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrder>): SubaccountOrder {
    return SubaccountOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrder>): SubaccountOrder {
    const message = createBaseSubaccountOrder();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.isReduceOnly = object.isReduceOnly ?? false;
    return message;
  },
};

function createBaseSubaccountOrderData(): SubaccountOrderData {
  return { order: undefined, orderHash: new Uint8Array() };
}

export const SubaccountOrderData = {
  encode(message: SubaccountOrderData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      SubaccountOrder.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(18).bytes(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrderData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.order = SubaccountOrder.decode(reader, reader.uint32());
          break;
        case 2:
          message.orderHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrderData {
    return {
      order: isSet(object.order) ? SubaccountOrder.fromJSON(object.order) : undefined,
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
    };
  },

  toJSON(message: SubaccountOrderData): unknown {
    const obj: any = {};
    message.order !== undefined && (obj.order = message.order ? SubaccountOrder.toJSON(message.order) : undefined);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrderData>): SubaccountOrderData {
    return SubaccountOrderData.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrderData>): SubaccountOrderData {
    const message = createBaseSubaccountOrderData();
    message.order = (object.order !== undefined && object.order !== null)
      ? SubaccountOrder.fromPartial(object.order)
      : undefined;
    message.orderHash = object.orderHash ?? new Uint8Array();
    return message;
  },
};

function createBaseDerivativeLimitOrder(): DerivativeLimitOrder {
  return {
    orderInfo: undefined,
    orderType: 0,
    margin: "",
    fillable: "",
    triggerPrice: "",
    orderHash: new Uint8Array(),
  };
}

export const DerivativeLimitOrder = {
  encode(message: DerivativeLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.margin !== "") {
      writer.uint32(26).string(message.margin);
    }
    if (message.fillable !== "") {
      writer.uint32(34).string(message.fillable);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(42).string(message.triggerPrice);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(50).bytes(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.orderType = reader.int32() as any;
          break;
        case 3:
          message.margin = reader.string();
          break;
        case 4:
          message.fillable = reader.string();
          break;
        case 5:
          message.triggerPrice = reader.string();
          break;
        case 6:
          message.orderHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeLimitOrder {
    return {
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      margin: isSet(object.margin) ? String(object.margin) : "",
      fillable: isSet(object.fillable) ? String(object.fillable) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
    };
  },

  toJSON(message: DerivativeLimitOrder): unknown {
    const obj: any = {};
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.margin !== undefined && (obj.margin = message.margin);
    message.fillable !== undefined && (obj.fillable = message.fillable);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder {
    return DerivativeLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeLimitOrder>): DerivativeLimitOrder {
    const message = createBaseDerivativeLimitOrder();
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.margin = object.margin ?? "";
    message.fillable = object.fillable ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    return message;
  },
};

function createBaseDerivativeMarketOrder(): DerivativeMarketOrder {
  return {
    orderInfo: undefined,
    orderType: 0,
    margin: "",
    marginHold: "",
    triggerPrice: "",
    orderHash: new Uint8Array(),
  };
}

export const DerivativeMarketOrder = {
  encode(message: DerivativeMarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderInfo !== undefined) {
      OrderInfo.encode(message.orderInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.margin !== "") {
      writer.uint32(26).string(message.margin);
    }
    if (message.marginHold !== "") {
      writer.uint32(34).string(message.marginHold);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(42).string(message.triggerPrice);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(50).bytes(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderInfo = OrderInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.orderType = reader.int32() as any;
          break;
        case 3:
          message.margin = reader.string();
          break;
        case 4:
          message.marginHold = reader.string();
          break;
        case 5:
          message.triggerPrice = reader.string();
          break;
        case 6:
          message.orderHash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarketOrder {
    return {
      orderInfo: isSet(object.orderInfo) ? OrderInfo.fromJSON(object.orderInfo) : undefined,
      orderType: isSet(object.orderType) ? orderTypeFromJSON(object.orderType) : 0,
      margin: isSet(object.margin) ? String(object.margin) : "",
      marginHold: isSet(object.marginHold) ? String(object.marginHold) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
    };
  },

  toJSON(message: DerivativeMarketOrder): unknown {
    const obj: any = {};
    message.orderInfo !== undefined &&
      (obj.orderInfo = message.orderInfo ? OrderInfo.toJSON(message.orderInfo) : undefined);
    message.orderType !== undefined && (obj.orderType = orderTypeToJSON(message.orderType));
    message.margin !== undefined && (obj.margin = message.margin);
    message.marginHold !== undefined && (obj.marginHold = message.marginHold);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarketOrder>): DerivativeMarketOrder {
    return DerivativeMarketOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarketOrder>): DerivativeMarketOrder {
    const message = createBaseDerivativeMarketOrder();
    message.orderInfo = (object.orderInfo !== undefined && object.orderInfo !== null)
      ? OrderInfo.fromPartial(object.orderInfo)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.margin = object.margin ?? "";
    message.marginHold = object.marginHold ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    return message;
  },
};

function createBasePosition(): Position {
  return { isLong: false, quantity: "", entryPrice: "", margin: "", cumulativeFundingEntry: "" };
}

export const Position = {
  encode(message: Position, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isLong === true) {
      writer.uint32(8).bool(message.isLong);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.entryPrice !== "") {
      writer.uint32(26).string(message.entryPrice);
    }
    if (message.margin !== "") {
      writer.uint32(34).string(message.margin);
    }
    if (message.cumulativeFundingEntry !== "") {
      writer.uint32(42).string(message.cumulativeFundingEntry);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Position {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isLong = reader.bool();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.entryPrice = reader.string();
          break;
        case 4:
          message.margin = reader.string();
          break;
        case 5:
          message.cumulativeFundingEntry = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Position {
    return {
      isLong: isSet(object.isLong) ? Boolean(object.isLong) : false,
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      entryPrice: isSet(object.entryPrice) ? String(object.entryPrice) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
      cumulativeFundingEntry: isSet(object.cumulativeFundingEntry) ? String(object.cumulativeFundingEntry) : "",
    };
  },

  toJSON(message: Position): unknown {
    const obj: any = {};
    message.isLong !== undefined && (obj.isLong = message.isLong);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.entryPrice !== undefined && (obj.entryPrice = message.entryPrice);
    message.margin !== undefined && (obj.margin = message.margin);
    message.cumulativeFundingEntry !== undefined && (obj.cumulativeFundingEntry = message.cumulativeFundingEntry);
    return obj;
  },

  create(base?: DeepPartial<Position>): Position {
    return Position.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Position>): Position {
    const message = createBasePosition();
    message.isLong = object.isLong ?? false;
    message.quantity = object.quantity ?? "";
    message.entryPrice = object.entryPrice ?? "";
    message.margin = object.margin ?? "";
    message.cumulativeFundingEntry = object.cumulativeFundingEntry ?? "";
    return message;
  },
};

function createBaseMarketOrderIndicator(): MarketOrderIndicator {
  return { marketId: "", isBuy: false };
}

export const MarketOrderIndicator = {
  encode(message: MarketOrderIndicator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.isBuy === true) {
      writer.uint32(16).bool(message.isBuy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderIndicator {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderIndicator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.isBuy = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderIndicator {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      isBuy: isSet(object.isBuy) ? Boolean(object.isBuy) : false,
    };
  },

  toJSON(message: MarketOrderIndicator): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.isBuy !== undefined && (obj.isBuy = message.isBuy);
    return obj;
  },

  create(base?: DeepPartial<MarketOrderIndicator>): MarketOrderIndicator {
    return MarketOrderIndicator.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketOrderIndicator>): MarketOrderIndicator {
    const message = createBaseMarketOrderIndicator();
    message.marketId = object.marketId ?? "";
    message.isBuy = object.isBuy ?? false;
    return message;
  },
};

function createBaseTradeLog(): TradeLog {
  return {
    quantity: "",
    price: "",
    subaccountId: new Uint8Array(),
    fee: "",
    orderHash: new Uint8Array(),
    feeRecipientAddress: new Uint8Array(),
  };
}

export const TradeLog = {
  encode(message: TradeLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.quantity !== "") {
      writer.uint32(10).string(message.quantity);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.subaccountId.length !== 0) {
      writer.uint32(26).bytes(message.subaccountId);
    }
    if (message.fee !== "") {
      writer.uint32(34).string(message.fee);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(42).bytes(message.orderHash);
    }
    if (message.feeRecipientAddress.length !== 0) {
      writer.uint32(50).bytes(message.feeRecipientAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeLog {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quantity = reader.string();
          break;
        case 2:
          message.price = reader.string();
          break;
        case 3:
          message.subaccountId = reader.bytes();
          break;
        case 4:
          message.fee = reader.string();
          break;
        case 5:
          message.orderHash = reader.bytes();
          break;
        case 6:
          message.feeRecipientAddress = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradeLog {
    return {
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      price: isSet(object.price) ? String(object.price) : "",
      subaccountId: isSet(object.subaccountId) ? bytesFromBase64(object.subaccountId) : new Uint8Array(),
      fee: isSet(object.fee) ? String(object.fee) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
      feeRecipientAddress: isSet(object.feeRecipientAddress)
        ? bytesFromBase64(object.feeRecipientAddress)
        : new Uint8Array(),
    };
  },

  toJSON(message: TradeLog): unknown {
    const obj: any = {};
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.price !== undefined && (obj.price = message.price);
    message.subaccountId !== undefined &&
      (obj.subaccountId = base64FromBytes(
        message.subaccountId !== undefined ? message.subaccountId : new Uint8Array(),
      ));
    message.fee !== undefined && (obj.fee = message.fee);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    message.feeRecipientAddress !== undefined &&
      (obj.feeRecipientAddress = base64FromBytes(
        message.feeRecipientAddress !== undefined ? message.feeRecipientAddress : new Uint8Array(),
      ));
    return obj;
  },

  create(base?: DeepPartial<TradeLog>): TradeLog {
    return TradeLog.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradeLog>): TradeLog {
    const message = createBaseTradeLog();
    message.quantity = object.quantity ?? "";
    message.price = object.price ?? "";
    message.subaccountId = object.subaccountId ?? new Uint8Array();
    message.fee = object.fee ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    message.feeRecipientAddress = object.feeRecipientAddress ?? new Uint8Array();
    return message;
  },
};

function createBasePositionDelta(): PositionDelta {
  return { isLong: false, executionQuantity: "", executionMargin: "", executionPrice: "" };
}

export const PositionDelta = {
  encode(message: PositionDelta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isLong === true) {
      writer.uint32(8).bool(message.isLong);
    }
    if (message.executionQuantity !== "") {
      writer.uint32(18).string(message.executionQuantity);
    }
    if (message.executionMargin !== "") {
      writer.uint32(26).string(message.executionMargin);
    }
    if (message.executionPrice !== "") {
      writer.uint32(34).string(message.executionPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PositionDelta {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isLong = reader.bool();
          break;
        case 2:
          message.executionQuantity = reader.string();
          break;
        case 3:
          message.executionMargin = reader.string();
          break;
        case 4:
          message.executionPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PositionDelta {
    return {
      isLong: isSet(object.isLong) ? Boolean(object.isLong) : false,
      executionQuantity: isSet(object.executionQuantity) ? String(object.executionQuantity) : "",
      executionMargin: isSet(object.executionMargin) ? String(object.executionMargin) : "",
      executionPrice: isSet(object.executionPrice) ? String(object.executionPrice) : "",
    };
  },

  toJSON(message: PositionDelta): unknown {
    const obj: any = {};
    message.isLong !== undefined && (obj.isLong = message.isLong);
    message.executionQuantity !== undefined && (obj.executionQuantity = message.executionQuantity);
    message.executionMargin !== undefined && (obj.executionMargin = message.executionMargin);
    message.executionPrice !== undefined && (obj.executionPrice = message.executionPrice);
    return obj;
  },

  create(base?: DeepPartial<PositionDelta>): PositionDelta {
    return PositionDelta.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PositionDelta>): PositionDelta {
    const message = createBasePositionDelta();
    message.isLong = object.isLong ?? false;
    message.executionQuantity = object.executionQuantity ?? "";
    message.executionMargin = object.executionMargin ?? "";
    message.executionPrice = object.executionPrice ?? "";
    return message;
  },
};

function createBaseDerivativeTradeLog(): DerivativeTradeLog {
  return {
    subaccountId: new Uint8Array(),
    positionDelta: undefined,
    payout: "",
    fee: "",
    orderHash: new Uint8Array(),
    feeRecipientAddress: new Uint8Array(),
  };
}

export const DerivativeTradeLog = {
  encode(message: DerivativeTradeLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId.length !== 0) {
      writer.uint32(10).bytes(message.subaccountId);
    }
    if (message.positionDelta !== undefined) {
      PositionDelta.encode(message.positionDelta, writer.uint32(18).fork()).ldelim();
    }
    if (message.payout !== "") {
      writer.uint32(26).string(message.payout);
    }
    if (message.fee !== "") {
      writer.uint32(34).string(message.fee);
    }
    if (message.orderHash.length !== 0) {
      writer.uint32(42).bytes(message.orderHash);
    }
    if (message.feeRecipientAddress.length !== 0) {
      writer.uint32(50).bytes(message.feeRecipientAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeTradeLog {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeTradeLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.bytes();
          break;
        case 2:
          message.positionDelta = PositionDelta.decode(reader, reader.uint32());
          break;
        case 3:
          message.payout = reader.string();
          break;
        case 4:
          message.fee = reader.string();
          break;
        case 5:
          message.orderHash = reader.bytes();
          break;
        case 6:
          message.feeRecipientAddress = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeTradeLog {
    return {
      subaccountId: isSet(object.subaccountId) ? bytesFromBase64(object.subaccountId) : new Uint8Array(),
      positionDelta: isSet(object.positionDelta) ? PositionDelta.fromJSON(object.positionDelta) : undefined,
      payout: isSet(object.payout) ? String(object.payout) : "",
      fee: isSet(object.fee) ? String(object.fee) : "",
      orderHash: isSet(object.orderHash) ? bytesFromBase64(object.orderHash) : new Uint8Array(),
      feeRecipientAddress: isSet(object.feeRecipientAddress)
        ? bytesFromBase64(object.feeRecipientAddress)
        : new Uint8Array(),
    };
  },

  toJSON(message: DerivativeTradeLog): unknown {
    const obj: any = {};
    message.subaccountId !== undefined &&
      (obj.subaccountId = base64FromBytes(
        message.subaccountId !== undefined ? message.subaccountId : new Uint8Array(),
      ));
    message.positionDelta !== undefined &&
      (obj.positionDelta = message.positionDelta ? PositionDelta.toJSON(message.positionDelta) : undefined);
    message.payout !== undefined && (obj.payout = message.payout);
    message.fee !== undefined && (obj.fee = message.fee);
    message.orderHash !== undefined &&
      (obj.orderHash = base64FromBytes(message.orderHash !== undefined ? message.orderHash : new Uint8Array()));
    message.feeRecipientAddress !== undefined &&
      (obj.feeRecipientAddress = base64FromBytes(
        message.feeRecipientAddress !== undefined ? message.feeRecipientAddress : new Uint8Array(),
      ));
    return obj;
  },

  create(base?: DeepPartial<DerivativeTradeLog>): DerivativeTradeLog {
    return DerivativeTradeLog.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeTradeLog>): DerivativeTradeLog {
    const message = createBaseDerivativeTradeLog();
    message.subaccountId = object.subaccountId ?? new Uint8Array();
    message.positionDelta = (object.positionDelta !== undefined && object.positionDelta !== null)
      ? PositionDelta.fromPartial(object.positionDelta)
      : undefined;
    message.payout = object.payout ?? "";
    message.fee = object.fee ?? "";
    message.orderHash = object.orderHash ?? new Uint8Array();
    message.feeRecipientAddress = object.feeRecipientAddress ?? new Uint8Array();
    return message;
  },
};

function createBaseSubaccountPosition(): SubaccountPosition {
  return { position: undefined, subaccountId: new Uint8Array() };
}

export const SubaccountPosition = {
  encode(message: SubaccountPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.subaccountId.length !== 0) {
      writer.uint32(18).bytes(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountPosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.position = Position.decode(reader, reader.uint32());
          break;
        case 2:
          message.subaccountId = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountPosition {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      subaccountId: isSet(object.subaccountId) ? bytesFromBase64(object.subaccountId) : new Uint8Array(),
    };
  },

  toJSON(message: SubaccountPosition): unknown {
    const obj: any = {};
    message.position !== undefined && (obj.position = message.position ? Position.toJSON(message.position) : undefined);
    message.subaccountId !== undefined &&
      (obj.subaccountId = base64FromBytes(
        message.subaccountId !== undefined ? message.subaccountId : new Uint8Array(),
      ));
    return obj;
  },

  create(base?: DeepPartial<SubaccountPosition>): SubaccountPosition {
    return SubaccountPosition.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountPosition>): SubaccountPosition {
    const message = createBaseSubaccountPosition();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.subaccountId = object.subaccountId ?? new Uint8Array();
    return message;
  },
};

function createBaseSubaccountDeposit(): SubaccountDeposit {
  return { subaccountId: new Uint8Array(), deposit: undefined };
}

export const SubaccountDeposit = {
  encode(message: SubaccountDeposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId.length !== 0) {
      writer.uint32(10).bytes(message.subaccountId);
    }
    if (message.deposit !== undefined) {
      Deposit.encode(message.deposit, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountDeposit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.bytes();
          break;
        case 2:
          message.deposit = Deposit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountDeposit {
    return {
      subaccountId: isSet(object.subaccountId) ? bytesFromBase64(object.subaccountId) : new Uint8Array(),
      deposit: isSet(object.deposit) ? Deposit.fromJSON(object.deposit) : undefined,
    };
  },

  toJSON(message: SubaccountDeposit): unknown {
    const obj: any = {};
    message.subaccountId !== undefined &&
      (obj.subaccountId = base64FromBytes(
        message.subaccountId !== undefined ? message.subaccountId : new Uint8Array(),
      ));
    message.deposit !== undefined && (obj.deposit = message.deposit ? Deposit.toJSON(message.deposit) : undefined);
    return obj;
  },

  create(base?: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    return SubaccountDeposit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountDeposit>): SubaccountDeposit {
    const message = createBaseSubaccountDeposit();
    message.subaccountId = object.subaccountId ?? new Uint8Array();
    message.deposit = (object.deposit !== undefined && object.deposit !== null)
      ? Deposit.fromPartial(object.deposit)
      : undefined;
    return message;
  },
};

function createBaseDepositUpdate(): DepositUpdate {
  return { denom: "", deposits: [] };
}

export const DepositUpdate = {
  encode(message: DepositUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.deposits) {
      SubaccountDeposit.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DepositUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.deposits.push(SubaccountDeposit.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DepositUpdate {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      deposits: Array.isArray(object?.deposits) ? object.deposits.map((e: any) => SubaccountDeposit.fromJSON(e)) : [],
    };
  },

  toJSON(message: DepositUpdate): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    if (message.deposits) {
      obj.deposits = message.deposits.map((e) => e ? SubaccountDeposit.toJSON(e) : undefined);
    } else {
      obj.deposits = [];
    }
    return obj;
  },

  create(base?: DeepPartial<DepositUpdate>): DepositUpdate {
    return DepositUpdate.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DepositUpdate>): DepositUpdate {
    const message = createBaseDepositUpdate();
    message.denom = object.denom ?? "";
    message.deposits = object.deposits?.map((e) => SubaccountDeposit.fromPartial(e)) || [];
    return message;
  },
};

function createBasePointsMultiplier(): PointsMultiplier {
  return { makerPointsMultiplier: "", takerPointsMultiplier: "" };
}

export const PointsMultiplier = {
  encode(message: PointsMultiplier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.makerPointsMultiplier !== "") {
      writer.uint32(10).string(message.makerPointsMultiplier);
    }
    if (message.takerPointsMultiplier !== "") {
      writer.uint32(18).string(message.takerPointsMultiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PointsMultiplier {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointsMultiplier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.makerPointsMultiplier = reader.string();
          break;
        case 2:
          message.takerPointsMultiplier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PointsMultiplier {
    return {
      makerPointsMultiplier: isSet(object.makerPointsMultiplier) ? String(object.makerPointsMultiplier) : "",
      takerPointsMultiplier: isSet(object.takerPointsMultiplier) ? String(object.takerPointsMultiplier) : "",
    };
  },

  toJSON(message: PointsMultiplier): unknown {
    const obj: any = {};
    message.makerPointsMultiplier !== undefined && (obj.makerPointsMultiplier = message.makerPointsMultiplier);
    message.takerPointsMultiplier !== undefined && (obj.takerPointsMultiplier = message.takerPointsMultiplier);
    return obj;
  },

  create(base?: DeepPartial<PointsMultiplier>): PointsMultiplier {
    return PointsMultiplier.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PointsMultiplier>): PointsMultiplier {
    const message = createBasePointsMultiplier();
    message.makerPointsMultiplier = object.makerPointsMultiplier ?? "";
    message.takerPointsMultiplier = object.takerPointsMultiplier ?? "";
    return message;
  },
};

function createBaseTradingRewardCampaignBoostInfo(): TradingRewardCampaignBoostInfo {
  return {
    boostedSpotMarketIds: [],
    spotMarketMultipliers: [],
    boostedDerivativeMarketIds: [],
    derivativeMarketMultipliers: [],
  };
}

export const TradingRewardCampaignBoostInfo = {
  encode(message: TradingRewardCampaignBoostInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.boostedSpotMarketIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.spotMarketMultipliers) {
      PointsMultiplier.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.boostedDerivativeMarketIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.derivativeMarketMultipliers) {
      PointsMultiplier.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignBoostInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingRewardCampaignBoostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.boostedSpotMarketIds.push(reader.string());
          break;
        case 2:
          message.spotMarketMultipliers.push(PointsMultiplier.decode(reader, reader.uint32()));
          break;
        case 3:
          message.boostedDerivativeMarketIds.push(reader.string());
          break;
        case 4:
          message.derivativeMarketMultipliers.push(PointsMultiplier.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradingRewardCampaignBoostInfo {
    return {
      boostedSpotMarketIds: Array.isArray(object?.boostedSpotMarketIds)
        ? object.boostedSpotMarketIds.map((e: any) => String(e))
        : [],
      spotMarketMultipliers: Array.isArray(object?.spotMarketMultipliers)
        ? object.spotMarketMultipliers.map((e: any) => PointsMultiplier.fromJSON(e))
        : [],
      boostedDerivativeMarketIds: Array.isArray(object?.boostedDerivativeMarketIds)
        ? object.boostedDerivativeMarketIds.map((e: any) => String(e))
        : [],
      derivativeMarketMultipliers: Array.isArray(object?.derivativeMarketMultipliers)
        ? object.derivativeMarketMultipliers.map((e: any) => PointsMultiplier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradingRewardCampaignBoostInfo): unknown {
    const obj: any = {};
    if (message.boostedSpotMarketIds) {
      obj.boostedSpotMarketIds = message.boostedSpotMarketIds.map((e) => e);
    } else {
      obj.boostedSpotMarketIds = [];
    }
    if (message.spotMarketMultipliers) {
      obj.spotMarketMultipliers = message.spotMarketMultipliers.map((e) => e ? PointsMultiplier.toJSON(e) : undefined);
    } else {
      obj.spotMarketMultipliers = [];
    }
    if (message.boostedDerivativeMarketIds) {
      obj.boostedDerivativeMarketIds = message.boostedDerivativeMarketIds.map((e) => e);
    } else {
      obj.boostedDerivativeMarketIds = [];
    }
    if (message.derivativeMarketMultipliers) {
      obj.derivativeMarketMultipliers = message.derivativeMarketMultipliers.map((e) =>
        e ? PointsMultiplier.toJSON(e) : undefined
      );
    } else {
      obj.derivativeMarketMultipliers = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo {
    return TradingRewardCampaignBoostInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradingRewardCampaignBoostInfo>): TradingRewardCampaignBoostInfo {
    const message = createBaseTradingRewardCampaignBoostInfo();
    message.boostedSpotMarketIds = object.boostedSpotMarketIds?.map((e) => e) || [];
    message.spotMarketMultipliers = object.spotMarketMultipliers?.map((e) => PointsMultiplier.fromPartial(e)) || [];
    message.boostedDerivativeMarketIds = object.boostedDerivativeMarketIds?.map((e) => e) || [];
    message.derivativeMarketMultipliers =
      object.derivativeMarketMultipliers?.map((e) => PointsMultiplier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampaignRewardPool(): CampaignRewardPool {
  return { startTimestamp: "0", maxCampaignRewards: [] };
}

export const CampaignRewardPool = {
  encode(message: CampaignRewardPool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startTimestamp !== "0") {
      writer.uint32(8).int64(message.startTimestamp);
    }
    for (const v of message.maxCampaignRewards) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CampaignRewardPool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignRewardPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.startTimestamp = longToString(reader.int64() as Long);
          break;
        case 2:
          message.maxCampaignRewards.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CampaignRewardPool {
    return {
      startTimestamp: isSet(object.startTimestamp) ? String(object.startTimestamp) : "0",
      maxCampaignRewards: Array.isArray(object?.maxCampaignRewards)
        ? object.maxCampaignRewards.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CampaignRewardPool): unknown {
    const obj: any = {};
    message.startTimestamp !== undefined && (obj.startTimestamp = message.startTimestamp);
    if (message.maxCampaignRewards) {
      obj.maxCampaignRewards = message.maxCampaignRewards.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.maxCampaignRewards = [];
    }
    return obj;
  },

  create(base?: DeepPartial<CampaignRewardPool>): CampaignRewardPool {
    return CampaignRewardPool.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CampaignRewardPool>): CampaignRewardPool {
    const message = createBaseCampaignRewardPool();
    message.startTimestamp = object.startTimestamp ?? "0";
    message.maxCampaignRewards = object.maxCampaignRewards?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradingRewardCampaignInfo(): TradingRewardCampaignInfo {
  return {
    campaignDurationSeconds: "0",
    quoteDenoms: [],
    tradingRewardBoostInfo: undefined,
    disqualifiedMarketIds: [],
  };
}

export const TradingRewardCampaignInfo = {
  encode(message: TradingRewardCampaignInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.campaignDurationSeconds !== "0") {
      writer.uint32(8).int64(message.campaignDurationSeconds);
    }
    for (const v of message.quoteDenoms) {
      writer.uint32(18).string(v!);
    }
    if (message.tradingRewardBoostInfo !== undefined) {
      TradingRewardCampaignBoostInfo.encode(message.tradingRewardBoostInfo, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.disqualifiedMarketIds) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingRewardCampaignInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.campaignDurationSeconds = longToString(reader.int64() as Long);
          break;
        case 2:
          message.quoteDenoms.push(reader.string());
          break;
        case 3:
          message.tradingRewardBoostInfo = TradingRewardCampaignBoostInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradingRewardCampaignInfo {
    return {
      campaignDurationSeconds: isSet(object.campaignDurationSeconds) ? String(object.campaignDurationSeconds) : "0",
      quoteDenoms: Array.isArray(object?.quoteDenoms) ? object.quoteDenoms.map((e: any) => String(e)) : [],
      tradingRewardBoostInfo: isSet(object.tradingRewardBoostInfo)
        ? TradingRewardCampaignBoostInfo.fromJSON(object.tradingRewardBoostInfo)
        : undefined,
      disqualifiedMarketIds: Array.isArray(object?.disqualifiedMarketIds)
        ? object.disqualifiedMarketIds.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: TradingRewardCampaignInfo): unknown {
    const obj: any = {};
    message.campaignDurationSeconds !== undefined && (obj.campaignDurationSeconds = message.campaignDurationSeconds);
    if (message.quoteDenoms) {
      obj.quoteDenoms = message.quoteDenoms.map((e) => e);
    } else {
      obj.quoteDenoms = [];
    }
    message.tradingRewardBoostInfo !== undefined && (obj.tradingRewardBoostInfo = message.tradingRewardBoostInfo
      ? TradingRewardCampaignBoostInfo.toJSON(message.tradingRewardBoostInfo)
      : undefined);
    if (message.disqualifiedMarketIds) {
      obj.disqualifiedMarketIds = message.disqualifiedMarketIds.map((e) => e);
    } else {
      obj.disqualifiedMarketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradingRewardCampaignInfo>): TradingRewardCampaignInfo {
    return TradingRewardCampaignInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradingRewardCampaignInfo>): TradingRewardCampaignInfo {
    const message = createBaseTradingRewardCampaignInfo();
    message.campaignDurationSeconds = object.campaignDurationSeconds ?? "0";
    message.quoteDenoms = object.quoteDenoms?.map((e) => e) || [];
    message.tradingRewardBoostInfo =
      (object.tradingRewardBoostInfo !== undefined && object.tradingRewardBoostInfo !== null)
        ? TradingRewardCampaignBoostInfo.fromPartial(object.tradingRewardBoostInfo)
        : undefined;
    message.disqualifiedMarketIds = object.disqualifiedMarketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeeDiscountTierInfo(): FeeDiscountTierInfo {
  return { makerDiscountRate: "", takerDiscountRate: "", stakedAmount: "", volume: "" };
}

export const FeeDiscountTierInfo = {
  encode(message: FeeDiscountTierInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.makerDiscountRate !== "") {
      writer.uint32(10).string(message.makerDiscountRate);
    }
    if (message.takerDiscountRate !== "") {
      writer.uint32(18).string(message.takerDiscountRate);
    }
    if (message.stakedAmount !== "") {
      writer.uint32(26).string(message.stakedAmount);
    }
    if (message.volume !== "") {
      writer.uint32(34).string(message.volume);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountTierInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeDiscountTierInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.makerDiscountRate = reader.string();
          break;
        case 2:
          message.takerDiscountRate = reader.string();
          break;
        case 3:
          message.stakedAmount = reader.string();
          break;
        case 4:
          message.volume = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeeDiscountTierInfo {
    return {
      makerDiscountRate: isSet(object.makerDiscountRate) ? String(object.makerDiscountRate) : "",
      takerDiscountRate: isSet(object.takerDiscountRate) ? String(object.takerDiscountRate) : "",
      stakedAmount: isSet(object.stakedAmount) ? String(object.stakedAmount) : "",
      volume: isSet(object.volume) ? String(object.volume) : "",
    };
  },

  toJSON(message: FeeDiscountTierInfo): unknown {
    const obj: any = {};
    message.makerDiscountRate !== undefined && (obj.makerDiscountRate = message.makerDiscountRate);
    message.takerDiscountRate !== undefined && (obj.takerDiscountRate = message.takerDiscountRate);
    message.stakedAmount !== undefined && (obj.stakedAmount = message.stakedAmount);
    message.volume !== undefined && (obj.volume = message.volume);
    return obj;
  },

  create(base?: DeepPartial<FeeDiscountTierInfo>): FeeDiscountTierInfo {
    return FeeDiscountTierInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FeeDiscountTierInfo>): FeeDiscountTierInfo {
    const message = createBaseFeeDiscountTierInfo();
    message.makerDiscountRate = object.makerDiscountRate ?? "";
    message.takerDiscountRate = object.takerDiscountRate ?? "";
    message.stakedAmount = object.stakedAmount ?? "";
    message.volume = object.volume ?? "";
    return message;
  },
};

function createBaseFeeDiscountSchedule(): FeeDiscountSchedule {
  return { bucketCount: "0", bucketDuration: "0", quoteDenoms: [], tierInfos: [], disqualifiedMarketIds: [] };
}

export const FeeDiscountSchedule = {
  encode(message: FeeDiscountSchedule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bucketCount !== "0") {
      writer.uint32(8).uint64(message.bucketCount);
    }
    if (message.bucketDuration !== "0") {
      writer.uint32(16).int64(message.bucketDuration);
    }
    for (const v of message.quoteDenoms) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.tierInfos) {
      FeeDiscountTierInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.disqualifiedMarketIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountSchedule {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeDiscountSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bucketCount = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.bucketDuration = longToString(reader.int64() as Long);
          break;
        case 3:
          message.quoteDenoms.push(reader.string());
          break;
        case 4:
          message.tierInfos.push(FeeDiscountTierInfo.decode(reader, reader.uint32()));
          break;
        case 5:
          message.disqualifiedMarketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeeDiscountSchedule {
    return {
      bucketCount: isSet(object.bucketCount) ? String(object.bucketCount) : "0",
      bucketDuration: isSet(object.bucketDuration) ? String(object.bucketDuration) : "0",
      quoteDenoms: Array.isArray(object?.quoteDenoms) ? object.quoteDenoms.map((e: any) => String(e)) : [],
      tierInfos: Array.isArray(object?.tierInfos)
        ? object.tierInfos.map((e: any) => FeeDiscountTierInfo.fromJSON(e))
        : [],
      disqualifiedMarketIds: Array.isArray(object?.disqualifiedMarketIds)
        ? object.disqualifiedMarketIds.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: FeeDiscountSchedule): unknown {
    const obj: any = {};
    message.bucketCount !== undefined && (obj.bucketCount = message.bucketCount);
    message.bucketDuration !== undefined && (obj.bucketDuration = message.bucketDuration);
    if (message.quoteDenoms) {
      obj.quoteDenoms = message.quoteDenoms.map((e) => e);
    } else {
      obj.quoteDenoms = [];
    }
    if (message.tierInfos) {
      obj.tierInfos = message.tierInfos.map((e) => e ? FeeDiscountTierInfo.toJSON(e) : undefined);
    } else {
      obj.tierInfos = [];
    }
    if (message.disqualifiedMarketIds) {
      obj.disqualifiedMarketIds = message.disqualifiedMarketIds.map((e) => e);
    } else {
      obj.disqualifiedMarketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<FeeDiscountSchedule>): FeeDiscountSchedule {
    return FeeDiscountSchedule.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FeeDiscountSchedule>): FeeDiscountSchedule {
    const message = createBaseFeeDiscountSchedule();
    message.bucketCount = object.bucketCount ?? "0";
    message.bucketDuration = object.bucketDuration ?? "0";
    message.quoteDenoms = object.quoteDenoms?.map((e) => e) || [];
    message.tierInfos = object.tierInfos?.map((e) => FeeDiscountTierInfo.fromPartial(e)) || [];
    message.disqualifiedMarketIds = object.disqualifiedMarketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeeDiscountTierTTL(): FeeDiscountTierTTL {
  return { tier: "0", ttlTimestamp: "0" };
}

export const FeeDiscountTierTTL = {
  encode(message: FeeDiscountTierTTL, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tier !== "0") {
      writer.uint32(8).uint64(message.tier);
    }
    if (message.ttlTimestamp !== "0") {
      writer.uint32(16).int64(message.ttlTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountTierTTL {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeDiscountTierTTL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tier = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.ttlTimestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeeDiscountTierTTL {
    return {
      tier: isSet(object.tier) ? String(object.tier) : "0",
      ttlTimestamp: isSet(object.ttlTimestamp) ? String(object.ttlTimestamp) : "0",
    };
  },

  toJSON(message: FeeDiscountTierTTL): unknown {
    const obj: any = {};
    message.tier !== undefined && (obj.tier = message.tier);
    message.ttlTimestamp !== undefined && (obj.ttlTimestamp = message.ttlTimestamp);
    return obj;
  },

  create(base?: DeepPartial<FeeDiscountTierTTL>): FeeDiscountTierTTL {
    return FeeDiscountTierTTL.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FeeDiscountTierTTL>): FeeDiscountTierTTL {
    const message = createBaseFeeDiscountTierTTL();
    message.tier = object.tier ?? "0";
    message.ttlTimestamp = object.ttlTimestamp ?? "0";
    return message;
  },
};

function createBaseVolumeRecord(): VolumeRecord {
  return { makerVolume: "", takerVolume: "" };
}

export const VolumeRecord = {
  encode(message: VolumeRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.makerVolume !== "") {
      writer.uint32(10).string(message.makerVolume);
    }
    if (message.takerVolume !== "") {
      writer.uint32(18).string(message.takerVolume);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VolumeRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.makerVolume = reader.string();
          break;
        case 2:
          message.takerVolume = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VolumeRecord {
    return {
      makerVolume: isSet(object.makerVolume) ? String(object.makerVolume) : "",
      takerVolume: isSet(object.takerVolume) ? String(object.takerVolume) : "",
    };
  },

  toJSON(message: VolumeRecord): unknown {
    const obj: any = {};
    message.makerVolume !== undefined && (obj.makerVolume = message.makerVolume);
    message.takerVolume !== undefined && (obj.takerVolume = message.takerVolume);
    return obj;
  },

  create(base?: DeepPartial<VolumeRecord>): VolumeRecord {
    return VolumeRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<VolumeRecord>): VolumeRecord {
    const message = createBaseVolumeRecord();
    message.makerVolume = object.makerVolume ?? "";
    message.takerVolume = object.takerVolume ?? "";
    return message;
  },
};

function createBaseAccountRewards(): AccountRewards {
  return { account: "", rewards: [] };
}

export const AccountRewards = {
  encode(message: AccountRewards, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    for (const v of message.rewards) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountRewards {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRewards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        case 2:
          message.rewards.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccountRewards {
    return {
      account: isSet(object.account) ? String(object.account) : "",
      rewards: Array.isArray(object?.rewards) ? object.rewards.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: AccountRewards): unknown {
    const obj: any = {};
    message.account !== undefined && (obj.account = message.account);
    if (message.rewards) {
      obj.rewards = message.rewards.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.rewards = [];
    }
    return obj;
  },

  create(base?: DeepPartial<AccountRewards>): AccountRewards {
    return AccountRewards.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AccountRewards>): AccountRewards {
    const message = createBaseAccountRewards();
    message.account = object.account ?? "";
    message.rewards = object.rewards?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeRecords(): TradeRecords {
  return { marketId: "", latestTradeRecords: [] };
}

export const TradeRecords = {
  encode(message: TradeRecords, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    for (const v of message.latestTradeRecords) {
      TradeRecord.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeRecords {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.latestTradeRecords.push(TradeRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradeRecords {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      latestTradeRecords: Array.isArray(object?.latestTradeRecords)
        ? object.latestTradeRecords.map((e: any) => TradeRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradeRecords): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    if (message.latestTradeRecords) {
      obj.latestTradeRecords = message.latestTradeRecords.map((e) => e ? TradeRecord.toJSON(e) : undefined);
    } else {
      obj.latestTradeRecords = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradeRecords>): TradeRecords {
    return TradeRecords.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradeRecords>): TradeRecords {
    const message = createBaseTradeRecords();
    message.marketId = object.marketId ?? "";
    message.latestTradeRecords = object.latestTradeRecords?.map((e) => TradeRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubaccountIDs(): SubaccountIDs {
  return { subaccountIds: [] };
}

export const SubaccountIDs = {
  encode(message: SubaccountIDs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subaccountIds) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountIDs {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountIDs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountIds.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountIDs {
    return {
      subaccountIds: Array.isArray(object?.subaccountIds)
        ? object.subaccountIds.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SubaccountIDs): unknown {
    const obj: any = {};
    if (message.subaccountIds) {
      obj.subaccountIds = message.subaccountIds.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.subaccountIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<SubaccountIDs>): SubaccountIDs {
    return SubaccountIDs.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountIDs>): SubaccountIDs {
    const message = createBaseSubaccountIDs();
    message.subaccountIds = object.subaccountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseTradeRecord(): TradeRecord {
  return { timestamp: "0", price: "", quantity: "" };
}

export const TradeRecord = {
  encode(message: TradeRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(26).string(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = longToString(reader.int64() as Long);
          break;
        case 2:
          message.price = reader.string();
          break;
        case 3:
          message.quantity = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradeRecord {
    return {
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
    };
  },

  toJSON(message: TradeRecord): unknown {
    const obj: any = {};
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    return obj;
  },

  create(base?: DeepPartial<TradeRecord>): TradeRecord {
    return TradeRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradeRecord>): TradeRecord {
    const message = createBaseTradeRecord();
    message.timestamp = object.timestamp ?? "0";
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    return message;
  },
};

function createBaseLevel(): Level {
  return { p: "", q: "" };
}

export const Level = {
  encode(message: Level, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.p !== "") {
      writer.uint32(10).string(message.p);
    }
    if (message.q !== "") {
      writer.uint32(18).string(message.q);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Level {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.p = reader.string();
          break;
        case 2:
          message.q = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Level {
    return { p: isSet(object.p) ? String(object.p) : "", q: isSet(object.q) ? String(object.q) : "" };
  },

  toJSON(message: Level): unknown {
    const obj: any = {};
    message.p !== undefined && (obj.p = message.p);
    message.q !== undefined && (obj.q = message.q);
    return obj;
  },

  create(base?: DeepPartial<Level>): Level {
    return Level.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Level>): Level {
    const message = createBaseLevel();
    message.p = object.p ?? "";
    message.q = object.q ?? "";
    return message;
  },
};

function createBaseAggregateSubaccountVolumeRecord(): AggregateSubaccountVolumeRecord {
  return { subaccountId: "", marketVolumes: [] };
}

export const AggregateSubaccountVolumeRecord = {
  encode(message: AggregateSubaccountVolumeRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    for (const v of message.marketVolumes) {
      MarketVolume.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateSubaccountVolumeRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateSubaccountVolumeRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketVolumes.push(MarketVolume.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AggregateSubaccountVolumeRecord {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketVolumes: Array.isArray(object?.marketVolumes)
        ? object.marketVolumes.map((e: any) => MarketVolume.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateSubaccountVolumeRecord): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.marketVolumes) {
      obj.marketVolumes = message.marketVolumes.map((e) => e ? MarketVolume.toJSON(e) : undefined);
    } else {
      obj.marketVolumes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord {
    return AggregateSubaccountVolumeRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AggregateSubaccountVolumeRecord>): AggregateSubaccountVolumeRecord {
    const message = createBaseAggregateSubaccountVolumeRecord();
    message.subaccountId = object.subaccountId ?? "";
    message.marketVolumes = object.marketVolumes?.map((e) => MarketVolume.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAggregateAccountVolumeRecord(): AggregateAccountVolumeRecord {
  return { account: "", marketVolumes: [] };
}

export const AggregateAccountVolumeRecord = {
  encode(message: AggregateAccountVolumeRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    for (const v of message.marketVolumes) {
      MarketVolume.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateAccountVolumeRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateAccountVolumeRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        case 2:
          message.marketVolumes.push(MarketVolume.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AggregateAccountVolumeRecord {
    return {
      account: isSet(object.account) ? String(object.account) : "",
      marketVolumes: Array.isArray(object?.marketVolumes)
        ? object.marketVolumes.map((e: any) => MarketVolume.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateAccountVolumeRecord): unknown {
    const obj: any = {};
    message.account !== undefined && (obj.account = message.account);
    if (message.marketVolumes) {
      obj.marketVolumes = message.marketVolumes.map((e) => e ? MarketVolume.toJSON(e) : undefined);
    } else {
      obj.marketVolumes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord {
    return AggregateAccountVolumeRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<AggregateAccountVolumeRecord>): AggregateAccountVolumeRecord {
    const message = createBaseAggregateAccountVolumeRecord();
    message.account = object.account ?? "";
    message.marketVolumes = object.marketVolumes?.map((e) => MarketVolume.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarketVolume(): MarketVolume {
  return { marketId: "", volume: undefined };
}

export const MarketVolume = {
  encode(message: MarketVolume, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.volume !== undefined) {
      VolumeRecord.encode(message.volume, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketVolume {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.volume = VolumeRecord.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketVolume {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      volume: isSet(object.volume) ? VolumeRecord.fromJSON(object.volume) : undefined,
    };
  },

  toJSON(message: MarketVolume): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.volume !== undefined && (obj.volume = message.volume ? VolumeRecord.toJSON(message.volume) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MarketVolume>): MarketVolume {
    return MarketVolume.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketVolume>): MarketVolume {
    const message = createBaseMarketVolume();
    message.marketId = object.marketId ?? "";
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? VolumeRecord.fromPartial(object.volume)
      : undefined;
    return message;
  },
};

function createBaseDenomDecimals(): DenomDecimals {
  return { denom: "", decimals: "0" };
}

export const DenomDecimals = {
  encode(message: DenomDecimals, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.decimals !== "0") {
      writer.uint32(16).uint64(message.decimals);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DenomDecimals {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenomDecimals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        case 2:
          message.decimals = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DenomDecimals {
    return {
      denom: isSet(object.denom) ? String(object.denom) : "",
      decimals: isSet(object.decimals) ? String(object.decimals) : "0",
    };
  },

  toJSON(message: DenomDecimals): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    message.decimals !== undefined && (obj.decimals = message.decimals);
    return obj;
  },

  create(base?: DeepPartial<DenomDecimals>): DenomDecimals {
    return DenomDecimals.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DenomDecimals>): DenomDecimals {
    const message = createBaseDenomDecimals();
    message.denom = object.denom ?? "";
    message.decimals = object.decimals ?? "0";
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
