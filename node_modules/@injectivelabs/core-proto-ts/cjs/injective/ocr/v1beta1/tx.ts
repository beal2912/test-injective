/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { FeedConfig, Report } from "./ocr";

export interface MsgCreateFeed {
  sender: string;
  config: FeedConfig | undefined;
}

export interface MsgCreateFeedResponse {
}

export interface MsgUpdateFeed {
  sender: string;
  /** feed_id is an unique ID for the target of this config */
  feedId: string;
  /** signers ith element is address ith oracle uses to sign a report */
  signers: string[];
  /** transmitters ith element is address ith oracle uses to transmit a report via the transmit method */
  transmitters: string[];
  /** Fixed LINK reward for each observer */
  linkPerObservation: string;
  /** Fixed LINK reward for transmitter */
  linkPerTransmission: string;
  /** Native denom for LINK coin in the bank keeper */
  linkDenom: string;
  /** feed administrator */
  feedAdmin: string;
  /** feed billing administrator */
  billingAdmin: string;
}

export interface MsgUpdateFeedResponse {
}

export interface MsgTransmit {
  /** Address of the transmitter */
  transmitter: string;
  configDigest: Uint8Array;
  feedId: string;
  epoch: string;
  round: string;
  extraHash: Uint8Array;
  report: Report | undefined;
  signatures: Uint8Array[];
}

export interface MsgTransmitResponse {
}

export interface MsgFundFeedRewardPool {
  sender: string;
  feedId: string;
  amount: Coin | undefined;
}

export interface MsgFundFeedRewardPoolResponse {
}

export interface MsgWithdrawFeedRewardPool {
  sender: string;
  feedId: string;
  amount: Coin | undefined;
}

export interface MsgWithdrawFeedRewardPoolResponse {
}

export interface MsgSetPayees {
  sender: string;
  feedId: string;
  /** addresses oracles use to transmit the reports */
  transmitters: string[];
  /** addresses of payees corresponding to list of transmitters */
  payees: string[];
}

export interface MsgSetPayeesResponse {
}

export interface MsgTransferPayeeship {
  /** transmitter address of oracle whose payee is changing */
  sender: string;
  transmitter: string;
  feedId: string;
  /** new payee address */
  proposed: string;
}

export interface MsgTransferPayeeshipResponse {
}

export interface MsgAcceptPayeeship {
  /** new payee address */
  payee: string;
  /** transmitter address of oracle whose payee is changing */
  transmitter: string;
  feedId: string;
}

export interface MsgAcceptPayeeshipResponse {
}

function createBaseMsgCreateFeed(): MsgCreateFeed {
  return { sender: "", config: undefined };
}

export const MsgCreateFeed = {
  encode(message: MsgCreateFeed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.config !== undefined) {
      FeedConfig.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateFeed {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.config = FeedConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateFeed {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      config: isSet(object.config) ? FeedConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: MsgCreateFeed): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.config !== undefined && (obj.config = message.config ? FeedConfig.toJSON(message.config) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateFeed>): MsgCreateFeed {
    return MsgCreateFeed.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateFeed>): MsgCreateFeed {
    const message = createBaseMsgCreateFeed();
    message.sender = object.sender ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? FeedConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateFeedResponse(): MsgCreateFeedResponse {
  return {};
}

export const MsgCreateFeedResponse = {
  encode(_: MsgCreateFeedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateFeedResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCreateFeedResponse {
    return {};
  },

  toJSON(_: MsgCreateFeedResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCreateFeedResponse>): MsgCreateFeedResponse {
    return MsgCreateFeedResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgCreateFeedResponse>): MsgCreateFeedResponse {
    const message = createBaseMsgCreateFeedResponse();
    return message;
  },
};

function createBaseMsgUpdateFeed(): MsgUpdateFeed {
  return {
    sender: "",
    feedId: "",
    signers: [],
    transmitters: [],
    linkPerObservation: "",
    linkPerTransmission: "",
    linkDenom: "",
    feedAdmin: "",
    billingAdmin: "",
  };
}

export const MsgUpdateFeed = {
  encode(message: MsgUpdateFeed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.feedId !== "") {
      writer.uint32(18).string(message.feedId);
    }
    for (const v of message.signers) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.transmitters) {
      writer.uint32(34).string(v!);
    }
    if (message.linkPerObservation !== "") {
      writer.uint32(42).string(message.linkPerObservation);
    }
    if (message.linkPerTransmission !== "") {
      writer.uint32(50).string(message.linkPerTransmission);
    }
    if (message.linkDenom !== "") {
      writer.uint32(58).string(message.linkDenom);
    }
    if (message.feedAdmin !== "") {
      writer.uint32(66).string(message.feedAdmin);
    }
    if (message.billingAdmin !== "") {
      writer.uint32(74).string(message.billingAdmin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateFeed {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.feedId = reader.string();
          break;
        case 3:
          message.signers.push(reader.string());
          break;
        case 4:
          message.transmitters.push(reader.string());
          break;
        case 5:
          message.linkPerObservation = reader.string();
          break;
        case 6:
          message.linkPerTransmission = reader.string();
          break;
        case 7:
          message.linkDenom = reader.string();
          break;
        case 8:
          message.feedAdmin = reader.string();
          break;
        case 9:
          message.billingAdmin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateFeed {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      signers: Array.isArray(object?.signers) ? object.signers.map((e: any) => String(e)) : [],
      transmitters: Array.isArray(object?.transmitters) ? object.transmitters.map((e: any) => String(e)) : [],
      linkPerObservation: isSet(object.linkPerObservation) ? String(object.linkPerObservation) : "",
      linkPerTransmission: isSet(object.linkPerTransmission) ? String(object.linkPerTransmission) : "",
      linkDenom: isSet(object.linkDenom) ? String(object.linkDenom) : "",
      feedAdmin: isSet(object.feedAdmin) ? String(object.feedAdmin) : "",
      billingAdmin: isSet(object.billingAdmin) ? String(object.billingAdmin) : "",
    };
  },

  toJSON(message: MsgUpdateFeed): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    if (message.signers) {
      obj.signers = message.signers.map((e) => e);
    } else {
      obj.signers = [];
    }
    if (message.transmitters) {
      obj.transmitters = message.transmitters.map((e) => e);
    } else {
      obj.transmitters = [];
    }
    message.linkPerObservation !== undefined && (obj.linkPerObservation = message.linkPerObservation);
    message.linkPerTransmission !== undefined && (obj.linkPerTransmission = message.linkPerTransmission);
    message.linkDenom !== undefined && (obj.linkDenom = message.linkDenom);
    message.feedAdmin !== undefined && (obj.feedAdmin = message.feedAdmin);
    message.billingAdmin !== undefined && (obj.billingAdmin = message.billingAdmin);
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateFeed>): MsgUpdateFeed {
    return MsgUpdateFeed.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgUpdateFeed>): MsgUpdateFeed {
    const message = createBaseMsgUpdateFeed();
    message.sender = object.sender ?? "";
    message.feedId = object.feedId ?? "";
    message.signers = object.signers?.map((e) => e) || [];
    message.transmitters = object.transmitters?.map((e) => e) || [];
    message.linkPerObservation = object.linkPerObservation ?? "";
    message.linkPerTransmission = object.linkPerTransmission ?? "";
    message.linkDenom = object.linkDenom ?? "";
    message.feedAdmin = object.feedAdmin ?? "";
    message.billingAdmin = object.billingAdmin ?? "";
    return message;
  },
};

function createBaseMsgUpdateFeedResponse(): MsgUpdateFeedResponse {
  return {};
}

export const MsgUpdateFeedResponse = {
  encode(_: MsgUpdateFeedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateFeedResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFeedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateFeedResponse {
    return {};
  },

  toJSON(_: MsgUpdateFeedResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateFeedResponse>): MsgUpdateFeedResponse {
    return MsgUpdateFeedResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgUpdateFeedResponse>): MsgUpdateFeedResponse {
    const message = createBaseMsgUpdateFeedResponse();
    return message;
  },
};

function createBaseMsgTransmit(): MsgTransmit {
  return {
    transmitter: "",
    configDigest: new Uint8Array(),
    feedId: "",
    epoch: "0",
    round: "0",
    extraHash: new Uint8Array(),
    report: undefined,
    signatures: [],
  };
}

export const MsgTransmit = {
  encode(message: MsgTransmit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transmitter !== "") {
      writer.uint32(10).string(message.transmitter);
    }
    if (message.configDigest.length !== 0) {
      writer.uint32(18).bytes(message.configDigest);
    }
    if (message.feedId !== "") {
      writer.uint32(26).string(message.feedId);
    }
    if (message.epoch !== "0") {
      writer.uint32(32).uint64(message.epoch);
    }
    if (message.round !== "0") {
      writer.uint32(40).uint64(message.round);
    }
    if (message.extraHash.length !== 0) {
      writer.uint32(50).bytes(message.extraHash);
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.signatures) {
      writer.uint32(66).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransmit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransmit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.transmitter = reader.string();
          break;
        case 2:
          message.configDigest = reader.bytes();
          break;
        case 3:
          message.feedId = reader.string();
          break;
        case 4:
          message.epoch = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.round = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.extraHash = reader.bytes();
          break;
        case 7:
          message.report = Report.decode(reader, reader.uint32());
          break;
        case 8:
          message.signatures.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgTransmit {
    return {
      transmitter: isSet(object.transmitter) ? String(object.transmitter) : "",
      configDigest: isSet(object.configDigest) ? bytesFromBase64(object.configDigest) : new Uint8Array(),
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      epoch: isSet(object.epoch) ? String(object.epoch) : "0",
      round: isSet(object.round) ? String(object.round) : "0",
      extraHash: isSet(object.extraHash) ? bytesFromBase64(object.extraHash) : new Uint8Array(),
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      signatures: Array.isArray(object?.signatures) ? object.signatures.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: MsgTransmit): unknown {
    const obj: any = {};
    message.transmitter !== undefined && (obj.transmitter = message.transmitter);
    message.configDigest !== undefined &&
      (obj.configDigest = base64FromBytes(
        message.configDigest !== undefined ? message.configDigest : new Uint8Array(),
      ));
    message.feedId !== undefined && (obj.feedId = message.feedId);
    message.epoch !== undefined && (obj.epoch = message.epoch);
    message.round !== undefined && (obj.round = message.round);
    message.extraHash !== undefined &&
      (obj.extraHash = base64FromBytes(message.extraHash !== undefined ? message.extraHash : new Uint8Array()));
    message.report !== undefined && (obj.report = message.report ? Report.toJSON(message.report) : undefined);
    if (message.signatures) {
      obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.signatures = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTransmit>): MsgTransmit {
    return MsgTransmit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgTransmit>): MsgTransmit {
    const message = createBaseMsgTransmit();
    message.transmitter = object.transmitter ?? "";
    message.configDigest = object.configDigest ?? new Uint8Array();
    message.feedId = object.feedId ?? "";
    message.epoch = object.epoch ?? "0";
    message.round = object.round ?? "0";
    message.extraHash = object.extraHash ?? new Uint8Array();
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.signatures = object.signatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgTransmitResponse(): MsgTransmitResponse {
  return {};
}

export const MsgTransmitResponse = {
  encode(_: MsgTransmitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransmitResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransmitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgTransmitResponse {
    return {};
  },

  toJSON(_: MsgTransmitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTransmitResponse>): MsgTransmitResponse {
    return MsgTransmitResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgTransmitResponse>): MsgTransmitResponse {
    const message = createBaseMsgTransmitResponse();
    return message;
  },
};

function createBaseMsgFundFeedRewardPool(): MsgFundFeedRewardPool {
  return { sender: "", feedId: "", amount: undefined };
}

export const MsgFundFeedRewardPool = {
  encode(message: MsgFundFeedRewardPool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.feedId !== "") {
      writer.uint32(18).string(message.feedId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgFundFeedRewardPool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeedRewardPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.feedId = reader.string();
          break;
        case 3:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgFundFeedRewardPool {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgFundFeedRewardPool): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgFundFeedRewardPool>): MsgFundFeedRewardPool {
    return MsgFundFeedRewardPool.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgFundFeedRewardPool>): MsgFundFeedRewardPool {
    const message = createBaseMsgFundFeedRewardPool();
    message.sender = object.sender ?? "";
    message.feedId = object.feedId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgFundFeedRewardPoolResponse(): MsgFundFeedRewardPoolResponse {
  return {};
}

export const MsgFundFeedRewardPoolResponse = {
  encode(_: MsgFundFeedRewardPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgFundFeedRewardPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeedRewardPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgFundFeedRewardPoolResponse {
    return {};
  },

  toJSON(_: MsgFundFeedRewardPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgFundFeedRewardPoolResponse>): MsgFundFeedRewardPoolResponse {
    return MsgFundFeedRewardPoolResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgFundFeedRewardPoolResponse>): MsgFundFeedRewardPoolResponse {
    const message = createBaseMsgFundFeedRewardPoolResponse();
    return message;
  },
};

function createBaseMsgWithdrawFeedRewardPool(): MsgWithdrawFeedRewardPool {
  return { sender: "", feedId: "", amount: undefined };
}

export const MsgWithdrawFeedRewardPool = {
  encode(message: MsgWithdrawFeedRewardPool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.feedId !== "") {
      writer.uint32(18).string(message.feedId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawFeedRewardPool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawFeedRewardPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.feedId = reader.string();
          break;
        case 3:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawFeedRewardPool {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgWithdrawFeedRewardPool): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgWithdrawFeedRewardPool>): MsgWithdrawFeedRewardPool {
    return MsgWithdrawFeedRewardPool.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgWithdrawFeedRewardPool>): MsgWithdrawFeedRewardPool {
    const message = createBaseMsgWithdrawFeedRewardPool();
    message.sender = object.sender ?? "";
    message.feedId = object.feedId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgWithdrawFeedRewardPoolResponse(): MsgWithdrawFeedRewardPoolResponse {
  return {};
}

export const MsgWithdrawFeedRewardPoolResponse = {
  encode(_: MsgWithdrawFeedRewardPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawFeedRewardPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawFeedRewardPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawFeedRewardPoolResponse {
    return {};
  },

  toJSON(_: MsgWithdrawFeedRewardPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgWithdrawFeedRewardPoolResponse>): MsgWithdrawFeedRewardPoolResponse {
    return MsgWithdrawFeedRewardPoolResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgWithdrawFeedRewardPoolResponse>): MsgWithdrawFeedRewardPoolResponse {
    const message = createBaseMsgWithdrawFeedRewardPoolResponse();
    return message;
  },
};

function createBaseMsgSetPayees(): MsgSetPayees {
  return { sender: "", feedId: "", transmitters: [], payees: [] };
}

export const MsgSetPayees = {
  encode(message: MsgSetPayees, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.feedId !== "") {
      writer.uint32(18).string(message.feedId);
    }
    for (const v of message.transmitters) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.payees) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetPayees {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetPayees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.feedId = reader.string();
          break;
        case 3:
          message.transmitters.push(reader.string());
          break;
        case 4:
          message.payees.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSetPayees {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      transmitters: Array.isArray(object?.transmitters) ? object.transmitters.map((e: any) => String(e)) : [],
      payees: Array.isArray(object?.payees) ? object.payees.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: MsgSetPayees): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    if (message.transmitters) {
      obj.transmitters = message.transmitters.map((e) => e);
    } else {
      obj.transmitters = [];
    }
    if (message.payees) {
      obj.payees = message.payees.map((e) => e);
    } else {
      obj.payees = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgSetPayees>): MsgSetPayees {
    return MsgSetPayees.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgSetPayees>): MsgSetPayees {
    const message = createBaseMsgSetPayees();
    message.sender = object.sender ?? "";
    message.feedId = object.feedId ?? "";
    message.transmitters = object.transmitters?.map((e) => e) || [];
    message.payees = object.payees?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSetPayeesResponse(): MsgSetPayeesResponse {
  return {};
}

export const MsgSetPayeesResponse = {
  encode(_: MsgSetPayeesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetPayeesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetPayeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgSetPayeesResponse {
    return {};
  },

  toJSON(_: MsgSetPayeesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSetPayeesResponse>): MsgSetPayeesResponse {
    return MsgSetPayeesResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgSetPayeesResponse>): MsgSetPayeesResponse {
    const message = createBaseMsgSetPayeesResponse();
    return message;
  },
};

function createBaseMsgTransferPayeeship(): MsgTransferPayeeship {
  return { sender: "", transmitter: "", feedId: "", proposed: "" };
}

export const MsgTransferPayeeship = {
  encode(message: MsgTransferPayeeship, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.transmitter !== "") {
      writer.uint32(18).string(message.transmitter);
    }
    if (message.feedId !== "") {
      writer.uint32(26).string(message.feedId);
    }
    if (message.proposed !== "") {
      writer.uint32(34).string(message.proposed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferPayeeship {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferPayeeship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.transmitter = reader.string();
          break;
        case 3:
          message.feedId = reader.string();
          break;
        case 4:
          message.proposed = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgTransferPayeeship {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      transmitter: isSet(object.transmitter) ? String(object.transmitter) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      proposed: isSet(object.proposed) ? String(object.proposed) : "",
    };
  },

  toJSON(message: MsgTransferPayeeship): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.transmitter !== undefined && (obj.transmitter = message.transmitter);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    message.proposed !== undefined && (obj.proposed = message.proposed);
    return obj;
  },

  create(base?: DeepPartial<MsgTransferPayeeship>): MsgTransferPayeeship {
    return MsgTransferPayeeship.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgTransferPayeeship>): MsgTransferPayeeship {
    const message = createBaseMsgTransferPayeeship();
    message.sender = object.sender ?? "";
    message.transmitter = object.transmitter ?? "";
    message.feedId = object.feedId ?? "";
    message.proposed = object.proposed ?? "";
    return message;
  },
};

function createBaseMsgTransferPayeeshipResponse(): MsgTransferPayeeshipResponse {
  return {};
}

export const MsgTransferPayeeshipResponse = {
  encode(_: MsgTransferPayeeshipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferPayeeshipResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferPayeeshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgTransferPayeeshipResponse {
    return {};
  },

  toJSON(_: MsgTransferPayeeshipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTransferPayeeshipResponse>): MsgTransferPayeeshipResponse {
    return MsgTransferPayeeshipResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgTransferPayeeshipResponse>): MsgTransferPayeeshipResponse {
    const message = createBaseMsgTransferPayeeshipResponse();
    return message;
  },
};

function createBaseMsgAcceptPayeeship(): MsgAcceptPayeeship {
  return { payee: "", transmitter: "", feedId: "" };
}

export const MsgAcceptPayeeship = {
  encode(message: MsgAcceptPayeeship, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payee !== "") {
      writer.uint32(10).string(message.payee);
    }
    if (message.transmitter !== "") {
      writer.uint32(18).string(message.transmitter);
    }
    if (message.feedId !== "") {
      writer.uint32(26).string(message.feedId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAcceptPayeeship {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptPayeeship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.payee = reader.string();
          break;
        case 2:
          message.transmitter = reader.string();
          break;
        case 3:
          message.feedId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAcceptPayeeship {
    return {
      payee: isSet(object.payee) ? String(object.payee) : "",
      transmitter: isSet(object.transmitter) ? String(object.transmitter) : "",
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
    };
  },

  toJSON(message: MsgAcceptPayeeship): unknown {
    const obj: any = {};
    message.payee !== undefined && (obj.payee = message.payee);
    message.transmitter !== undefined && (obj.transmitter = message.transmitter);
    message.feedId !== undefined && (obj.feedId = message.feedId);
    return obj;
  },

  create(base?: DeepPartial<MsgAcceptPayeeship>): MsgAcceptPayeeship {
    return MsgAcceptPayeeship.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgAcceptPayeeship>): MsgAcceptPayeeship {
    const message = createBaseMsgAcceptPayeeship();
    message.payee = object.payee ?? "";
    message.transmitter = object.transmitter ?? "";
    message.feedId = object.feedId ?? "";
    return message;
  },
};

function createBaseMsgAcceptPayeeshipResponse(): MsgAcceptPayeeshipResponse {
  return {};
}

export const MsgAcceptPayeeshipResponse = {
  encode(_: MsgAcceptPayeeshipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAcceptPayeeshipResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptPayeeshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAcceptPayeeshipResponse {
    return {};
  },

  toJSON(_: MsgAcceptPayeeshipResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAcceptPayeeshipResponse>): MsgAcceptPayeeshipResponse {
    return MsgAcceptPayeeshipResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgAcceptPayeeshipResponse>): MsgAcceptPayeeshipResponse {
    const message = createBaseMsgAcceptPayeeshipResponse();
    return message;
  },
};

/** Msg defines the OCR Msg service. */
export interface Msg {
  /** CreateFeed defines a method for creating feed by module admin */
  CreateFeed(request: DeepPartial<MsgCreateFeed>, metadata?: grpc.Metadata): Promise<MsgCreateFeedResponse>;
  /** CreateFeed defines a method for creating feed by feed admin or feed billing admin */
  UpdateFeed(request: DeepPartial<MsgUpdateFeed>, metadata?: grpc.Metadata): Promise<MsgUpdateFeedResponse>;
  /** Transmit defines a method for transmitting the feed info by transmitter */
  Transmit(request: DeepPartial<MsgTransmit>, metadata?: grpc.Metadata): Promise<MsgTransmitResponse>;
  /** FundFeedRewardPool defines a method to put funds into feed reward pool */
  FundFeedRewardPool(
    request: DeepPartial<MsgFundFeedRewardPool>,
    metadata?: grpc.Metadata,
  ): Promise<MsgFundFeedRewardPoolResponse>;
  /** WithdrawFeedRewardPool defines a method to witdhraw feed reward by feed admin or billing admin */
  WithdrawFeedRewardPool(
    request: DeepPartial<MsgWithdrawFeedRewardPool>,
    metadata?: grpc.Metadata,
  ): Promise<MsgWithdrawFeedRewardPoolResponse>;
  /** SetPayees defines a method to set payees for transmitters (batch action) */
  SetPayees(request: DeepPartial<MsgSetPayees>, metadata?: grpc.Metadata): Promise<MsgSetPayeesResponse>;
  /** TransferPayeeship defines a method for a payee to transfer reward receive ownership */
  TransferPayeeship(
    request: DeepPartial<MsgTransferPayeeship>,
    metadata?: grpc.Metadata,
  ): Promise<MsgTransferPayeeshipResponse>;
  /** AcceptPayeeship defines a method for a new payee to accept reward receive ownership */
  AcceptPayeeship(
    request: DeepPartial<MsgAcceptPayeeship>,
    metadata?: grpc.Metadata,
  ): Promise<MsgAcceptPayeeshipResponse>;
}

export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.CreateFeed = this.CreateFeed.bind(this);
    this.UpdateFeed = this.UpdateFeed.bind(this);
    this.Transmit = this.Transmit.bind(this);
    this.FundFeedRewardPool = this.FundFeedRewardPool.bind(this);
    this.WithdrawFeedRewardPool = this.WithdrawFeedRewardPool.bind(this);
    this.SetPayees = this.SetPayees.bind(this);
    this.TransferPayeeship = this.TransferPayeeship.bind(this);
    this.AcceptPayeeship = this.AcceptPayeeship.bind(this);
  }

  CreateFeed(request: DeepPartial<MsgCreateFeed>, metadata?: grpc.Metadata): Promise<MsgCreateFeedResponse> {
    return this.rpc.unary(MsgCreateFeedDesc, MsgCreateFeed.fromPartial(request), metadata);
  }

  UpdateFeed(request: DeepPartial<MsgUpdateFeed>, metadata?: grpc.Metadata): Promise<MsgUpdateFeedResponse> {
    return this.rpc.unary(MsgUpdateFeedDesc, MsgUpdateFeed.fromPartial(request), metadata);
  }

  Transmit(request: DeepPartial<MsgTransmit>, metadata?: grpc.Metadata): Promise<MsgTransmitResponse> {
    return this.rpc.unary(MsgTransmitDesc, MsgTransmit.fromPartial(request), metadata);
  }

  FundFeedRewardPool(
    request: DeepPartial<MsgFundFeedRewardPool>,
    metadata?: grpc.Metadata,
  ): Promise<MsgFundFeedRewardPoolResponse> {
    return this.rpc.unary(MsgFundFeedRewardPoolDesc, MsgFundFeedRewardPool.fromPartial(request), metadata);
  }

  WithdrawFeedRewardPool(
    request: DeepPartial<MsgWithdrawFeedRewardPool>,
    metadata?: grpc.Metadata,
  ): Promise<MsgWithdrawFeedRewardPoolResponse> {
    return this.rpc.unary(MsgWithdrawFeedRewardPoolDesc, MsgWithdrawFeedRewardPool.fromPartial(request), metadata);
  }

  SetPayees(request: DeepPartial<MsgSetPayees>, metadata?: grpc.Metadata): Promise<MsgSetPayeesResponse> {
    return this.rpc.unary(MsgSetPayeesDesc, MsgSetPayees.fromPartial(request), metadata);
  }

  TransferPayeeship(
    request: DeepPartial<MsgTransferPayeeship>,
    metadata?: grpc.Metadata,
  ): Promise<MsgTransferPayeeshipResponse> {
    return this.rpc.unary(MsgTransferPayeeshipDesc, MsgTransferPayeeship.fromPartial(request), metadata);
  }

  AcceptPayeeship(
    request: DeepPartial<MsgAcceptPayeeship>,
    metadata?: grpc.Metadata,
  ): Promise<MsgAcceptPayeeshipResponse> {
    return this.rpc.unary(MsgAcceptPayeeshipDesc, MsgAcceptPayeeship.fromPartial(request), metadata);
  }
}

export const MsgDesc = { serviceName: "injective.ocr.v1beta1.Msg" };

export const MsgCreateFeedDesc: UnaryMethodDefinitionish = {
  methodName: "CreateFeed",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateFeed.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateFeedResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgUpdateFeedDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateFeed",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgUpdateFeed.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgUpdateFeedResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgTransmitDesc: UnaryMethodDefinitionish = {
  methodName: "Transmit",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgTransmit.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgTransmitResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgFundFeedRewardPoolDesc: UnaryMethodDefinitionish = {
  methodName: "FundFeedRewardPool",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgFundFeedRewardPool.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgFundFeedRewardPoolResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgWithdrawFeedRewardPoolDesc: UnaryMethodDefinitionish = {
  methodName: "WithdrawFeedRewardPool",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgWithdrawFeedRewardPool.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgWithdrawFeedRewardPoolResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgSetPayeesDesc: UnaryMethodDefinitionish = {
  methodName: "SetPayees",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgSetPayees.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgSetPayeesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgTransferPayeeshipDesc: UnaryMethodDefinitionish = {
  methodName: "TransferPayeeship",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgTransferPayeeship.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgTransferPayeeshipResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgAcceptPayeeshipDesc: UnaryMethodDefinitionish = {
  methodName: "AcceptPayeeship",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgAcceptPayeeship.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgAcceptPayeeshipResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
