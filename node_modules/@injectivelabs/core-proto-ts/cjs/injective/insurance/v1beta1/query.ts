/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { GenesisState } from "./genesis";
import { InsuranceFund, Params } from "./insurance";

/** QueryInsuranceParamsRequest is the request type for the Query/InsuranceParams RPC method. */
export interface QueryInsuranceParamsRequest {
}

/** QueryInsuranceParamsRequest is the response type for the Query/InsuranceParams RPC method. */
export interface QueryInsuranceParamsResponse {
  params: Params | undefined;
}

/** QueryInsuranceFundRequest is the request type for the Query/InsuranceFunds RPC method. */
export interface QueryInsuranceFundRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QueryInsuranceFundResponse is the response type for the Query/InsuranceFund RPC method. */
export interface QueryInsuranceFundResponse {
  fund: InsuranceFund | undefined;
}

/** QueryInsuranceFundsRequest is the request type for the Query/InsuranceFunds RPC method. */
export interface QueryInsuranceFundsRequest {
}

/** QueryInsuranceFundsResponse is the response type for the Query/InsuranceFunds RPC method. */
export interface QueryInsuranceFundsResponse {
  funds: InsuranceFund[];
}

/** QueryEstimatedRedemptionsRequest is the request type for the Query/EstimatedRedemptions RPC method. */
export interface QueryEstimatedRedemptionsRequest {
  marketId: string;
  address: string;
}

/** QueryEstimatedRedemptionsResponse is the response type for the Query/EstimatedRedemptions RPC method. */
export interface QueryEstimatedRedemptionsResponse {
  amount: Coin[];
}

/** QueryPendingRedemptionsRequest is the request type for the Query/PendingRedemptions RPC method. */
export interface QueryPendingRedemptionsRequest {
  marketId: string;
  address: string;
}

/** QueryPendingRedemptionsResponse is the response type for the Query/PendingRedemptions RPC method. */
export interface QueryPendingRedemptionsResponse {
  amount: Coin[];
}

/** QueryModuleStateRequest is the request type for the Query/InsuranceModuleState RPC method. */
export interface QueryModuleStateRequest {
}

/** QueryModuleStateResponse is the response type for the Query/InsuranceModuleState RPC method. */
export interface QueryModuleStateResponse {
  state: GenesisState | undefined;
}

function createBaseQueryInsuranceParamsRequest(): QueryInsuranceParamsRequest {
  return {};
}

export const QueryInsuranceParamsRequest = {
  encode(_: QueryInsuranceParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceParamsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryInsuranceParamsRequest {
    return {};
  },

  toJSON(_: QueryInsuranceParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceParamsRequest>): QueryInsuranceParamsRequest {
    return QueryInsuranceParamsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryInsuranceParamsRequest>): QueryInsuranceParamsRequest {
    const message = createBaseQueryInsuranceParamsRequest();
    return message;
  },
};

function createBaseQueryInsuranceParamsResponse(): QueryInsuranceParamsResponse {
  return { params: undefined };
}

export const QueryInsuranceParamsResponse = {
  encode(message: QueryInsuranceParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceParamsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryInsuranceParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryInsuranceParamsResponse): unknown {
    const obj: any = {};
    message.params !== undefined && (obj.params = message.params ? Params.toJSON(message.params) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceParamsResponse>): QueryInsuranceParamsResponse {
    return QueryInsuranceParamsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryInsuranceParamsResponse>): QueryInsuranceParamsResponse {
    const message = createBaseQueryInsuranceParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryInsuranceFundRequest(): QueryInsuranceFundRequest {
  return { marketId: "" };
}

export const QueryInsuranceFundRequest = {
  encode(message: QueryInsuranceFundRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceFundRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceFundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryInsuranceFundRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryInsuranceFundRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceFundRequest>): QueryInsuranceFundRequest {
    return QueryInsuranceFundRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryInsuranceFundRequest>): QueryInsuranceFundRequest {
    const message = createBaseQueryInsuranceFundRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryInsuranceFundResponse(): QueryInsuranceFundResponse {
  return { fund: undefined };
}

export const QueryInsuranceFundResponse = {
  encode(message: QueryInsuranceFundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fund !== undefined) {
      InsuranceFund.encode(message.fund, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceFundResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceFundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fund = InsuranceFund.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryInsuranceFundResponse {
    return { fund: isSet(object.fund) ? InsuranceFund.fromJSON(object.fund) : undefined };
  },

  toJSON(message: QueryInsuranceFundResponse): unknown {
    const obj: any = {};
    message.fund !== undefined && (obj.fund = message.fund ? InsuranceFund.toJSON(message.fund) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceFundResponse>): QueryInsuranceFundResponse {
    return QueryInsuranceFundResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryInsuranceFundResponse>): QueryInsuranceFundResponse {
    const message = createBaseQueryInsuranceFundResponse();
    message.fund = (object.fund !== undefined && object.fund !== null)
      ? InsuranceFund.fromPartial(object.fund)
      : undefined;
    return message;
  },
};

function createBaseQueryInsuranceFundsRequest(): QueryInsuranceFundsRequest {
  return {};
}

export const QueryInsuranceFundsRequest = {
  encode(_: QueryInsuranceFundsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceFundsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceFundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryInsuranceFundsRequest {
    return {};
  },

  toJSON(_: QueryInsuranceFundsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceFundsRequest>): QueryInsuranceFundsRequest {
    return QueryInsuranceFundsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryInsuranceFundsRequest>): QueryInsuranceFundsRequest {
    const message = createBaseQueryInsuranceFundsRequest();
    return message;
  },
};

function createBaseQueryInsuranceFundsResponse(): QueryInsuranceFundsResponse {
  return { funds: [] };
}

export const QueryInsuranceFundsResponse = {
  encode(message: QueryInsuranceFundsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.funds) {
      InsuranceFund.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryInsuranceFundsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryInsuranceFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.funds.push(InsuranceFund.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryInsuranceFundsResponse {
    return { funds: Array.isArray(object?.funds) ? object.funds.map((e: any) => InsuranceFund.fromJSON(e)) : [] };
  },

  toJSON(message: QueryInsuranceFundsResponse): unknown {
    const obj: any = {};
    if (message.funds) {
      obj.funds = message.funds.map((e) => e ? InsuranceFund.toJSON(e) : undefined);
    } else {
      obj.funds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryInsuranceFundsResponse>): QueryInsuranceFundsResponse {
    return QueryInsuranceFundsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryInsuranceFundsResponse>): QueryInsuranceFundsResponse {
    const message = createBaseQueryInsuranceFundsResponse();
    message.funds = object.funds?.map((e) => InsuranceFund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryEstimatedRedemptionsRequest(): QueryEstimatedRedemptionsRequest {
  return { marketId: "", address: "" };
}

export const QueryEstimatedRedemptionsRequest = {
  encode(message: QueryEstimatedRedemptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryEstimatedRedemptionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEstimatedRedemptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryEstimatedRedemptionsRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      address: isSet(object.address) ? String(object.address) : "",
    };
  },

  toJSON(message: QueryEstimatedRedemptionsRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.address !== undefined && (obj.address = message.address);
    return obj;
  },

  create(base?: DeepPartial<QueryEstimatedRedemptionsRequest>): QueryEstimatedRedemptionsRequest {
    return QueryEstimatedRedemptionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryEstimatedRedemptionsRequest>): QueryEstimatedRedemptionsRequest {
    const message = createBaseQueryEstimatedRedemptionsRequest();
    message.marketId = object.marketId ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryEstimatedRedemptionsResponse(): QueryEstimatedRedemptionsResponse {
  return { amount: [] };
}

export const QueryEstimatedRedemptionsResponse = {
  encode(message: QueryEstimatedRedemptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryEstimatedRedemptionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEstimatedRedemptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.amount.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryEstimatedRedemptionsResponse {
    return { amount: Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: QueryEstimatedRedemptionsResponse): unknown {
    const obj: any = {};
    if (message.amount) {
      obj.amount = message.amount.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.amount = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryEstimatedRedemptionsResponse>): QueryEstimatedRedemptionsResponse {
    return QueryEstimatedRedemptionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryEstimatedRedemptionsResponse>): QueryEstimatedRedemptionsResponse {
    const message = createBaseQueryEstimatedRedemptionsResponse();
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPendingRedemptionsRequest(): QueryPendingRedemptionsRequest {
  return { marketId: "", address: "" };
}

export const QueryPendingRedemptionsRequest = {
  encode(message: QueryPendingRedemptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPendingRedemptionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingRedemptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPendingRedemptionsRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      address: isSet(object.address) ? String(object.address) : "",
    };
  },

  toJSON(message: QueryPendingRedemptionsRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.address !== undefined && (obj.address = message.address);
    return obj;
  },

  create(base?: DeepPartial<QueryPendingRedemptionsRequest>): QueryPendingRedemptionsRequest {
    return QueryPendingRedemptionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPendingRedemptionsRequest>): QueryPendingRedemptionsRequest {
    const message = createBaseQueryPendingRedemptionsRequest();
    message.marketId = object.marketId ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryPendingRedemptionsResponse(): QueryPendingRedemptionsResponse {
  return { amount: [] };
}

export const QueryPendingRedemptionsResponse = {
  encode(message: QueryPendingRedemptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPendingRedemptionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingRedemptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.amount.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPendingRedemptionsResponse {
    return { amount: Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: QueryPendingRedemptionsResponse): unknown {
    const obj: any = {};
    if (message.amount) {
      obj.amount = message.amount.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.amount = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPendingRedemptionsResponse>): QueryPendingRedemptionsResponse {
    return QueryPendingRedemptionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPendingRedemptionsResponse>): QueryPendingRedemptionsResponse {
    const message = createBaseQueryPendingRedemptionsResponse();
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryModuleStateRequest(): QueryModuleStateRequest {
  return {};
}

export const QueryModuleStateRequest = {
  encode(_: QueryModuleStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryModuleStateRequest {
    return {};
  },

  toJSON(_: QueryModuleStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    return QueryModuleStateRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    const message = createBaseQueryModuleStateRequest();
    return message;
  },
};

function createBaseQueryModuleStateResponse(): QueryModuleStateResponse {
  return { state: undefined };
}

export const QueryModuleStateResponse = {
  encode(message: QueryModuleStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      GenesisState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = GenesisState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryModuleStateResponse {
    return { state: isSet(object.state) ? GenesisState.fromJSON(object.state) : undefined };
  },

  toJSON(message: QueryModuleStateResponse): unknown {
    const obj: any = {};
    message.state !== undefined && (obj.state = message.state ? GenesisState.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    return QueryModuleStateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    const message = createBaseQueryModuleStateResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? GenesisState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Retrieves insurance params */
  InsuranceParams(
    request: DeepPartial<QueryInsuranceParamsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceParamsResponse>;
  /** Retrieves individual insurance fund information from market id */
  InsuranceFund(
    request: DeepPartial<QueryInsuranceFundRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceFundResponse>;
  /** Retrieves all insurance funds */
  InsuranceFunds(
    request: DeepPartial<QueryInsuranceFundsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceFundsResponse>;
  /** Retrives the value of insurance fund share token at current price (not pending redemption) */
  EstimatedRedemptions(
    request: DeepPartial<QueryEstimatedRedemptionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryEstimatedRedemptionsResponse>;
  /** Retrieves pending redemptions' share token at current price */
  PendingRedemptions(
    request: DeepPartial<QueryPendingRedemptionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPendingRedemptionsResponse>;
  /** Retrieves the entire insurance module's state */
  InsuranceModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse>;
}

export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.InsuranceParams = this.InsuranceParams.bind(this);
    this.InsuranceFund = this.InsuranceFund.bind(this);
    this.InsuranceFunds = this.InsuranceFunds.bind(this);
    this.EstimatedRedemptions = this.EstimatedRedemptions.bind(this);
    this.PendingRedemptions = this.PendingRedemptions.bind(this);
    this.InsuranceModuleState = this.InsuranceModuleState.bind(this);
  }

  InsuranceParams(
    request: DeepPartial<QueryInsuranceParamsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceParamsResponse> {
    return this.rpc.unary(QueryInsuranceParamsDesc, QueryInsuranceParamsRequest.fromPartial(request), metadata);
  }

  InsuranceFund(
    request: DeepPartial<QueryInsuranceFundRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceFundResponse> {
    return this.rpc.unary(QueryInsuranceFundDesc, QueryInsuranceFundRequest.fromPartial(request), metadata);
  }

  InsuranceFunds(
    request: DeepPartial<QueryInsuranceFundsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryInsuranceFundsResponse> {
    return this.rpc.unary(QueryInsuranceFundsDesc, QueryInsuranceFundsRequest.fromPartial(request), metadata);
  }

  EstimatedRedemptions(
    request: DeepPartial<QueryEstimatedRedemptionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryEstimatedRedemptionsResponse> {
    return this.rpc.unary(
      QueryEstimatedRedemptionsDesc,
      QueryEstimatedRedemptionsRequest.fromPartial(request),
      metadata,
    );
  }

  PendingRedemptions(
    request: DeepPartial<QueryPendingRedemptionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPendingRedemptionsResponse> {
    return this.rpc.unary(QueryPendingRedemptionsDesc, QueryPendingRedemptionsRequest.fromPartial(request), metadata);
  }

  InsuranceModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse> {
    return this.rpc.unary(QueryInsuranceModuleStateDesc, QueryModuleStateRequest.fromPartial(request), metadata);
  }
}

export const QueryDesc = { serviceName: "injective.insurance.v1beta1.Query" };

export const QueryInsuranceParamsDesc: UnaryMethodDefinitionish = {
  methodName: "InsuranceParams",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryInsuranceParamsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryInsuranceParamsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryInsuranceFundDesc: UnaryMethodDefinitionish = {
  methodName: "InsuranceFund",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryInsuranceFundRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryInsuranceFundResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryInsuranceFundsDesc: UnaryMethodDefinitionish = {
  methodName: "InsuranceFunds",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryInsuranceFundsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryInsuranceFundsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryEstimatedRedemptionsDesc: UnaryMethodDefinitionish = {
  methodName: "EstimatedRedemptions",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryEstimatedRedemptionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryEstimatedRedemptionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPendingRedemptionsDesc: UnaryMethodDefinitionish = {
  methodName: "PendingRedemptions",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPendingRedemptionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPendingRedemptionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryInsuranceModuleStateDesc: UnaryMethodDefinitionish = {
  methodName: "InsuranceModuleState",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryModuleStateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryModuleStateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
