/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export enum OracleType {
  Unspecified = 0,
  Band = 1,
  PriceFeed = 2,
  Coinbase = 3,
  Chainlink = 4,
  Razor = 5,
  Dia = 6,
  API3 = 7,
  Uma = 8,
  Pyth = 9,
  BandIBC = 10,
  Provider = 11,
  UNRECOGNIZED = -1,
}

export function oracleTypeFromJSON(object: any): OracleType {
  switch (object) {
    case 0:
    case "Unspecified":
      return OracleType.Unspecified;
    case 1:
    case "Band":
      return OracleType.Band;
    case 2:
    case "PriceFeed":
      return OracleType.PriceFeed;
    case 3:
    case "Coinbase":
      return OracleType.Coinbase;
    case 4:
    case "Chainlink":
      return OracleType.Chainlink;
    case 5:
    case "Razor":
      return OracleType.Razor;
    case 6:
    case "Dia":
      return OracleType.Dia;
    case 7:
    case "API3":
      return OracleType.API3;
    case 8:
    case "Uma":
      return OracleType.Uma;
    case 9:
    case "Pyth":
      return OracleType.Pyth;
    case 10:
    case "BandIBC":
      return OracleType.BandIBC;
    case 11:
    case "Provider":
      return OracleType.Provider;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OracleType.UNRECOGNIZED;
  }
}

export function oracleTypeToJSON(object: OracleType): string {
  switch (object) {
    case OracleType.Unspecified:
      return "Unspecified";
    case OracleType.Band:
      return "Band";
    case OracleType.PriceFeed:
      return "PriceFeed";
    case OracleType.Coinbase:
      return "Coinbase";
    case OracleType.Chainlink:
      return "Chainlink";
    case OracleType.Razor:
      return "Razor";
    case OracleType.Dia:
      return "Dia";
    case OracleType.API3:
      return "API3";
    case OracleType.Uma:
      return "Uma";
    case OracleType.Pyth:
      return "Pyth";
    case OracleType.BandIBC:
      return "BandIBC";
    case OracleType.Provider:
      return "Provider";
    case OracleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PythStatus {
  /** Unknown - The price feed is not currently updating for an unknown reason. */
  Unknown = 0,
  /** Trading - The price feed is updating as expected. */
  Trading = 1,
  /** Halted - The price feed is not currently updating because trading in the product has been halted. */
  Halted = 2,
  /** Auction - The price feed is not currently updating because an auction is setting the price. */
  Auction = 3,
  UNRECOGNIZED = -1,
}

export function pythStatusFromJSON(object: any): PythStatus {
  switch (object) {
    case 0:
    case "Unknown":
      return PythStatus.Unknown;
    case 1:
    case "Trading":
      return PythStatus.Trading;
    case 2:
    case "Halted":
      return PythStatus.Halted;
    case 3:
    case "Auction":
      return PythStatus.Auction;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PythStatus.UNRECOGNIZED;
  }
}

export function pythStatusToJSON(object: PythStatus): string {
  switch (object) {
    case PythStatus.Unknown:
      return "Unknown";
    case PythStatus.Trading:
      return "Trading";
    case PythStatus.Halted:
      return "Halted";
    case PythStatus.Auction:
      return "Auction";
    case PythStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Params {
  pythContract: string;
}

export interface OracleInfo {
  symbol: string;
  oracleType: OracleType;
  scaleFactor: number;
}

export interface ChainlinkPriceState {
  feedId: string;
  answer: string;
  timestamp: string;
  priceState: PriceState | undefined;
}

export interface BandPriceState {
  symbol: string;
  rate: string;
  resolveTime: string;
  requestID: string;
  priceState: PriceState | undefined;
}

export interface PriceFeedState {
  base: string;
  quote: string;
  priceState: PriceState | undefined;
  relayers: string[];
}

export interface ProviderInfo {
  provider: string;
  relayers: string[];
}

export interface ProviderState {
  providerInfo: ProviderInfo | undefined;
  providerPriceStates: ProviderPriceState[];
}

export interface ProviderPriceState {
  symbol: string;
  state: PriceState | undefined;
}

export interface PriceFeedInfo {
  base: string;
  quote: string;
}

export interface PriceFeedPrice {
  price: string;
}

export interface CoinbasePriceState {
  /** kind should always be "prices" */
  kind: string;
  /** timestamp of the when the price was signed by coinbase */
  timestamp: string;
  /** the symbol of the price, e.g. BTC */
  key: string;
  /** the value of the price scaled by 1e6 */
  value: string;
  /** the price state */
  priceState: PriceState | undefined;
}

export interface PriceState {
  price: string;
  cumulativePrice: string;
  timestamp: string;
}

export interface PythPriceState {
  priceId: string;
  emaPrice: string;
  emaConf: string;
  conf: string;
  publishTime: string;
  priceState: PriceState | undefined;
}

export interface BandOracleRequest {
  /** Unique Identifier for band ibc oracle request */
  requestId: string;
  /** OracleScriptID is the unique identifier of the oracle script to be executed. */
  oracleScriptId: string;
  /** Symbols is the list of symbols to prepare in the calldata */
  symbols: string[];
  /**
   * AskCount is the number of validators that are requested to respond to this
   * oracle request. Higher value means more security, at a higher gas cost.
   */
  askCount: string;
  /**
   * MinCount is the minimum number of validators necessary for the request to
   * proceed to the execution phase. Higher value means more security, at the
   * cost of liveness.
   */
  minCount: string;
  /** FeeLimit is the maximum tokens that will be paid to all data source providers. */
  feeLimit: Coin[];
  /** PrepareGas is amount of gas to pay to prepare raw requests */
  prepareGas: string;
  /** ExecuteGas is amount of gas to reserve for executing */
  executeGas: string;
}

export interface BandIBCParams {
  /** true if Band IBC should be enabled */
  bandIbcEnabled: boolean;
  /** block request interval to send Band IBC prices */
  ibcRequestInterval: string;
  /** band IBC source channel */
  ibcSourceChannel: string;
  /** band IBC version */
  ibcVersion: string;
  /** band IBC portID */
  ibcPortId: string;
  /** legacy oracle scheme ids */
  legacyOracleIds: string[];
}

export interface SymbolPriceTimestamp {
  oracle: OracleType;
  symbolId: string;
  timestamp: string;
}

export interface LastPriceTimestamps {
  lastPriceTimestamps: SymbolPriceTimestamp[];
}

export interface PriceRecords {
  oracle: OracleType;
  symbolId: string;
  latestPriceRecords: PriceRecord[];
}

export interface PriceRecord {
  timestamp: string;
  price: string;
}

/** MetadataStatistics refers to the metadata summary statistics of the historical sample considered */
export interface MetadataStatistics {
  /** GroupCount refers to the number of groups used. Equals RecordsSampleSize if no grouping is used */
  groupCount: number;
  /** RecordsSampleSize refers to the total number of records used. */
  recordsSampleSize: number;
  /**
   * Mean refers to the arithmetic mean
   * For trades, the mean is the VWAP computed over the grouped trade records ∑ (price * quantity) / ∑ quantity
   * For oracle prices, the mean is computed over the price records ∑ (price) / prices_count
   */
  mean: string;
  /** TWAP refers to the time-weighted average price which equals ∑ (price_i * ∆t_i) / ∑ ∆t_i where ∆t_i = t_i - t_{i-1} */
  twap: string;
  /** FirstTimestamp is the timestamp of the oldest record considered */
  firstTimestamp: string;
  /** LastTimestamp is the timestamp of the youngest record considered */
  lastTimestamp: string;
  /** MinPrice refers to the smallest individual raw price considered */
  minPrice: string;
  /** MaxPrice refers to the largest individual raw price considered */
  maxPrice: string;
  /** MedianPrice refers to the median individual raw price considered */
  medianPrice: string;
}

export interface PriceAttestation {
  productId: string;
  priceId: Uint8Array;
  /** MaxPrice refers to the largest individual raw price considered */
  price: string;
  conf: string;
  expo: number;
  emaPrice: string;
  emaConf: string;
  status: PythStatus;
  numPublishers: number;
  maxNumPublishers: number;
  attestationTime: string;
  publishTime: string;
}

function createBaseParams(): Params {
  return { pythContract: "" };
}

export const Params = {
  encode(message: Params, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pythContract !== "") {
      writer.uint32(10).string(message.pythContract);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Params {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pythContract = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Params {
    return { pythContract: isSet(object.pythContract) ? String(object.pythContract) : "" };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    message.pythContract !== undefined && (obj.pythContract = message.pythContract);
    return obj;
  },

  create(base?: DeepPartial<Params>): Params {
    return Params.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.pythContract = object.pythContract ?? "";
    return message;
  },
};

function createBaseOracleInfo(): OracleInfo {
  return { symbol: "", oracleType: 0, scaleFactor: 0 };
}

export const OracleInfo = {
  encode(message: OracleInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.oracleType !== 0) {
      writer.uint32(16).int32(message.oracleType);
    }
    if (message.scaleFactor !== 0) {
      writer.uint32(24).uint32(message.scaleFactor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OracleInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.symbol = reader.string();
          break;
        case 2:
          message.oracleType = reader.int32() as any;
          break;
        case 3:
          message.scaleFactor = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OracleInfo {
    return {
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      scaleFactor: isSet(object.scaleFactor) ? Number(object.scaleFactor) : 0,
    };
  },

  toJSON(message: OracleInfo): unknown {
    const obj: any = {};
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.scaleFactor !== undefined && (obj.scaleFactor = Math.round(message.scaleFactor));
    return obj;
  },

  create(base?: DeepPartial<OracleInfo>): OracleInfo {
    return OracleInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OracleInfo>): OracleInfo {
    const message = createBaseOracleInfo();
    message.symbol = object.symbol ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.scaleFactor = object.scaleFactor ?? 0;
    return message;
  },
};

function createBaseChainlinkPriceState(): ChainlinkPriceState {
  return { feedId: "", answer: "", timestamp: "0", priceState: undefined };
}

export const ChainlinkPriceState = {
  encode(message: ChainlinkPriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feedId !== "") {
      writer.uint32(10).string(message.feedId);
    }
    if (message.answer !== "") {
      writer.uint32(18).string(message.answer);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).uint64(message.timestamp);
    }
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainlinkPriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainlinkPriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feedId = reader.string();
          break;
        case 2:
          message.answer = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChainlinkPriceState {
    return {
      feedId: isSet(object.feedId) ? String(object.feedId) : "",
      answer: isSet(object.answer) ? String(object.answer) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined,
    };
  },

  toJSON(message: ChainlinkPriceState): unknown {
    const obj: any = {};
    message.feedId !== undefined && (obj.feedId = message.feedId);
    message.answer !== undefined && (obj.answer = message.answer);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<ChainlinkPriceState>): ChainlinkPriceState {
    return ChainlinkPriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ChainlinkPriceState>): ChainlinkPriceState {
    const message = createBaseChainlinkPriceState();
    message.feedId = object.feedId ?? "";
    message.answer = object.answer ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBaseBandPriceState(): BandPriceState {
  return { symbol: "", rate: "", resolveTime: "0", requestID: "0", priceState: undefined };
}

export const BandPriceState = {
  encode(message: BandPriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.rate !== "") {
      writer.uint32(18).string(message.rate);
    }
    if (message.resolveTime !== "0") {
      writer.uint32(24).uint64(message.resolveTime);
    }
    if (message.requestID !== "0") {
      writer.uint32(32).uint64(message.requestID);
    }
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BandPriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBandPriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.symbol = reader.string();
          break;
        case 2:
          message.rate = reader.string();
          break;
        case 3:
          message.resolveTime = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.requestID = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BandPriceState {
    return {
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      rate: isSet(object.rate) ? String(object.rate) : "",
      resolveTime: isSet(object.resolveTime) ? String(object.resolveTime) : "0",
      requestID: isSet(object.requestID) ? String(object.requestID) : "0",
      priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined,
    };
  },

  toJSON(message: BandPriceState): unknown {
    const obj: any = {};
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.rate !== undefined && (obj.rate = message.rate);
    message.resolveTime !== undefined && (obj.resolveTime = message.resolveTime);
    message.requestID !== undefined && (obj.requestID = message.requestID);
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<BandPriceState>): BandPriceState {
    return BandPriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BandPriceState>): BandPriceState {
    const message = createBaseBandPriceState();
    message.symbol = object.symbol ?? "";
    message.rate = object.rate ?? "";
    message.resolveTime = object.resolveTime ?? "0";
    message.requestID = object.requestID ?? "0";
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBasePriceFeedState(): PriceFeedState {
  return { base: "", quote: "", priceState: undefined, relayers: [] };
}

export const PriceFeedState = {
  encode(message: PriceFeedState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== "") {
      writer.uint32(10).string(message.base);
    }
    if (message.quote !== "") {
      writer.uint32(18).string(message.quote);
    }
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.relayers) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceFeedState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceFeedState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.base = reader.string();
          break;
        case 2:
          message.quote = reader.string();
          break;
        case 3:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        case 4:
          message.relayers.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceFeedState {
    return {
      base: isSet(object.base) ? String(object.base) : "",
      quote: isSet(object.quote) ? String(object.quote) : "",
      priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined,
      relayers: Array.isArray(object?.relayers) ? object.relayers.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: PriceFeedState): unknown {
    const obj: any = {};
    message.base !== undefined && (obj.base = message.base);
    message.quote !== undefined && (obj.quote = message.quote);
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    if (message.relayers) {
      obj.relayers = message.relayers.map((e) => e);
    } else {
      obj.relayers = [];
    }
    return obj;
  },

  create(base?: DeepPartial<PriceFeedState>): PriceFeedState {
    return PriceFeedState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceFeedState>): PriceFeedState {
    const message = createBasePriceFeedState();
    message.base = object.base ?? "";
    message.quote = object.quote ?? "";
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    message.relayers = object.relayers?.map((e) => e) || [];
    return message;
  },
};

function createBaseProviderInfo(): ProviderInfo {
  return { provider: "", relayers: [] };
}

export const ProviderInfo = {
  encode(message: ProviderInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    for (const v of message.relayers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.provider = reader.string();
          break;
        case 2:
          message.relayers.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProviderInfo {
    return {
      provider: isSet(object.provider) ? String(object.provider) : "",
      relayers: Array.isArray(object?.relayers) ? object.relayers.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: ProviderInfo): unknown {
    const obj: any = {};
    message.provider !== undefined && (obj.provider = message.provider);
    if (message.relayers) {
      obj.relayers = message.relayers.map((e) => e);
    } else {
      obj.relayers = [];
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderInfo>): ProviderInfo {
    return ProviderInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ProviderInfo>): ProviderInfo {
    const message = createBaseProviderInfo();
    message.provider = object.provider ?? "";
    message.relayers = object.relayers?.map((e) => e) || [];
    return message;
  },
};

function createBaseProviderState(): ProviderState {
  return { providerInfo: undefined, providerPriceStates: [] };
}

export const ProviderState = {
  encode(message: ProviderState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.providerInfo !== undefined) {
      ProviderInfo.encode(message.providerInfo, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.providerPriceStates) {
      ProviderPriceState.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.providerInfo = ProviderInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.providerPriceStates.push(ProviderPriceState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProviderState {
    return {
      providerInfo: isSet(object.providerInfo) ? ProviderInfo.fromJSON(object.providerInfo) : undefined,
      providerPriceStates: Array.isArray(object?.providerPriceStates)
        ? object.providerPriceStates.map((e: any) => ProviderPriceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProviderState): unknown {
    const obj: any = {};
    message.providerInfo !== undefined &&
      (obj.providerInfo = message.providerInfo ? ProviderInfo.toJSON(message.providerInfo) : undefined);
    if (message.providerPriceStates) {
      obj.providerPriceStates = message.providerPriceStates.map((e) => e ? ProviderPriceState.toJSON(e) : undefined);
    } else {
      obj.providerPriceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderState>): ProviderState {
    return ProviderState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ProviderState>): ProviderState {
    const message = createBaseProviderState();
    message.providerInfo = (object.providerInfo !== undefined && object.providerInfo !== null)
      ? ProviderInfo.fromPartial(object.providerInfo)
      : undefined;
    message.providerPriceStates = object.providerPriceStates?.map((e) => ProviderPriceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProviderPriceState(): ProviderPriceState {
  return { symbol: "", state: undefined };
}

export const ProviderPriceState = {
  encode(message: ProviderPriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.state !== undefined) {
      PriceState.encode(message.state, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderPriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderPriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.symbol = reader.string();
          break;
        case 2:
          message.state = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProviderPriceState {
    return {
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      state: isSet(object.state) ? PriceState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ProviderPriceState): unknown {
    const obj: any = {};
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.state !== undefined && (obj.state = message.state ? PriceState.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<ProviderPriceState>): ProviderPriceState {
    return ProviderPriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ProviderPriceState>): ProviderPriceState {
    const message = createBaseProviderPriceState();
    message.symbol = object.symbol ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? PriceState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBasePriceFeedInfo(): PriceFeedInfo {
  return { base: "", quote: "" };
}

export const PriceFeedInfo = {
  encode(message: PriceFeedInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== "") {
      writer.uint32(10).string(message.base);
    }
    if (message.quote !== "") {
      writer.uint32(18).string(message.quote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceFeedInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceFeedInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.base = reader.string();
          break;
        case 2:
          message.quote = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceFeedInfo {
    return {
      base: isSet(object.base) ? String(object.base) : "",
      quote: isSet(object.quote) ? String(object.quote) : "",
    };
  },

  toJSON(message: PriceFeedInfo): unknown {
    const obj: any = {};
    message.base !== undefined && (obj.base = message.base);
    message.quote !== undefined && (obj.quote = message.quote);
    return obj;
  },

  create(base?: DeepPartial<PriceFeedInfo>): PriceFeedInfo {
    return PriceFeedInfo.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceFeedInfo>): PriceFeedInfo {
    const message = createBasePriceFeedInfo();
    message.base = object.base ?? "";
    message.quote = object.quote ?? "";
    return message;
  },
};

function createBasePriceFeedPrice(): PriceFeedPrice {
  return { price: "" };
}

export const PriceFeedPrice = {
  encode(message: PriceFeedPrice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceFeedPrice {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceFeedPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceFeedPrice {
    return { price: isSet(object.price) ? String(object.price) : "" };
  },

  toJSON(message: PriceFeedPrice): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    return obj;
  },

  create(base?: DeepPartial<PriceFeedPrice>): PriceFeedPrice {
    return PriceFeedPrice.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceFeedPrice>): PriceFeedPrice {
    const message = createBasePriceFeedPrice();
    message.price = object.price ?? "";
    return message;
  },
};

function createBaseCoinbasePriceState(): CoinbasePriceState {
  return { kind: "", timestamp: "0", key: "", value: "0", priceState: undefined };
}

export const CoinbasePriceState = {
  encode(message: CoinbasePriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).uint64(message.timestamp);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.value !== "0") {
      writer.uint32(32).uint64(message.value);
    }
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CoinbasePriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinbasePriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.string();
          break;
        case 2:
          message.timestamp = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.key = reader.string();
          break;
        case 4:
          message.value = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CoinbasePriceState {
    return {
      kind: isSet(object.kind) ? String(object.kind) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? String(object.value) : "0",
      priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined,
    };
  },

  toJSON(message: CoinbasePriceState): unknown {
    const obj: any = {};
    message.kind !== undefined && (obj.kind = message.kind);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<CoinbasePriceState>): CoinbasePriceState {
    return CoinbasePriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<CoinbasePriceState>): CoinbasePriceState {
    const message = createBaseCoinbasePriceState();
    message.kind = object.kind ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.key = object.key ?? "";
    message.value = object.value ?? "0";
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBasePriceState(): PriceState {
  return { price: "", cumulativePrice: "", timestamp: "0" };
}

export const PriceState = {
  encode(message: PriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.cumulativePrice !== "") {
      writer.uint32(18).string(message.cumulativePrice);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.cumulativePrice = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceState {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      cumulativePrice: isSet(object.cumulativePrice) ? String(object.cumulativePrice) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: PriceState): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.cumulativePrice !== undefined && (obj.cumulativePrice = message.cumulativePrice);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<PriceState>): PriceState {
    return PriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceState>): PriceState {
    const message = createBasePriceState();
    message.price = object.price ?? "";
    message.cumulativePrice = object.cumulativePrice ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBasePythPriceState(): PythPriceState {
  return { priceId: "", emaPrice: "", emaConf: "", conf: "", publishTime: "0", priceState: undefined };
}

export const PythPriceState = {
  encode(message: PythPriceState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceId !== "") {
      writer.uint32(10).string(message.priceId);
    }
    if (message.emaPrice !== "") {
      writer.uint32(18).string(message.emaPrice);
    }
    if (message.emaConf !== "") {
      writer.uint32(26).string(message.emaConf);
    }
    if (message.conf !== "") {
      writer.uint32(34).string(message.conf);
    }
    if (message.publishTime !== "0") {
      writer.uint32(40).uint64(message.publishTime);
    }
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PythPriceState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePythPriceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceId = reader.string();
          break;
        case 2:
          message.emaPrice = reader.string();
          break;
        case 3:
          message.emaConf = reader.string();
          break;
        case 4:
          message.conf = reader.string();
          break;
        case 5:
          message.publishTime = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PythPriceState {
    return {
      priceId: isSet(object.priceId) ? String(object.priceId) : "",
      emaPrice: isSet(object.emaPrice) ? String(object.emaPrice) : "",
      emaConf: isSet(object.emaConf) ? String(object.emaConf) : "",
      conf: isSet(object.conf) ? String(object.conf) : "",
      publishTime: isSet(object.publishTime) ? String(object.publishTime) : "0",
      priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined,
    };
  },

  toJSON(message: PythPriceState): unknown {
    const obj: any = {};
    message.priceId !== undefined && (obj.priceId = message.priceId);
    message.emaPrice !== undefined && (obj.emaPrice = message.emaPrice);
    message.emaConf !== undefined && (obj.emaConf = message.emaConf);
    message.conf !== undefined && (obj.conf = message.conf);
    message.publishTime !== undefined && (obj.publishTime = message.publishTime);
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<PythPriceState>): PythPriceState {
    return PythPriceState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PythPriceState>): PythPriceState {
    const message = createBasePythPriceState();
    message.priceId = object.priceId ?? "";
    message.emaPrice = object.emaPrice ?? "";
    message.emaConf = object.emaConf ?? "";
    message.conf = object.conf ?? "";
    message.publishTime = object.publishTime ?? "0";
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBaseBandOracleRequest(): BandOracleRequest {
  return {
    requestId: "0",
    oracleScriptId: "0",
    symbols: [],
    askCount: "0",
    minCount: "0",
    feeLimit: [],
    prepareGas: "0",
    executeGas: "0",
  };
}

export const BandOracleRequest = {
  encode(message: BandOracleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "0") {
      writer.uint32(8).uint64(message.requestId);
    }
    if (message.oracleScriptId !== "0") {
      writer.uint32(16).int64(message.oracleScriptId);
    }
    for (const v of message.symbols) {
      writer.uint32(26).string(v!);
    }
    if (message.askCount !== "0") {
      writer.uint32(32).uint64(message.askCount);
    }
    if (message.minCount !== "0") {
      writer.uint32(40).uint64(message.minCount);
    }
    for (const v of message.feeLimit) {
      Coin.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.prepareGas !== "0") {
      writer.uint32(56).uint64(message.prepareGas);
    }
    if (message.executeGas !== "0") {
      writer.uint32(64).uint64(message.executeGas);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BandOracleRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBandOracleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.requestId = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.oracleScriptId = longToString(reader.int64() as Long);
          break;
        case 3:
          message.symbols.push(reader.string());
          break;
        case 4:
          message.askCount = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.minCount = longToString(reader.uint64() as Long);
          break;
        case 6:
          message.feeLimit.push(Coin.decode(reader, reader.uint32()));
          break;
        case 7:
          message.prepareGas = longToString(reader.uint64() as Long);
          break;
        case 8:
          message.executeGas = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BandOracleRequest {
    return {
      requestId: isSet(object.requestId) ? String(object.requestId) : "0",
      oracleScriptId: isSet(object.oracleScriptId) ? String(object.oracleScriptId) : "0",
      symbols: Array.isArray(object?.symbols) ? object.symbols.map((e: any) => String(e)) : [],
      askCount: isSet(object.askCount) ? String(object.askCount) : "0",
      minCount: isSet(object.minCount) ? String(object.minCount) : "0",
      feeLimit: Array.isArray(object?.feeLimit) ? object.feeLimit.map((e: any) => Coin.fromJSON(e)) : [],
      prepareGas: isSet(object.prepareGas) ? String(object.prepareGas) : "0",
      executeGas: isSet(object.executeGas) ? String(object.executeGas) : "0",
    };
  },

  toJSON(message: BandOracleRequest): unknown {
    const obj: any = {};
    message.requestId !== undefined && (obj.requestId = message.requestId);
    message.oracleScriptId !== undefined && (obj.oracleScriptId = message.oracleScriptId);
    if (message.symbols) {
      obj.symbols = message.symbols.map((e) => e);
    } else {
      obj.symbols = [];
    }
    message.askCount !== undefined && (obj.askCount = message.askCount);
    message.minCount !== undefined && (obj.minCount = message.minCount);
    if (message.feeLimit) {
      obj.feeLimit = message.feeLimit.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.feeLimit = [];
    }
    message.prepareGas !== undefined && (obj.prepareGas = message.prepareGas);
    message.executeGas !== undefined && (obj.executeGas = message.executeGas);
    return obj;
  },

  create(base?: DeepPartial<BandOracleRequest>): BandOracleRequest {
    return BandOracleRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BandOracleRequest>): BandOracleRequest {
    const message = createBaseBandOracleRequest();
    message.requestId = object.requestId ?? "0";
    message.oracleScriptId = object.oracleScriptId ?? "0";
    message.symbols = object.symbols?.map((e) => e) || [];
    message.askCount = object.askCount ?? "0";
    message.minCount = object.minCount ?? "0";
    message.feeLimit = object.feeLimit?.map((e) => Coin.fromPartial(e)) || [];
    message.prepareGas = object.prepareGas ?? "0";
    message.executeGas = object.executeGas ?? "0";
    return message;
  },
};

function createBaseBandIBCParams(): BandIBCParams {
  return {
    bandIbcEnabled: false,
    ibcRequestInterval: "0",
    ibcSourceChannel: "",
    ibcVersion: "",
    ibcPortId: "",
    legacyOracleIds: [],
  };
}

export const BandIBCParams = {
  encode(message: BandIBCParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bandIbcEnabled === true) {
      writer.uint32(8).bool(message.bandIbcEnabled);
    }
    if (message.ibcRequestInterval !== "0") {
      writer.uint32(16).int64(message.ibcRequestInterval);
    }
    if (message.ibcSourceChannel !== "") {
      writer.uint32(26).string(message.ibcSourceChannel);
    }
    if (message.ibcVersion !== "") {
      writer.uint32(34).string(message.ibcVersion);
    }
    if (message.ibcPortId !== "") {
      writer.uint32(42).string(message.ibcPortId);
    }
    writer.uint32(50).fork();
    for (const v of message.legacyOracleIds) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BandIBCParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBandIBCParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bandIbcEnabled = reader.bool();
          break;
        case 2:
          message.ibcRequestInterval = longToString(reader.int64() as Long);
          break;
        case 3:
          message.ibcSourceChannel = reader.string();
          break;
        case 4:
          message.ibcVersion = reader.string();
          break;
        case 5:
          message.ibcPortId = reader.string();
          break;
        case 6:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.legacyOracleIds.push(longToString(reader.int64() as Long));
            }
          } else {
            message.legacyOracleIds.push(longToString(reader.int64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BandIBCParams {
    return {
      bandIbcEnabled: isSet(object.bandIbcEnabled) ? Boolean(object.bandIbcEnabled) : false,
      ibcRequestInterval: isSet(object.ibcRequestInterval) ? String(object.ibcRequestInterval) : "0",
      ibcSourceChannel: isSet(object.ibcSourceChannel) ? String(object.ibcSourceChannel) : "",
      ibcVersion: isSet(object.ibcVersion) ? String(object.ibcVersion) : "",
      ibcPortId: isSet(object.ibcPortId) ? String(object.ibcPortId) : "",
      legacyOracleIds: Array.isArray(object?.legacyOracleIds) ? object.legacyOracleIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: BandIBCParams): unknown {
    const obj: any = {};
    message.bandIbcEnabled !== undefined && (obj.bandIbcEnabled = message.bandIbcEnabled);
    message.ibcRequestInterval !== undefined && (obj.ibcRequestInterval = message.ibcRequestInterval);
    message.ibcSourceChannel !== undefined && (obj.ibcSourceChannel = message.ibcSourceChannel);
    message.ibcVersion !== undefined && (obj.ibcVersion = message.ibcVersion);
    message.ibcPortId !== undefined && (obj.ibcPortId = message.ibcPortId);
    if (message.legacyOracleIds) {
      obj.legacyOracleIds = message.legacyOracleIds.map((e) => e);
    } else {
      obj.legacyOracleIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<BandIBCParams>): BandIBCParams {
    return BandIBCParams.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BandIBCParams>): BandIBCParams {
    const message = createBaseBandIBCParams();
    message.bandIbcEnabled = object.bandIbcEnabled ?? false;
    message.ibcRequestInterval = object.ibcRequestInterval ?? "0";
    message.ibcSourceChannel = object.ibcSourceChannel ?? "";
    message.ibcVersion = object.ibcVersion ?? "";
    message.ibcPortId = object.ibcPortId ?? "";
    message.legacyOracleIds = object.legacyOracleIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseSymbolPriceTimestamp(): SymbolPriceTimestamp {
  return { oracle: 0, symbolId: "", timestamp: "0" };
}

export const SymbolPriceTimestamp = {
  encode(message: SymbolPriceTimestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oracle !== 0) {
      writer.uint32(8).int32(message.oracle);
    }
    if (message.symbolId !== "") {
      writer.uint32(18).string(message.symbolId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SymbolPriceTimestamp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSymbolPriceTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oracle = reader.int32() as any;
          break;
        case 2:
          message.symbolId = reader.string();
          break;
        case 3:
          message.timestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SymbolPriceTimestamp {
    return {
      oracle: isSet(object.oracle) ? oracleTypeFromJSON(object.oracle) : 0,
      symbolId: isSet(object.symbolId) ? String(object.symbolId) : "",
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
    };
  },

  toJSON(message: SymbolPriceTimestamp): unknown {
    const obj: any = {};
    message.oracle !== undefined && (obj.oracle = oracleTypeToJSON(message.oracle));
    message.symbolId !== undefined && (obj.symbolId = message.symbolId);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    return obj;
  },

  create(base?: DeepPartial<SymbolPriceTimestamp>): SymbolPriceTimestamp {
    return SymbolPriceTimestamp.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SymbolPriceTimestamp>): SymbolPriceTimestamp {
    const message = createBaseSymbolPriceTimestamp();
    message.oracle = object.oracle ?? 0;
    message.symbolId = object.symbolId ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseLastPriceTimestamps(): LastPriceTimestamps {
  return { lastPriceTimestamps: [] };
}

export const LastPriceTimestamps = {
  encode(message: LastPriceTimestamps, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lastPriceTimestamps) {
      SymbolPriceTimestamp.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LastPriceTimestamps {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPriceTimestamps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastPriceTimestamps.push(SymbolPriceTimestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LastPriceTimestamps {
    return {
      lastPriceTimestamps: Array.isArray(object?.lastPriceTimestamps)
        ? object.lastPriceTimestamps.map((e: any) => SymbolPriceTimestamp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LastPriceTimestamps): unknown {
    const obj: any = {};
    if (message.lastPriceTimestamps) {
      obj.lastPriceTimestamps = message.lastPriceTimestamps.map((e) => e ? SymbolPriceTimestamp.toJSON(e) : undefined);
    } else {
      obj.lastPriceTimestamps = [];
    }
    return obj;
  },

  create(base?: DeepPartial<LastPriceTimestamps>): LastPriceTimestamps {
    return LastPriceTimestamps.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<LastPriceTimestamps>): LastPriceTimestamps {
    const message = createBaseLastPriceTimestamps();
    message.lastPriceTimestamps = object.lastPriceTimestamps?.map((e) => SymbolPriceTimestamp.fromPartial(e)) || [];
    return message;
  },
};

function createBasePriceRecords(): PriceRecords {
  return { oracle: 0, symbolId: "", latestPriceRecords: [] };
}

export const PriceRecords = {
  encode(message: PriceRecords, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oracle !== 0) {
      writer.uint32(8).int32(message.oracle);
    }
    if (message.symbolId !== "") {
      writer.uint32(18).string(message.symbolId);
    }
    for (const v of message.latestPriceRecords) {
      PriceRecord.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceRecords {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oracle = reader.int32() as any;
          break;
        case 2:
          message.symbolId = reader.string();
          break;
        case 3:
          message.latestPriceRecords.push(PriceRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceRecords {
    return {
      oracle: isSet(object.oracle) ? oracleTypeFromJSON(object.oracle) : 0,
      symbolId: isSet(object.symbolId) ? String(object.symbolId) : "",
      latestPriceRecords: Array.isArray(object?.latestPriceRecords)
        ? object.latestPriceRecords.map((e: any) => PriceRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PriceRecords): unknown {
    const obj: any = {};
    message.oracle !== undefined && (obj.oracle = oracleTypeToJSON(message.oracle));
    message.symbolId !== undefined && (obj.symbolId = message.symbolId);
    if (message.latestPriceRecords) {
      obj.latestPriceRecords = message.latestPriceRecords.map((e) => e ? PriceRecord.toJSON(e) : undefined);
    } else {
      obj.latestPriceRecords = [];
    }
    return obj;
  },

  create(base?: DeepPartial<PriceRecords>): PriceRecords {
    return PriceRecords.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceRecords>): PriceRecords {
    const message = createBasePriceRecords();
    message.oracle = object.oracle ?? 0;
    message.symbolId = object.symbolId ?? "";
    message.latestPriceRecords = object.latestPriceRecords?.map((e) => PriceRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBasePriceRecord(): PriceRecord {
  return { timestamp: "0", price: "" };
}

export const PriceRecord = {
  encode(message: PriceRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = longToString(reader.int64() as Long);
          break;
        case 2:
          message.price = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceRecord {
    return {
      timestamp: isSet(object.timestamp) ? String(object.timestamp) : "0",
      price: isSet(object.price) ? String(object.price) : "",
    };
  },

  toJSON(message: PriceRecord): unknown {
    const obj: any = {};
    message.timestamp !== undefined && (obj.timestamp = message.timestamp);
    message.price !== undefined && (obj.price = message.price);
    return obj;
  },

  create(base?: DeepPartial<PriceRecord>): PriceRecord {
    return PriceRecord.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceRecord>): PriceRecord {
    const message = createBasePriceRecord();
    message.timestamp = object.timestamp ?? "0";
    message.price = object.price ?? "";
    return message;
  },
};

function createBaseMetadataStatistics(): MetadataStatistics {
  return {
    groupCount: 0,
    recordsSampleSize: 0,
    mean: "",
    twap: "",
    firstTimestamp: "0",
    lastTimestamp: "0",
    minPrice: "",
    maxPrice: "",
    medianPrice: "",
  };
}

export const MetadataStatistics = {
  encode(message: MetadataStatistics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.groupCount !== 0) {
      writer.uint32(8).uint32(message.groupCount);
    }
    if (message.recordsSampleSize !== 0) {
      writer.uint32(16).uint32(message.recordsSampleSize);
    }
    if (message.mean !== "") {
      writer.uint32(26).string(message.mean);
    }
    if (message.twap !== "") {
      writer.uint32(34).string(message.twap);
    }
    if (message.firstTimestamp !== "0") {
      writer.uint32(40).int64(message.firstTimestamp);
    }
    if (message.lastTimestamp !== "0") {
      writer.uint32(48).int64(message.lastTimestamp);
    }
    if (message.minPrice !== "") {
      writer.uint32(58).string(message.minPrice);
    }
    if (message.maxPrice !== "") {
      writer.uint32(66).string(message.maxPrice);
    }
    if (message.medianPrice !== "") {
      writer.uint32(74).string(message.medianPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataStatistics {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupCount = reader.uint32();
          break;
        case 2:
          message.recordsSampleSize = reader.uint32();
          break;
        case 3:
          message.mean = reader.string();
          break;
        case 4:
          message.twap = reader.string();
          break;
        case 5:
          message.firstTimestamp = longToString(reader.int64() as Long);
          break;
        case 6:
          message.lastTimestamp = longToString(reader.int64() as Long);
          break;
        case 7:
          message.minPrice = reader.string();
          break;
        case 8:
          message.maxPrice = reader.string();
          break;
        case 9:
          message.medianPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MetadataStatistics {
    return {
      groupCount: isSet(object.groupCount) ? Number(object.groupCount) : 0,
      recordsSampleSize: isSet(object.recordsSampleSize) ? Number(object.recordsSampleSize) : 0,
      mean: isSet(object.mean) ? String(object.mean) : "",
      twap: isSet(object.twap) ? String(object.twap) : "",
      firstTimestamp: isSet(object.firstTimestamp) ? String(object.firstTimestamp) : "0",
      lastTimestamp: isSet(object.lastTimestamp) ? String(object.lastTimestamp) : "0",
      minPrice: isSet(object.minPrice) ? String(object.minPrice) : "",
      maxPrice: isSet(object.maxPrice) ? String(object.maxPrice) : "",
      medianPrice: isSet(object.medianPrice) ? String(object.medianPrice) : "",
    };
  },

  toJSON(message: MetadataStatistics): unknown {
    const obj: any = {};
    message.groupCount !== undefined && (obj.groupCount = Math.round(message.groupCount));
    message.recordsSampleSize !== undefined && (obj.recordsSampleSize = Math.round(message.recordsSampleSize));
    message.mean !== undefined && (obj.mean = message.mean);
    message.twap !== undefined && (obj.twap = message.twap);
    message.firstTimestamp !== undefined && (obj.firstTimestamp = message.firstTimestamp);
    message.lastTimestamp !== undefined && (obj.lastTimestamp = message.lastTimestamp);
    message.minPrice !== undefined && (obj.minPrice = message.minPrice);
    message.maxPrice !== undefined && (obj.maxPrice = message.maxPrice);
    message.medianPrice !== undefined && (obj.medianPrice = message.medianPrice);
    return obj;
  },

  create(base?: DeepPartial<MetadataStatistics>): MetadataStatistics {
    return MetadataStatistics.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MetadataStatistics>): MetadataStatistics {
    const message = createBaseMetadataStatistics();
    message.groupCount = object.groupCount ?? 0;
    message.recordsSampleSize = object.recordsSampleSize ?? 0;
    message.mean = object.mean ?? "";
    message.twap = object.twap ?? "";
    message.firstTimestamp = object.firstTimestamp ?? "0";
    message.lastTimestamp = object.lastTimestamp ?? "0";
    message.minPrice = object.minPrice ?? "";
    message.maxPrice = object.maxPrice ?? "";
    message.medianPrice = object.medianPrice ?? "";
    return message;
  },
};

function createBasePriceAttestation(): PriceAttestation {
  return {
    productId: "",
    priceId: new Uint8Array(),
    price: "0",
    conf: "0",
    expo: 0,
    emaPrice: "0",
    emaConf: "0",
    status: 0,
    numPublishers: 0,
    maxNumPublishers: 0,
    attestationTime: "0",
    publishTime: "0",
  };
}

export const PriceAttestation = {
  encode(message: PriceAttestation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.priceId.length !== 0) {
      writer.uint32(18).bytes(message.priceId);
    }
    if (message.price !== "0") {
      writer.uint32(24).int64(message.price);
    }
    if (message.conf !== "0") {
      writer.uint32(32).uint64(message.conf);
    }
    if (message.expo !== 0) {
      writer.uint32(40).int32(message.expo);
    }
    if (message.emaPrice !== "0") {
      writer.uint32(48).int64(message.emaPrice);
    }
    if (message.emaConf !== "0") {
      writer.uint32(56).uint64(message.emaConf);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.numPublishers !== 0) {
      writer.uint32(72).uint32(message.numPublishers);
    }
    if (message.maxNumPublishers !== 0) {
      writer.uint32(80).uint32(message.maxNumPublishers);
    }
    if (message.attestationTime !== "0") {
      writer.uint32(88).int64(message.attestationTime);
    }
    if (message.publishTime !== "0") {
      writer.uint32(96).int64(message.publishTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceAttestation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.productId = reader.string();
          break;
        case 2:
          message.priceId = reader.bytes();
          break;
        case 3:
          message.price = longToString(reader.int64() as Long);
          break;
        case 4:
          message.conf = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.expo = reader.int32();
          break;
        case 6:
          message.emaPrice = longToString(reader.int64() as Long);
          break;
        case 7:
          message.emaConf = longToString(reader.uint64() as Long);
          break;
        case 8:
          message.status = reader.int32() as any;
          break;
        case 9:
          message.numPublishers = reader.uint32();
          break;
        case 10:
          message.maxNumPublishers = reader.uint32();
          break;
        case 11:
          message.attestationTime = longToString(reader.int64() as Long);
          break;
        case 12:
          message.publishTime = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceAttestation {
    return {
      productId: isSet(object.productId) ? String(object.productId) : "",
      priceId: isSet(object.priceId) ? bytesFromBase64(object.priceId) : new Uint8Array(),
      price: isSet(object.price) ? String(object.price) : "0",
      conf: isSet(object.conf) ? String(object.conf) : "0",
      expo: isSet(object.expo) ? Number(object.expo) : 0,
      emaPrice: isSet(object.emaPrice) ? String(object.emaPrice) : "0",
      emaConf: isSet(object.emaConf) ? String(object.emaConf) : "0",
      status: isSet(object.status) ? pythStatusFromJSON(object.status) : 0,
      numPublishers: isSet(object.numPublishers) ? Number(object.numPublishers) : 0,
      maxNumPublishers: isSet(object.maxNumPublishers) ? Number(object.maxNumPublishers) : 0,
      attestationTime: isSet(object.attestationTime) ? String(object.attestationTime) : "0",
      publishTime: isSet(object.publishTime) ? String(object.publishTime) : "0",
    };
  },

  toJSON(message: PriceAttestation): unknown {
    const obj: any = {};
    message.productId !== undefined && (obj.productId = message.productId);
    message.priceId !== undefined &&
      (obj.priceId = base64FromBytes(message.priceId !== undefined ? message.priceId : new Uint8Array()));
    message.price !== undefined && (obj.price = message.price);
    message.conf !== undefined && (obj.conf = message.conf);
    message.expo !== undefined && (obj.expo = Math.round(message.expo));
    message.emaPrice !== undefined && (obj.emaPrice = message.emaPrice);
    message.emaConf !== undefined && (obj.emaConf = message.emaConf);
    message.status !== undefined && (obj.status = pythStatusToJSON(message.status));
    message.numPublishers !== undefined && (obj.numPublishers = Math.round(message.numPublishers));
    message.maxNumPublishers !== undefined && (obj.maxNumPublishers = Math.round(message.maxNumPublishers));
    message.attestationTime !== undefined && (obj.attestationTime = message.attestationTime);
    message.publishTime !== undefined && (obj.publishTime = message.publishTime);
    return obj;
  },

  create(base?: DeepPartial<PriceAttestation>): PriceAttestation {
    return PriceAttestation.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceAttestation>): PriceAttestation {
    const message = createBasePriceAttestation();
    message.productId = object.productId ?? "";
    message.priceId = object.priceId ?? new Uint8Array();
    message.price = object.price ?? "0";
    message.conf = object.conf ?? "0";
    message.expo = object.expo ?? 0;
    message.emaPrice = object.emaPrice ?? "0";
    message.emaConf = object.emaConf ?? "0";
    message.status = object.status ?? 0;
    message.numPublishers = object.numPublishers ?? 0;
    message.maxNumPublishers = object.maxNumPublishers ?? 0;
    message.attestationTime = object.attestationTime ?? "0";
    message.publishTime = object.publishTime ?? "0";
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
