/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { GenesisState } from "./genesis";
import {
  BandPriceState,
  CoinbasePriceState,
  MetadataStatistics,
  OracleInfo,
  OracleType,
  oracleTypeFromJSON,
  oracleTypeToJSON,
  Params,
  PriceFeedState,
  PriceRecord,
  PriceRecords,
  PriceState,
  ProviderInfo,
  ProviderState,
  PythPriceState,
} from "./oracle";

export interface QueryPythPriceRequest {
  priceId: string;
}

export interface QueryPythPriceResponse {
  priceState: PythPriceState | undefined;
}

/** QueryOracleParamsRequest is the request type for the Query/OracleParams RPC method. */
export interface QueryParamsRequest {
}

/** QueryOracleParamsResponse is the response type for the Query/OracleParams RPC method. */
export interface QueryParamsResponse {
  params: Params | undefined;
}

/** QueryBandRelayersRequest is the request type for the Query/BandRelayers RPC method. */
export interface QueryBandRelayersRequest {
}

/** QueryBandRelayersResponse is the response type for the Query/BandRelayers RPC method. */
export interface QueryBandRelayersResponse {
  relayers: string[];
}

/** QueryBandPriceStatesRequest is the request type for the Query/BandPriceStates RPC method. */
export interface QueryBandPriceStatesRequest {
}

/** QueryBandPriceStatesResponse is the response type for the Query/BandPriceStates RPC method. */
export interface QueryBandPriceStatesResponse {
  priceStates: BandPriceState[];
}

/** QueryBandIBCPriceStatesRequest is the request type for the Query/BandIBCPriceStates RPC method. */
export interface QueryBandIBCPriceStatesRequest {
}

/** QueryBandIBCPriceStatesResponse is the response type for the Query/BandIBCPriceStates RPC method. */
export interface QueryBandIBCPriceStatesResponse {
  priceStates: BandPriceState[];
}

/** QueryPriceFeedPriceStatesRequest is the request type for the Query/PriceFeedPriceStates RPC method. */
export interface QueryPriceFeedPriceStatesRequest {
}

/** QueryPriceFeedPriceStatesResponse is the response type for the Query/PriceFeedPriceStates RPC method. */
export interface QueryPriceFeedPriceStatesResponse {
  priceStates: PriceFeedState[];
}

/** QueryCoinbasePriceStatesRequest is the request type for the Query/CoinbasePriceStates RPC method. */
export interface QueryCoinbasePriceStatesRequest {
}

/** QueryCoinbasePriceStatesResponse is the response type for the Query/CoinbasePriceStates RPC method. */
export interface QueryCoinbasePriceStatesResponse {
  priceStates: CoinbasePriceState[];
}

/** QueryPythPriceStatesRequest is the request type for the Query/CoinbasePriceStates RPC method. */
export interface QueryPythPriceStatesRequest {
}

/** QueryPythPriceStatesResponse is the response type for the Query/CoinbasePriceStates RPC method. */
export interface QueryPythPriceStatesResponse {
  priceStates: PythPriceState[];
}

/** QueryProviderPriceStateRequest is the request type for the Query/ProviderPriceState RPC method. */
export interface QueryProviderPriceStateRequest {
  provider: string;
  symbol: string;
}

/** QueryProviderPriceStatesResponse is the response type for the Query/ProviderPriceStates RPC method. */
export interface QueryProviderPriceStateResponse {
  priceState: PriceState | undefined;
}

/** QueryModuleStateRequest is the request type for the Query/OracleModuleState RPC method. */
export interface QueryModuleStateRequest {
}

/** QueryModuleStateResponse is the response type for the Query/OracleModuleState RPC method. */
export interface QueryModuleStateResponse {
  state: GenesisState | undefined;
}

export interface QueryHistoricalPriceRecordsRequest {
  oracle: OracleType;
  symbolId: string;
}

export interface QueryHistoricalPriceRecordsResponse {
  priceRecords: PriceRecords[];
}

export interface OracleHistoryOptions {
  /**
   * MaxAge restricts the oracle price records oldest age in seconds from the current block time to consider.
   * A value of 0 means use all the records present on the chain.
   */
  maxAge: string;
  /** If IncludeRawHistory is true, the raw underlying data used for the computation is included in the response */
  includeRawHistory: boolean;
  /** If IncludeMetadata is true, metadata on the computation is included in the response */
  includeMetadata: boolean;
}

/** QueryOracleVolatilityRequest is the request type for Query/OracleVolatility RPC method. */
export interface QueryOracleVolatilityRequest {
  baseInfo: OracleInfo | undefined;
  quoteInfo: OracleInfo | undefined;
  oracleHistoryOptions: OracleHistoryOptions | undefined;
}

/** QueryOracleVolatilityResponse is the response type for Query/OracleVolatility RPC method. */
export interface QueryOracleVolatilityResponse {
  volatility: string;
  historyMetadata: MetadataStatistics | undefined;
  rawHistory: PriceRecord[];
}

export interface QueryOracleProvidersInfoRequest {
}

export interface QueryOracleProvidersInfoResponse {
  providers: ProviderInfo[];
}

export interface QueryOracleProviderPricesRequest {
  provider: string;
}

export interface QueryOracleProviderPricesResponse {
  providerState: ProviderState[];
}

/** QueryOraclePriceRequest is the request type for the Query/OraclePrice RPC method. */
export interface QueryOraclePriceRequest {
  oracleType: OracleType;
  base: string;
  quote: string;
}

export interface PricePairState {
  pairPrice: string;
  basePrice: string;
  quotePrice: string;
  baseCumulativePrice: string;
  quoteCumulativePrice: string;
  baseTimestamp: string;
  quoteTimestamp: string;
}

/** QueryOraclePriceResponse is the response type for the Query/OraclePrice RPC method. */
export interface QueryOraclePriceResponse {
  pricePairState: PricePairState | undefined;
}

function createBaseQueryPythPriceRequest(): QueryPythPriceRequest {
  return { priceId: "" };
}

export const QueryPythPriceRequest = {
  encode(message: QueryPythPriceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceId !== "") {
      writer.uint32(10).string(message.priceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPythPriceRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPythPriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPythPriceRequest {
    return { priceId: isSet(object.priceId) ? String(object.priceId) : "" };
  },

  toJSON(message: QueryPythPriceRequest): unknown {
    const obj: any = {};
    message.priceId !== undefined && (obj.priceId = message.priceId);
    return obj;
  },

  create(base?: DeepPartial<QueryPythPriceRequest>): QueryPythPriceRequest {
    return QueryPythPriceRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPythPriceRequest>): QueryPythPriceRequest {
    const message = createBaseQueryPythPriceRequest();
    message.priceId = object.priceId ?? "";
    return message;
  },
};

function createBaseQueryPythPriceResponse(): QueryPythPriceResponse {
  return { priceState: undefined };
}

export const QueryPythPriceResponse = {
  encode(message: QueryPythPriceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceState !== undefined) {
      PythPriceState.encode(message.priceState, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPythPriceResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPythPriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceState = PythPriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPythPriceResponse {
    return { priceState: isSet(object.priceState) ? PythPriceState.fromJSON(object.priceState) : undefined };
  },

  toJSON(message: QueryPythPriceResponse): unknown {
    const obj: any = {};
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PythPriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryPythPriceResponse>): QueryPythPriceResponse {
    return QueryPythPriceResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPythPriceResponse>): QueryPythPriceResponse {
    const message = createBaseQueryPythPriceResponse();
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PythPriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest = {
  encode(_: QueryParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryParamsRequest>): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse = {
  encode(message: QueryParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    message.params !== undefined && (obj.params = message.params ? Params.toJSON(message.params) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryParamsResponse>): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryBandRelayersRequest(): QueryBandRelayersRequest {
  return {};
}

export const QueryBandRelayersRequest = {
  encode(_: QueryBandRelayersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandRelayersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandRelayersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryBandRelayersRequest {
    return {};
  },

  toJSON(_: QueryBandRelayersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryBandRelayersRequest>): QueryBandRelayersRequest {
    return QueryBandRelayersRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryBandRelayersRequest>): QueryBandRelayersRequest {
    const message = createBaseQueryBandRelayersRequest();
    return message;
  },
};

function createBaseQueryBandRelayersResponse(): QueryBandRelayersResponse {
  return { relayers: [] };
}

export const QueryBandRelayersResponse = {
  encode(message: QueryBandRelayersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.relayers) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandRelayersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandRelayersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.relayers.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBandRelayersResponse {
    return { relayers: Array.isArray(object?.relayers) ? object.relayers.map((e: any) => String(e)) : [] };
  },

  toJSON(message: QueryBandRelayersResponse): unknown {
    const obj: any = {};
    if (message.relayers) {
      obj.relayers = message.relayers.map((e) => e);
    } else {
      obj.relayers = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBandRelayersResponse>): QueryBandRelayersResponse {
    return QueryBandRelayersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBandRelayersResponse>): QueryBandRelayersResponse {
    const message = createBaseQueryBandRelayersResponse();
    message.relayers = object.relayers?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryBandPriceStatesRequest(): QueryBandPriceStatesRequest {
  return {};
}

export const QueryBandPriceStatesRequest = {
  encode(_: QueryBandPriceStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandPriceStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandPriceStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryBandPriceStatesRequest {
    return {};
  },

  toJSON(_: QueryBandPriceStatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryBandPriceStatesRequest>): QueryBandPriceStatesRequest {
    return QueryBandPriceStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryBandPriceStatesRequest>): QueryBandPriceStatesRequest {
    const message = createBaseQueryBandPriceStatesRequest();
    return message;
  },
};

function createBaseQueryBandPriceStatesResponse(): QueryBandPriceStatesResponse {
  return { priceStates: [] };
}

export const QueryBandPriceStatesResponse = {
  encode(message: QueryBandPriceStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceStates) {
      BandPriceState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandPriceStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandPriceStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceStates.push(BandPriceState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBandPriceStatesResponse {
    return {
      priceStates: Array.isArray(object?.priceStates)
        ? object.priceStates.map((e: any) => BandPriceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBandPriceStatesResponse): unknown {
    const obj: any = {};
    if (message.priceStates) {
      obj.priceStates = message.priceStates.map((e) => e ? BandPriceState.toJSON(e) : undefined);
    } else {
      obj.priceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBandPriceStatesResponse>): QueryBandPriceStatesResponse {
    return QueryBandPriceStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBandPriceStatesResponse>): QueryBandPriceStatesResponse {
    const message = createBaseQueryBandPriceStatesResponse();
    message.priceStates = object.priceStates?.map((e) => BandPriceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBandIBCPriceStatesRequest(): QueryBandIBCPriceStatesRequest {
  return {};
}

export const QueryBandIBCPriceStatesRequest = {
  encode(_: QueryBandIBCPriceStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandIBCPriceStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandIBCPriceStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryBandIBCPriceStatesRequest {
    return {};
  },

  toJSON(_: QueryBandIBCPriceStatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryBandIBCPriceStatesRequest>): QueryBandIBCPriceStatesRequest {
    return QueryBandIBCPriceStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryBandIBCPriceStatesRequest>): QueryBandIBCPriceStatesRequest {
    const message = createBaseQueryBandIBCPriceStatesRequest();
    return message;
  },
};

function createBaseQueryBandIBCPriceStatesResponse(): QueryBandIBCPriceStatesResponse {
  return { priceStates: [] };
}

export const QueryBandIBCPriceStatesResponse = {
  encode(message: QueryBandIBCPriceStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceStates) {
      BandPriceState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBandIBCPriceStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBandIBCPriceStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceStates.push(BandPriceState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBandIBCPriceStatesResponse {
    return {
      priceStates: Array.isArray(object?.priceStates)
        ? object.priceStates.map((e: any) => BandPriceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBandIBCPriceStatesResponse): unknown {
    const obj: any = {};
    if (message.priceStates) {
      obj.priceStates = message.priceStates.map((e) => e ? BandPriceState.toJSON(e) : undefined);
    } else {
      obj.priceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBandIBCPriceStatesResponse>): QueryBandIBCPriceStatesResponse {
    return QueryBandIBCPriceStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBandIBCPriceStatesResponse>): QueryBandIBCPriceStatesResponse {
    const message = createBaseQueryBandIBCPriceStatesResponse();
    message.priceStates = object.priceStates?.map((e) => BandPriceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPriceFeedPriceStatesRequest(): QueryPriceFeedPriceStatesRequest {
  return {};
}

export const QueryPriceFeedPriceStatesRequest = {
  encode(_: QueryPriceFeedPriceStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPriceFeedPriceStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPriceFeedPriceStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryPriceFeedPriceStatesRequest {
    return {};
  },

  toJSON(_: QueryPriceFeedPriceStatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryPriceFeedPriceStatesRequest>): QueryPriceFeedPriceStatesRequest {
    return QueryPriceFeedPriceStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryPriceFeedPriceStatesRequest>): QueryPriceFeedPriceStatesRequest {
    const message = createBaseQueryPriceFeedPriceStatesRequest();
    return message;
  },
};

function createBaseQueryPriceFeedPriceStatesResponse(): QueryPriceFeedPriceStatesResponse {
  return { priceStates: [] };
}

export const QueryPriceFeedPriceStatesResponse = {
  encode(message: QueryPriceFeedPriceStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceStates) {
      PriceFeedState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPriceFeedPriceStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPriceFeedPriceStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceStates.push(PriceFeedState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPriceFeedPriceStatesResponse {
    return {
      priceStates: Array.isArray(object?.priceStates)
        ? object.priceStates.map((e: any) => PriceFeedState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPriceFeedPriceStatesResponse): unknown {
    const obj: any = {};
    if (message.priceStates) {
      obj.priceStates = message.priceStates.map((e) => e ? PriceFeedState.toJSON(e) : undefined);
    } else {
      obj.priceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPriceFeedPriceStatesResponse>): QueryPriceFeedPriceStatesResponse {
    return QueryPriceFeedPriceStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPriceFeedPriceStatesResponse>): QueryPriceFeedPriceStatesResponse {
    const message = createBaseQueryPriceFeedPriceStatesResponse();
    message.priceStates = object.priceStates?.map((e) => PriceFeedState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryCoinbasePriceStatesRequest(): QueryCoinbasePriceStatesRequest {
  return {};
}

export const QueryCoinbasePriceStatesRequest = {
  encode(_: QueryCoinbasePriceStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryCoinbasePriceStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCoinbasePriceStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryCoinbasePriceStatesRequest {
    return {};
  },

  toJSON(_: QueryCoinbasePriceStatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryCoinbasePriceStatesRequest>): QueryCoinbasePriceStatesRequest {
    return QueryCoinbasePriceStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryCoinbasePriceStatesRequest>): QueryCoinbasePriceStatesRequest {
    const message = createBaseQueryCoinbasePriceStatesRequest();
    return message;
  },
};

function createBaseQueryCoinbasePriceStatesResponse(): QueryCoinbasePriceStatesResponse {
  return { priceStates: [] };
}

export const QueryCoinbasePriceStatesResponse = {
  encode(message: QueryCoinbasePriceStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceStates) {
      CoinbasePriceState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryCoinbasePriceStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCoinbasePriceStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceStates.push(CoinbasePriceState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryCoinbasePriceStatesResponse {
    return {
      priceStates: Array.isArray(object?.priceStates)
        ? object.priceStates.map((e: any) => CoinbasePriceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryCoinbasePriceStatesResponse): unknown {
    const obj: any = {};
    if (message.priceStates) {
      obj.priceStates = message.priceStates.map((e) => e ? CoinbasePriceState.toJSON(e) : undefined);
    } else {
      obj.priceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCoinbasePriceStatesResponse>): QueryCoinbasePriceStatesResponse {
    return QueryCoinbasePriceStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryCoinbasePriceStatesResponse>): QueryCoinbasePriceStatesResponse {
    const message = createBaseQueryCoinbasePriceStatesResponse();
    message.priceStates = object.priceStates?.map((e) => CoinbasePriceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPythPriceStatesRequest(): QueryPythPriceStatesRequest {
  return {};
}

export const QueryPythPriceStatesRequest = {
  encode(_: QueryPythPriceStatesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPythPriceStatesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPythPriceStatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryPythPriceStatesRequest {
    return {};
  },

  toJSON(_: QueryPythPriceStatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryPythPriceStatesRequest>): QueryPythPriceStatesRequest {
    return QueryPythPriceStatesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryPythPriceStatesRequest>): QueryPythPriceStatesRequest {
    const message = createBaseQueryPythPriceStatesRequest();
    return message;
  },
};

function createBaseQueryPythPriceStatesResponse(): QueryPythPriceStatesResponse {
  return { priceStates: [] };
}

export const QueryPythPriceStatesResponse = {
  encode(message: QueryPythPriceStatesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceStates) {
      PythPriceState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPythPriceStatesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPythPriceStatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceStates.push(PythPriceState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPythPriceStatesResponse {
    return {
      priceStates: Array.isArray(object?.priceStates)
        ? object.priceStates.map((e: any) => PythPriceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPythPriceStatesResponse): unknown {
    const obj: any = {};
    if (message.priceStates) {
      obj.priceStates = message.priceStates.map((e) => e ? PythPriceState.toJSON(e) : undefined);
    } else {
      obj.priceStates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPythPriceStatesResponse>): QueryPythPriceStatesResponse {
    return QueryPythPriceStatesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPythPriceStatesResponse>): QueryPythPriceStatesResponse {
    const message = createBaseQueryPythPriceStatesResponse();
    message.priceStates = object.priceStates?.map((e) => PythPriceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryProviderPriceStateRequest(): QueryProviderPriceStateRequest {
  return { provider: "", symbol: "" };
}

export const QueryProviderPriceStateRequest = {
  encode(message: QueryProviderPriceStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProviderPriceStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProviderPriceStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.provider = reader.string();
          break;
        case 2:
          message.symbol = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryProviderPriceStateRequest {
    return {
      provider: isSet(object.provider) ? String(object.provider) : "",
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
    };
  },

  toJSON(message: QueryProviderPriceStateRequest): unknown {
    const obj: any = {};
    message.provider !== undefined && (obj.provider = message.provider);
    message.symbol !== undefined && (obj.symbol = message.symbol);
    return obj;
  },

  create(base?: DeepPartial<QueryProviderPriceStateRequest>): QueryProviderPriceStateRequest {
    return QueryProviderPriceStateRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryProviderPriceStateRequest>): QueryProviderPriceStateRequest {
    const message = createBaseQueryProviderPriceStateRequest();
    message.provider = object.provider ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseQueryProviderPriceStateResponse(): QueryProviderPriceStateResponse {
  return { priceState: undefined };
}

export const QueryProviderPriceStateResponse = {
  encode(message: QueryProviderPriceStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.priceState !== undefined) {
      PriceState.encode(message.priceState, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProviderPriceStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProviderPriceStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceState = PriceState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryProviderPriceStateResponse {
    return { priceState: isSet(object.priceState) ? PriceState.fromJSON(object.priceState) : undefined };
  },

  toJSON(message: QueryProviderPriceStateResponse): unknown {
    const obj: any = {};
    message.priceState !== undefined &&
      (obj.priceState = message.priceState ? PriceState.toJSON(message.priceState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryProviderPriceStateResponse>): QueryProviderPriceStateResponse {
    return QueryProviderPriceStateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryProviderPriceStateResponse>): QueryProviderPriceStateResponse {
    const message = createBaseQueryProviderPriceStateResponse();
    message.priceState = (object.priceState !== undefined && object.priceState !== null)
      ? PriceState.fromPartial(object.priceState)
      : undefined;
    return message;
  },
};

function createBaseQueryModuleStateRequest(): QueryModuleStateRequest {
  return {};
}

export const QueryModuleStateRequest = {
  encode(_: QueryModuleStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryModuleStateRequest {
    return {};
  },

  toJSON(_: QueryModuleStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    return QueryModuleStateRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    const message = createBaseQueryModuleStateRequest();
    return message;
  },
};

function createBaseQueryModuleStateResponse(): QueryModuleStateResponse {
  return { state: undefined };
}

export const QueryModuleStateResponse = {
  encode(message: QueryModuleStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      GenesisState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = GenesisState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryModuleStateResponse {
    return { state: isSet(object.state) ? GenesisState.fromJSON(object.state) : undefined };
  },

  toJSON(message: QueryModuleStateResponse): unknown {
    const obj: any = {};
    message.state !== undefined && (obj.state = message.state ? GenesisState.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    return QueryModuleStateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    const message = createBaseQueryModuleStateResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? GenesisState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseQueryHistoricalPriceRecordsRequest(): QueryHistoricalPriceRecordsRequest {
  return { oracle: 0, symbolId: "" };
}

export const QueryHistoricalPriceRecordsRequest = {
  encode(message: QueryHistoricalPriceRecordsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oracle !== 0) {
      writer.uint32(8).int32(message.oracle);
    }
    if (message.symbolId !== "") {
      writer.uint32(18).string(message.symbolId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalPriceRecordsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHistoricalPriceRecordsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oracle = reader.int32() as any;
          break;
        case 2:
          message.symbolId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryHistoricalPriceRecordsRequest {
    return {
      oracle: isSet(object.oracle) ? oracleTypeFromJSON(object.oracle) : 0,
      symbolId: isSet(object.symbolId) ? String(object.symbolId) : "",
    };
  },

  toJSON(message: QueryHistoricalPriceRecordsRequest): unknown {
    const obj: any = {};
    message.oracle !== undefined && (obj.oracle = oracleTypeToJSON(message.oracle));
    message.symbolId !== undefined && (obj.symbolId = message.symbolId);
    return obj;
  },

  create(base?: DeepPartial<QueryHistoricalPriceRecordsRequest>): QueryHistoricalPriceRecordsRequest {
    return QueryHistoricalPriceRecordsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryHistoricalPriceRecordsRequest>): QueryHistoricalPriceRecordsRequest {
    const message = createBaseQueryHistoricalPriceRecordsRequest();
    message.oracle = object.oracle ?? 0;
    message.symbolId = object.symbolId ?? "";
    return message;
  },
};

function createBaseQueryHistoricalPriceRecordsResponse(): QueryHistoricalPriceRecordsResponse {
  return { priceRecords: [] };
}

export const QueryHistoricalPriceRecordsResponse = {
  encode(message: QueryHistoricalPriceRecordsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.priceRecords) {
      PriceRecords.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalPriceRecordsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHistoricalPriceRecordsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.priceRecords.push(PriceRecords.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryHistoricalPriceRecordsResponse {
    return {
      priceRecords: Array.isArray(object?.priceRecords)
        ? object.priceRecords.map((e: any) => PriceRecords.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryHistoricalPriceRecordsResponse): unknown {
    const obj: any = {};
    if (message.priceRecords) {
      obj.priceRecords = message.priceRecords.map((e) => e ? PriceRecords.toJSON(e) : undefined);
    } else {
      obj.priceRecords = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryHistoricalPriceRecordsResponse>): QueryHistoricalPriceRecordsResponse {
    return QueryHistoricalPriceRecordsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryHistoricalPriceRecordsResponse>): QueryHistoricalPriceRecordsResponse {
    const message = createBaseQueryHistoricalPriceRecordsResponse();
    message.priceRecords = object.priceRecords?.map((e) => PriceRecords.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOracleHistoryOptions(): OracleHistoryOptions {
  return { maxAge: "0", includeRawHistory: false, includeMetadata: false };
}

export const OracleHistoryOptions = {
  encode(message: OracleHistoryOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxAge !== "0") {
      writer.uint32(8).uint64(message.maxAge);
    }
    if (message.includeRawHistory === true) {
      writer.uint32(16).bool(message.includeRawHistory);
    }
    if (message.includeMetadata === true) {
      writer.uint32(24).bool(message.includeMetadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OracleHistoryOptions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleHistoryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxAge = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.includeRawHistory = reader.bool();
          break;
        case 3:
          message.includeMetadata = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OracleHistoryOptions {
    return {
      maxAge: isSet(object.maxAge) ? String(object.maxAge) : "0",
      includeRawHistory: isSet(object.includeRawHistory) ? Boolean(object.includeRawHistory) : false,
      includeMetadata: isSet(object.includeMetadata) ? Boolean(object.includeMetadata) : false,
    };
  },

  toJSON(message: OracleHistoryOptions): unknown {
    const obj: any = {};
    message.maxAge !== undefined && (obj.maxAge = message.maxAge);
    message.includeRawHistory !== undefined && (obj.includeRawHistory = message.includeRawHistory);
    message.includeMetadata !== undefined && (obj.includeMetadata = message.includeMetadata);
    return obj;
  },

  create(base?: DeepPartial<OracleHistoryOptions>): OracleHistoryOptions {
    return OracleHistoryOptions.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OracleHistoryOptions>): OracleHistoryOptions {
    const message = createBaseOracleHistoryOptions();
    message.maxAge = object.maxAge ?? "0";
    message.includeRawHistory = object.includeRawHistory ?? false;
    message.includeMetadata = object.includeMetadata ?? false;
    return message;
  },
};

function createBaseQueryOracleVolatilityRequest(): QueryOracleVolatilityRequest {
  return { baseInfo: undefined, quoteInfo: undefined, oracleHistoryOptions: undefined };
}

export const QueryOracleVolatilityRequest = {
  encode(message: QueryOracleVolatilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseInfo !== undefined) {
      OracleInfo.encode(message.baseInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.quoteInfo !== undefined) {
      OracleInfo.encode(message.quoteInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.oracleHistoryOptions !== undefined) {
      OracleHistoryOptions.encode(message.oracleHistoryOptions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleVolatilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleVolatilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseInfo = OracleInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.quoteInfo = OracleInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.oracleHistoryOptions = OracleHistoryOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOracleVolatilityRequest {
    return {
      baseInfo: isSet(object.baseInfo) ? OracleInfo.fromJSON(object.baseInfo) : undefined,
      quoteInfo: isSet(object.quoteInfo) ? OracleInfo.fromJSON(object.quoteInfo) : undefined,
      oracleHistoryOptions: isSet(object.oracleHistoryOptions)
        ? OracleHistoryOptions.fromJSON(object.oracleHistoryOptions)
        : undefined,
    };
  },

  toJSON(message: QueryOracleVolatilityRequest): unknown {
    const obj: any = {};
    message.baseInfo !== undefined &&
      (obj.baseInfo = message.baseInfo ? OracleInfo.toJSON(message.baseInfo) : undefined);
    message.quoteInfo !== undefined &&
      (obj.quoteInfo = message.quoteInfo ? OracleInfo.toJSON(message.quoteInfo) : undefined);
    message.oracleHistoryOptions !== undefined && (obj.oracleHistoryOptions = message.oracleHistoryOptions
      ? OracleHistoryOptions.toJSON(message.oracleHistoryOptions)
      : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryOracleVolatilityRequest>): QueryOracleVolatilityRequest {
    return QueryOracleVolatilityRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOracleVolatilityRequest>): QueryOracleVolatilityRequest {
    const message = createBaseQueryOracleVolatilityRequest();
    message.baseInfo = (object.baseInfo !== undefined && object.baseInfo !== null)
      ? OracleInfo.fromPartial(object.baseInfo)
      : undefined;
    message.quoteInfo = (object.quoteInfo !== undefined && object.quoteInfo !== null)
      ? OracleInfo.fromPartial(object.quoteInfo)
      : undefined;
    message.oracleHistoryOptions = (object.oracleHistoryOptions !== undefined && object.oracleHistoryOptions !== null)
      ? OracleHistoryOptions.fromPartial(object.oracleHistoryOptions)
      : undefined;
    return message;
  },
};

function createBaseQueryOracleVolatilityResponse(): QueryOracleVolatilityResponse {
  return { volatility: "", historyMetadata: undefined, rawHistory: [] };
}

export const QueryOracleVolatilityResponse = {
  encode(message: QueryOracleVolatilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.volatility !== "") {
      writer.uint32(10).string(message.volatility);
    }
    if (message.historyMetadata !== undefined) {
      MetadataStatistics.encode(message.historyMetadata, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.rawHistory) {
      PriceRecord.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleVolatilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleVolatilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.volatility = reader.string();
          break;
        case 2:
          message.historyMetadata = MetadataStatistics.decode(reader, reader.uint32());
          break;
        case 3:
          message.rawHistory.push(PriceRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOracleVolatilityResponse {
    return {
      volatility: isSet(object.volatility) ? String(object.volatility) : "",
      historyMetadata: isSet(object.historyMetadata) ? MetadataStatistics.fromJSON(object.historyMetadata) : undefined,
      rawHistory: Array.isArray(object?.rawHistory) ? object.rawHistory.map((e: any) => PriceRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryOracleVolatilityResponse): unknown {
    const obj: any = {};
    message.volatility !== undefined && (obj.volatility = message.volatility);
    message.historyMetadata !== undefined &&
      (obj.historyMetadata = message.historyMetadata ? MetadataStatistics.toJSON(message.historyMetadata) : undefined);
    if (message.rawHistory) {
      obj.rawHistory = message.rawHistory.map((e) => e ? PriceRecord.toJSON(e) : undefined);
    } else {
      obj.rawHistory = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOracleVolatilityResponse>): QueryOracleVolatilityResponse {
    return QueryOracleVolatilityResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOracleVolatilityResponse>): QueryOracleVolatilityResponse {
    const message = createBaseQueryOracleVolatilityResponse();
    message.volatility = object.volatility ?? "";
    message.historyMetadata = (object.historyMetadata !== undefined && object.historyMetadata !== null)
      ? MetadataStatistics.fromPartial(object.historyMetadata)
      : undefined;
    message.rawHistory = object.rawHistory?.map((e) => PriceRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryOracleProvidersInfoRequest(): QueryOracleProvidersInfoRequest {
  return {};
}

export const QueryOracleProvidersInfoRequest = {
  encode(_: QueryOracleProvidersInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleProvidersInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleProvidersInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryOracleProvidersInfoRequest {
    return {};
  },

  toJSON(_: QueryOracleProvidersInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryOracleProvidersInfoRequest>): QueryOracleProvidersInfoRequest {
    return QueryOracleProvidersInfoRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryOracleProvidersInfoRequest>): QueryOracleProvidersInfoRequest {
    const message = createBaseQueryOracleProvidersInfoRequest();
    return message;
  },
};

function createBaseQueryOracleProvidersInfoResponse(): QueryOracleProvidersInfoResponse {
  return { providers: [] };
}

export const QueryOracleProvidersInfoResponse = {
  encode(message: QueryOracleProvidersInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.providers) {
      ProviderInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleProvidersInfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleProvidersInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.providers.push(ProviderInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOracleProvidersInfoResponse {
    return {
      providers: Array.isArray(object?.providers) ? object.providers.map((e: any) => ProviderInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryOracleProvidersInfoResponse): unknown {
    const obj: any = {};
    if (message.providers) {
      obj.providers = message.providers.map((e) => e ? ProviderInfo.toJSON(e) : undefined);
    } else {
      obj.providers = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOracleProvidersInfoResponse>): QueryOracleProvidersInfoResponse {
    return QueryOracleProvidersInfoResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOracleProvidersInfoResponse>): QueryOracleProvidersInfoResponse {
    const message = createBaseQueryOracleProvidersInfoResponse();
    message.providers = object.providers?.map((e) => ProviderInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryOracleProviderPricesRequest(): QueryOracleProviderPricesRequest {
  return { provider: "" };
}

export const QueryOracleProviderPricesRequest = {
  encode(message: QueryOracleProviderPricesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleProviderPricesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleProviderPricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.provider = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOracleProviderPricesRequest {
    return { provider: isSet(object.provider) ? String(object.provider) : "" };
  },

  toJSON(message: QueryOracleProviderPricesRequest): unknown {
    const obj: any = {};
    message.provider !== undefined && (obj.provider = message.provider);
    return obj;
  },

  create(base?: DeepPartial<QueryOracleProviderPricesRequest>): QueryOracleProviderPricesRequest {
    return QueryOracleProviderPricesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOracleProviderPricesRequest>): QueryOracleProviderPricesRequest {
    const message = createBaseQueryOracleProviderPricesRequest();
    message.provider = object.provider ?? "";
    return message;
  },
};

function createBaseQueryOracleProviderPricesResponse(): QueryOracleProviderPricesResponse {
  return { providerState: [] };
}

export const QueryOracleProviderPricesResponse = {
  encode(message: QueryOracleProviderPricesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.providerState) {
      ProviderState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOracleProviderPricesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOracleProviderPricesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.providerState.push(ProviderState.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOracleProviderPricesResponse {
    return {
      providerState: Array.isArray(object?.providerState)
        ? object.providerState.map((e: any) => ProviderState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryOracleProviderPricesResponse): unknown {
    const obj: any = {};
    if (message.providerState) {
      obj.providerState = message.providerState.map((e) => e ? ProviderState.toJSON(e) : undefined);
    } else {
      obj.providerState = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOracleProviderPricesResponse>): QueryOracleProviderPricesResponse {
    return QueryOracleProviderPricesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOracleProviderPricesResponse>): QueryOracleProviderPricesResponse {
    const message = createBaseQueryOracleProviderPricesResponse();
    message.providerState = object.providerState?.map((e) => ProviderState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryOraclePriceRequest(): QueryOraclePriceRequest {
  return { oracleType: 0, base: "", quote: "" };
}

export const QueryOraclePriceRequest = {
  encode(message: QueryOraclePriceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oracleType !== 0) {
      writer.uint32(8).int32(message.oracleType);
    }
    if (message.base !== "") {
      writer.uint32(18).string(message.base);
    }
    if (message.quote !== "") {
      writer.uint32(26).string(message.quote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOraclePriceRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOraclePriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oracleType = reader.int32() as any;
          break;
        case 2:
          message.base = reader.string();
          break;
        case 3:
          message.quote = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOraclePriceRequest {
    return {
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      base: isSet(object.base) ? String(object.base) : "",
      quote: isSet(object.quote) ? String(object.quote) : "",
    };
  },

  toJSON(message: QueryOraclePriceRequest): unknown {
    const obj: any = {};
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.base !== undefined && (obj.base = message.base);
    message.quote !== undefined && (obj.quote = message.quote);
    return obj;
  },

  create(base?: DeepPartial<QueryOraclePriceRequest>): QueryOraclePriceRequest {
    return QueryOraclePriceRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOraclePriceRequest>): QueryOraclePriceRequest {
    const message = createBaseQueryOraclePriceRequest();
    message.oracleType = object.oracleType ?? 0;
    message.base = object.base ?? "";
    message.quote = object.quote ?? "";
    return message;
  },
};

function createBasePricePairState(): PricePairState {
  return {
    pairPrice: "",
    basePrice: "",
    quotePrice: "",
    baseCumulativePrice: "",
    quoteCumulativePrice: "",
    baseTimestamp: "0",
    quoteTimestamp: "0",
  };
}

export const PricePairState = {
  encode(message: PricePairState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pairPrice !== "") {
      writer.uint32(10).string(message.pairPrice);
    }
    if (message.basePrice !== "") {
      writer.uint32(18).string(message.basePrice);
    }
    if (message.quotePrice !== "") {
      writer.uint32(26).string(message.quotePrice);
    }
    if (message.baseCumulativePrice !== "") {
      writer.uint32(34).string(message.baseCumulativePrice);
    }
    if (message.quoteCumulativePrice !== "") {
      writer.uint32(42).string(message.quoteCumulativePrice);
    }
    if (message.baseTimestamp !== "0") {
      writer.uint32(48).int64(message.baseTimestamp);
    }
    if (message.quoteTimestamp !== "0") {
      writer.uint32(56).int64(message.quoteTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PricePairState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricePairState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pairPrice = reader.string();
          break;
        case 2:
          message.basePrice = reader.string();
          break;
        case 3:
          message.quotePrice = reader.string();
          break;
        case 4:
          message.baseCumulativePrice = reader.string();
          break;
        case 5:
          message.quoteCumulativePrice = reader.string();
          break;
        case 6:
          message.baseTimestamp = longToString(reader.int64() as Long);
          break;
        case 7:
          message.quoteTimestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PricePairState {
    return {
      pairPrice: isSet(object.pairPrice) ? String(object.pairPrice) : "",
      basePrice: isSet(object.basePrice) ? String(object.basePrice) : "",
      quotePrice: isSet(object.quotePrice) ? String(object.quotePrice) : "",
      baseCumulativePrice: isSet(object.baseCumulativePrice) ? String(object.baseCumulativePrice) : "",
      quoteCumulativePrice: isSet(object.quoteCumulativePrice) ? String(object.quoteCumulativePrice) : "",
      baseTimestamp: isSet(object.baseTimestamp) ? String(object.baseTimestamp) : "0",
      quoteTimestamp: isSet(object.quoteTimestamp) ? String(object.quoteTimestamp) : "0",
    };
  },

  toJSON(message: PricePairState): unknown {
    const obj: any = {};
    message.pairPrice !== undefined && (obj.pairPrice = message.pairPrice);
    message.basePrice !== undefined && (obj.basePrice = message.basePrice);
    message.quotePrice !== undefined && (obj.quotePrice = message.quotePrice);
    message.baseCumulativePrice !== undefined && (obj.baseCumulativePrice = message.baseCumulativePrice);
    message.quoteCumulativePrice !== undefined && (obj.quoteCumulativePrice = message.quoteCumulativePrice);
    message.baseTimestamp !== undefined && (obj.baseTimestamp = message.baseTimestamp);
    message.quoteTimestamp !== undefined && (obj.quoteTimestamp = message.quoteTimestamp);
    return obj;
  },

  create(base?: DeepPartial<PricePairState>): PricePairState {
    return PricePairState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PricePairState>): PricePairState {
    const message = createBasePricePairState();
    message.pairPrice = object.pairPrice ?? "";
    message.basePrice = object.basePrice ?? "";
    message.quotePrice = object.quotePrice ?? "";
    message.baseCumulativePrice = object.baseCumulativePrice ?? "";
    message.quoteCumulativePrice = object.quoteCumulativePrice ?? "";
    message.baseTimestamp = object.baseTimestamp ?? "0";
    message.quoteTimestamp = object.quoteTimestamp ?? "0";
    return message;
  },
};

function createBaseQueryOraclePriceResponse(): QueryOraclePriceResponse {
  return { pricePairState: undefined };
}

export const QueryOraclePriceResponse = {
  encode(message: QueryOraclePriceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pricePairState !== undefined) {
      PricePairState.encode(message.pricePairState, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOraclePriceResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOraclePriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pricePairState = PricePairState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOraclePriceResponse {
    return {
      pricePairState: isSet(object.pricePairState) ? PricePairState.fromJSON(object.pricePairState) : undefined,
    };
  },

  toJSON(message: QueryOraclePriceResponse): unknown {
    const obj: any = {};
    message.pricePairState !== undefined &&
      (obj.pricePairState = message.pricePairState ? PricePairState.toJSON(message.pricePairState) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryOraclePriceResponse>): QueryOraclePriceResponse {
    return QueryOraclePriceResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOraclePriceResponse>): QueryOraclePriceResponse {
    const message = createBaseQueryOraclePriceResponse();
    message.pricePairState = (object.pricePairState !== undefined && object.pricePairState !== null)
      ? PricePairState.fromPartial(object.pricePairState)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Retrieves oracle params */
  Params(request: DeepPartial<QueryParamsRequest>, metadata?: grpc.Metadata): Promise<QueryParamsResponse>;
  /** Retrieves the band relayers */
  BandRelayers(
    request: DeepPartial<QueryBandRelayersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandRelayersResponse>;
  /** Retrieves the state for all band price feeds */
  BandPriceStates(
    request: DeepPartial<QueryBandPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandPriceStatesResponse>;
  /** Retrieves the state for all band ibc price feeds */
  BandIBCPriceStates(
    request: DeepPartial<QueryBandIBCPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandIBCPriceStatesResponse>;
  /** Retrieves the state for all price feeds */
  PriceFeedPriceStates(
    request: DeepPartial<QueryPriceFeedPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPriceFeedPriceStatesResponse>;
  /** Retrieves the state for all coinbase price feeds */
  CoinbasePriceStates(
    request: DeepPartial<QueryCoinbasePriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryCoinbasePriceStatesResponse>;
  /** Retrieves the state for all pyth price feeds */
  PythPriceStates(
    request: DeepPartial<QueryPythPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPythPriceStatesResponse>;
  /** Retrieves the state for all provider price feeds */
  ProviderPriceState(
    request: DeepPartial<QueryProviderPriceStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryProviderPriceStateResponse>;
  /** Retrieves the entire oracle module's state */
  OracleModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse>;
  /** Retrieves historical price records for a given OracleType and Symbol */
  HistoricalPriceRecords(
    request: DeepPartial<QueryHistoricalPriceRecordsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryHistoricalPriceRecordsResponse>;
  /** Retrieves mixed volatility value for the specified pair of base/quote */
  OracleVolatility(
    request: DeepPartial<QueryOracleVolatilityRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleVolatilityResponse>;
  OracleProvidersInfo(
    request: DeepPartial<QueryOracleProvidersInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleProvidersInfoResponse>;
  OracleProviderPrices(
    request: DeepPartial<QueryOracleProviderPricesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleProviderPricesResponse>;
  OraclePrice(
    request: DeepPartial<QueryOraclePriceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOraclePriceResponse>;
  PythPrice(request: DeepPartial<QueryPythPriceRequest>, metadata?: grpc.Metadata): Promise<QueryPythPriceResponse>;
}

export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.BandRelayers = this.BandRelayers.bind(this);
    this.BandPriceStates = this.BandPriceStates.bind(this);
    this.BandIBCPriceStates = this.BandIBCPriceStates.bind(this);
    this.PriceFeedPriceStates = this.PriceFeedPriceStates.bind(this);
    this.CoinbasePriceStates = this.CoinbasePriceStates.bind(this);
    this.PythPriceStates = this.PythPriceStates.bind(this);
    this.ProviderPriceState = this.ProviderPriceState.bind(this);
    this.OracleModuleState = this.OracleModuleState.bind(this);
    this.HistoricalPriceRecords = this.HistoricalPriceRecords.bind(this);
    this.OracleVolatility = this.OracleVolatility.bind(this);
    this.OracleProvidersInfo = this.OracleProvidersInfo.bind(this);
    this.OracleProviderPrices = this.OracleProviderPrices.bind(this);
    this.OraclePrice = this.OraclePrice.bind(this);
    this.PythPrice = this.PythPrice.bind(this);
  }

  Params(request: DeepPartial<QueryParamsRequest>, metadata?: grpc.Metadata): Promise<QueryParamsResponse> {
    return this.rpc.unary(QueryParamsDesc, QueryParamsRequest.fromPartial(request), metadata);
  }

  BandRelayers(
    request: DeepPartial<QueryBandRelayersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandRelayersResponse> {
    return this.rpc.unary(QueryBandRelayersDesc, QueryBandRelayersRequest.fromPartial(request), metadata);
  }

  BandPriceStates(
    request: DeepPartial<QueryBandPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandPriceStatesResponse> {
    return this.rpc.unary(QueryBandPriceStatesDesc, QueryBandPriceStatesRequest.fromPartial(request), metadata);
  }

  BandIBCPriceStates(
    request: DeepPartial<QueryBandIBCPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBandIBCPriceStatesResponse> {
    return this.rpc.unary(QueryBandIBCPriceStatesDesc, QueryBandIBCPriceStatesRequest.fromPartial(request), metadata);
  }

  PriceFeedPriceStates(
    request: DeepPartial<QueryPriceFeedPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPriceFeedPriceStatesResponse> {
    return this.rpc.unary(
      QueryPriceFeedPriceStatesDesc,
      QueryPriceFeedPriceStatesRequest.fromPartial(request),
      metadata,
    );
  }

  CoinbasePriceStates(
    request: DeepPartial<QueryCoinbasePriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryCoinbasePriceStatesResponse> {
    return this.rpc.unary(QueryCoinbasePriceStatesDesc, QueryCoinbasePriceStatesRequest.fromPartial(request), metadata);
  }

  PythPriceStates(
    request: DeepPartial<QueryPythPriceStatesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPythPriceStatesResponse> {
    return this.rpc.unary(QueryPythPriceStatesDesc, QueryPythPriceStatesRequest.fromPartial(request), metadata);
  }

  ProviderPriceState(
    request: DeepPartial<QueryProviderPriceStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryProviderPriceStateResponse> {
    return this.rpc.unary(QueryProviderPriceStateDesc, QueryProviderPriceStateRequest.fromPartial(request), metadata);
  }

  OracleModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse> {
    return this.rpc.unary(QueryOracleModuleStateDesc, QueryModuleStateRequest.fromPartial(request), metadata);
  }

  HistoricalPriceRecords(
    request: DeepPartial<QueryHistoricalPriceRecordsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryHistoricalPriceRecordsResponse> {
    return this.rpc.unary(
      QueryHistoricalPriceRecordsDesc,
      QueryHistoricalPriceRecordsRequest.fromPartial(request),
      metadata,
    );
  }

  OracleVolatility(
    request: DeepPartial<QueryOracleVolatilityRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleVolatilityResponse> {
    return this.rpc.unary(QueryOracleVolatilityDesc, QueryOracleVolatilityRequest.fromPartial(request), metadata);
  }

  OracleProvidersInfo(
    request: DeepPartial<QueryOracleProvidersInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleProvidersInfoResponse> {
    return this.rpc.unary(QueryOracleProvidersInfoDesc, QueryOracleProvidersInfoRequest.fromPartial(request), metadata);
  }

  OracleProviderPrices(
    request: DeepPartial<QueryOracleProviderPricesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOracleProviderPricesResponse> {
    return this.rpc.unary(
      QueryOracleProviderPricesDesc,
      QueryOracleProviderPricesRequest.fromPartial(request),
      metadata,
    );
  }

  OraclePrice(
    request: DeepPartial<QueryOraclePriceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOraclePriceResponse> {
    return this.rpc.unary(QueryOraclePriceDesc, QueryOraclePriceRequest.fromPartial(request), metadata);
  }

  PythPrice(request: DeepPartial<QueryPythPriceRequest>, metadata?: grpc.Metadata): Promise<QueryPythPriceResponse> {
    return this.rpc.unary(QueryPythPriceDesc, QueryPythPriceRequest.fromPartial(request), metadata);
  }
}

export const QueryDesc = { serviceName: "injective.oracle.v1beta1.Query" };

export const QueryParamsDesc: UnaryMethodDefinitionish = {
  methodName: "Params",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryParamsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryParamsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBandRelayersDesc: UnaryMethodDefinitionish = {
  methodName: "BandRelayers",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBandRelayersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBandRelayersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBandPriceStatesDesc: UnaryMethodDefinitionish = {
  methodName: "BandPriceStates",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBandPriceStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBandPriceStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBandIBCPriceStatesDesc: UnaryMethodDefinitionish = {
  methodName: "BandIBCPriceStates",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBandIBCPriceStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBandIBCPriceStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPriceFeedPriceStatesDesc: UnaryMethodDefinitionish = {
  methodName: "PriceFeedPriceStates",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPriceFeedPriceStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPriceFeedPriceStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryCoinbasePriceStatesDesc: UnaryMethodDefinitionish = {
  methodName: "CoinbasePriceStates",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryCoinbasePriceStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryCoinbasePriceStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPythPriceStatesDesc: UnaryMethodDefinitionish = {
  methodName: "PythPriceStates",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPythPriceStatesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPythPriceStatesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryProviderPriceStateDesc: UnaryMethodDefinitionish = {
  methodName: "ProviderPriceState",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryProviderPriceStateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryProviderPriceStateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOracleModuleStateDesc: UnaryMethodDefinitionish = {
  methodName: "OracleModuleState",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryModuleStateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryModuleStateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryHistoricalPriceRecordsDesc: UnaryMethodDefinitionish = {
  methodName: "HistoricalPriceRecords",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryHistoricalPriceRecordsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryHistoricalPriceRecordsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOracleVolatilityDesc: UnaryMethodDefinitionish = {
  methodName: "OracleVolatility",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryOracleVolatilityRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryOracleVolatilityResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOracleProvidersInfoDesc: UnaryMethodDefinitionish = {
  methodName: "OracleProvidersInfo",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryOracleProvidersInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryOracleProvidersInfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOracleProviderPricesDesc: UnaryMethodDefinitionish = {
  methodName: "OracleProviderPrices",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryOracleProviderPricesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryOracleProviderPricesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOraclePriceDesc: UnaryMethodDefinitionish = {
  methodName: "OraclePrice",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryOraclePriceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryOraclePriceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPythPriceDesc: UnaryMethodDefinitionish = {
  methodName: "PythPrice",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPythPriceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPythPriceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
