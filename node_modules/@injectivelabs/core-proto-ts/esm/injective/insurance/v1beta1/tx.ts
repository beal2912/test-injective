/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { OracleType, oracleTypeFromJSON, oracleTypeToJSON } from "../../oracle/v1beta1/oracle";

/** MsgCreateInsuranceFund a message to create an insurance fund for a derivative market. */
export interface MsgCreateInsuranceFund {
  /** Creator of the insurance fund. */
  sender: string;
  /** Ticker for the derivative market. */
  ticker: string;
  /** Coin denom to use for the market quote denom */
  quoteDenom: string;
  /** Oracle base currency of the derivative market OR the oracle symbol for the binary options market. */
  oracleBase: string;
  /** Oracle quote currency of the derivative market OR the oracle provider for the binary options market. */
  oracleQuote: string;
  /** Oracle type of the binary options or derivative market */
  oracleType: OracleType;
  /** Expiration time of the derivative market. Should be -1 for perpetual or -2 for binary options markets. */
  expiry: string;
  /** Initial deposit of the insurance fund */
  initialDeposit: Coin | undefined;
}

export interface MsgCreateInsuranceFundResponse {
}

/** MsgUnderwrite defines a message for depositing coins to underwrite an insurance fund */
export interface MsgUnderwrite {
  /** Address of the underwriter. */
  sender: string;
  /** MarketID of the insurance fund. */
  marketId: string;
  /** Amount of quote_denom to underwrite the insurance fund. */
  deposit: Coin | undefined;
}

export interface MsgUnderwriteResponse {
}

/** MsgRequestRedemption defines a message for requesting a redemption of the sender's insurance fund tokens */
export interface MsgRequestRedemption {
  /** Address of the underwriter requesting a redemption. */
  sender: string;
  /** MarketID of the insurance fund. */
  marketId: string;
  /** Insurance fund share token amount to be redeemed. */
  amount: Coin | undefined;
}

export interface MsgRequestRedemptionResponse {
}

function createBaseMsgCreateInsuranceFund(): MsgCreateInsuranceFund {
  return {
    sender: "",
    ticker: "",
    quoteDenom: "",
    oracleBase: "",
    oracleQuote: "",
    oracleType: 0,
    expiry: "0",
    initialDeposit: undefined,
  };
}

export const MsgCreateInsuranceFund = {
  encode(message: MsgCreateInsuranceFund, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ticker !== "") {
      writer.uint32(18).string(message.ticker);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(26).string(message.quoteDenom);
    }
    if (message.oracleBase !== "") {
      writer.uint32(34).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(42).string(message.oracleQuote);
    }
    if (message.oracleType !== 0) {
      writer.uint32(48).int32(message.oracleType);
    }
    if (message.expiry !== "0") {
      writer.uint32(56).int64(message.expiry);
    }
    if (message.initialDeposit !== undefined) {
      Coin.encode(message.initialDeposit, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateInsuranceFund {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateInsuranceFund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.ticker = reader.string();
          break;
        case 3:
          message.quoteDenom = reader.string();
          break;
        case 4:
          message.oracleBase = reader.string();
          break;
        case 5:
          message.oracleQuote = reader.string();
          break;
        case 6:
          message.oracleType = reader.int32() as any;
          break;
        case 7:
          message.expiry = longToString(reader.int64() as Long);
          break;
        case 8:
          message.initialDeposit = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateInsuranceFund {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      expiry: isSet(object.expiry) ? String(object.expiry) : "0",
      initialDeposit: isSet(object.initialDeposit) ? Coin.fromJSON(object.initialDeposit) : undefined,
    };
  },

  toJSON(message: MsgCreateInsuranceFund): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.expiry !== undefined && (obj.expiry = message.expiry);
    message.initialDeposit !== undefined &&
      (obj.initialDeposit = message.initialDeposit ? Coin.toJSON(message.initialDeposit) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateInsuranceFund>): MsgCreateInsuranceFund {
    return MsgCreateInsuranceFund.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateInsuranceFund>): MsgCreateInsuranceFund {
    const message = createBaseMsgCreateInsuranceFund();
    message.sender = object.sender ?? "";
    message.ticker = object.ticker ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.expiry = object.expiry ?? "0";
    message.initialDeposit = (object.initialDeposit !== undefined && object.initialDeposit !== null)
      ? Coin.fromPartial(object.initialDeposit)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateInsuranceFundResponse(): MsgCreateInsuranceFundResponse {
  return {};
}

export const MsgCreateInsuranceFundResponse = {
  encode(_: MsgCreateInsuranceFundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateInsuranceFundResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateInsuranceFundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCreateInsuranceFundResponse {
    return {};
  },

  toJSON(_: MsgCreateInsuranceFundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCreateInsuranceFundResponse>): MsgCreateInsuranceFundResponse {
    return MsgCreateInsuranceFundResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgCreateInsuranceFundResponse>): MsgCreateInsuranceFundResponse {
    const message = createBaseMsgCreateInsuranceFundResponse();
    return message;
  },
};

function createBaseMsgUnderwrite(): MsgUnderwrite {
  return { sender: "", marketId: "", deposit: undefined };
}

export const MsgUnderwrite = {
  encode(message: MsgUnderwrite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.deposit !== undefined) {
      Coin.encode(message.deposit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnderwrite {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnderwrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.deposit = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnderwrite {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      deposit: isSet(object.deposit) ? Coin.fromJSON(object.deposit) : undefined,
    };
  },

  toJSON(message: MsgUnderwrite): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.deposit !== undefined && (obj.deposit = message.deposit ? Coin.toJSON(message.deposit) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgUnderwrite>): MsgUnderwrite {
    return MsgUnderwrite.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgUnderwrite>): MsgUnderwrite {
    const message = createBaseMsgUnderwrite();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.deposit = (object.deposit !== undefined && object.deposit !== null)
      ? Coin.fromPartial(object.deposit)
      : undefined;
    return message;
  },
};

function createBaseMsgUnderwriteResponse(): MsgUnderwriteResponse {
  return {};
}

export const MsgUnderwriteResponse = {
  encode(_: MsgUnderwriteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnderwriteResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnderwriteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUnderwriteResponse {
    return {};
  },

  toJSON(_: MsgUnderwriteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUnderwriteResponse>): MsgUnderwriteResponse {
    return MsgUnderwriteResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgUnderwriteResponse>): MsgUnderwriteResponse {
    const message = createBaseMsgUnderwriteResponse();
    return message;
  },
};

function createBaseMsgRequestRedemption(): MsgRequestRedemption {
  return { sender: "", marketId: "", amount: undefined };
}

export const MsgRequestRedemption = {
  encode(message: MsgRequestRedemption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRequestRedemption {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestRedemption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgRequestRedemption {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgRequestRedemption): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgRequestRedemption>): MsgRequestRedemption {
    return MsgRequestRedemption.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgRequestRedemption>): MsgRequestRedemption {
    const message = createBaseMsgRequestRedemption();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgRequestRedemptionResponse(): MsgRequestRedemptionResponse {
  return {};
}

export const MsgRequestRedemptionResponse = {
  encode(_: MsgRequestRedemptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRequestRedemptionResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestRedemptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgRequestRedemptionResponse {
    return {};
  },

  toJSON(_: MsgRequestRedemptionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRequestRedemptionResponse>): MsgRequestRedemptionResponse {
    return MsgRequestRedemptionResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgRequestRedemptionResponse>): MsgRequestRedemptionResponse {
    const message = createBaseMsgRequestRedemptionResponse();
    return message;
  },
};

/** Msg defines the insurance Msg service. */
export interface Msg {
  /** CreateInsuranceFund defines a method for creating an insurance fund */
  CreateInsuranceFund(
    request: DeepPartial<MsgCreateInsuranceFund>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateInsuranceFundResponse>;
  /** Underwrite defines a method for depositing tokens to underwrite an insurance fund */
  Underwrite(request: DeepPartial<MsgUnderwrite>, metadata?: grpc.Metadata): Promise<MsgUnderwriteResponse>;
  /** RequestRedemption defines a method for requesting a redemption of the sender's insurance fund tokens */
  RequestRedemption(
    request: DeepPartial<MsgRequestRedemption>,
    metadata?: grpc.Metadata,
  ): Promise<MsgRequestRedemptionResponse>;
}

export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.CreateInsuranceFund = this.CreateInsuranceFund.bind(this);
    this.Underwrite = this.Underwrite.bind(this);
    this.RequestRedemption = this.RequestRedemption.bind(this);
  }

  CreateInsuranceFund(
    request: DeepPartial<MsgCreateInsuranceFund>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateInsuranceFundResponse> {
    return this.rpc.unary(MsgCreateInsuranceFundDesc, MsgCreateInsuranceFund.fromPartial(request), metadata);
  }

  Underwrite(request: DeepPartial<MsgUnderwrite>, metadata?: grpc.Metadata): Promise<MsgUnderwriteResponse> {
    return this.rpc.unary(MsgUnderwriteDesc, MsgUnderwrite.fromPartial(request), metadata);
  }

  RequestRedemption(
    request: DeepPartial<MsgRequestRedemption>,
    metadata?: grpc.Metadata,
  ): Promise<MsgRequestRedemptionResponse> {
    return this.rpc.unary(MsgRequestRedemptionDesc, MsgRequestRedemption.fromPartial(request), metadata);
  }
}

export const MsgDesc = { serviceName: "injective.insurance.v1beta1.Msg" };

export const MsgCreateInsuranceFundDesc: UnaryMethodDefinitionish = {
  methodName: "CreateInsuranceFund",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateInsuranceFund.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateInsuranceFundResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgUnderwriteDesc: UnaryMethodDefinitionish = {
  methodName: "Underwrite",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgUnderwrite.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgUnderwriteResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgRequestRedemptionDesc: UnaryMethodDefinitionish = {
  methodName: "RequestRedemption",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgRequestRedemption.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgRequestRedemptionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
