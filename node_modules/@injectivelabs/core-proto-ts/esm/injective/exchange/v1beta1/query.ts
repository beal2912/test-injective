/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { MetadataStatistics } from "../../oracle/v1beta1/oracle";
import {
  AggregateAccountVolumeRecord,
  BinaryOptionsMarket,
  CampaignRewardPool,
  DenomDecimals,
  Deposit,
  DerivativeMarket,
  ExpiryFuturesMarketInfo,
  FeeDiscountSchedule,
  FeeDiscountTierInfo,
  FeeDiscountTierTTL,
  Level,
  MarketVolume,
  Params,
  PerpetualMarketFunding,
  PerpetualMarketInfo,
  Position,
  SpotMarket,
  SubaccountOrderbookMetadata,
  SubaccountOrderData,
  TradeRecord,
  TradeRecords,
  TradingRewardCampaignInfo,
  VolumeRecord,
} from "./exchange";
import { Balance, DerivativePosition, GenesisState } from "./genesis";

/** CancellationStrategy is the list of cancellation strategies. */
export enum CancellationStrategy {
  /** UnspecifiedOrder - just cancelling in random order in most efficient way */
  UnspecifiedOrder = 0,
  /** FromWorstToBest - e.g. for buy orders from lowest to highest price */
  FromWorstToBest = 1,
  /** FromBestToWorst - e.g. for buy orders from higest to lowest price */
  FromBestToWorst = 2,
  UNRECOGNIZED = -1,
}

export function cancellationStrategyFromJSON(object: any): CancellationStrategy {
  switch (object) {
    case 0:
    case "UnspecifiedOrder":
      return CancellationStrategy.UnspecifiedOrder;
    case 1:
    case "FromWorstToBest":
      return CancellationStrategy.FromWorstToBest;
    case 2:
    case "FromBestToWorst":
      return CancellationStrategy.FromBestToWorst;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CancellationStrategy.UNRECOGNIZED;
  }
}

export function cancellationStrategyToJSON(object: CancellationStrategy): string {
  switch (object) {
    case CancellationStrategy.UnspecifiedOrder:
      return "UnspecifiedOrder";
    case CancellationStrategy.FromWorstToBest:
      return "FromWorstToBest";
    case CancellationStrategy.FromBestToWorst:
      return "FromBestToWorst";
    case CancellationStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Subaccount {
  trader: string;
  subaccountNonce: number;
}

export interface QuerySubaccountOrdersRequest {
  subaccountId: string;
  marketId: string;
}

export interface QuerySubaccountOrdersResponse {
  buyOrders: SubaccountOrderData[];
  sellOrders: SubaccountOrderData[];
}

export interface SubaccountOrderbookMetadataWithMarket {
  metadata: SubaccountOrderbookMetadata | undefined;
  marketId: string;
  isBuy: boolean;
}

/** QueryExchangeParamsRequest is the request type for the Query/ExchangeParams RPC method. */
export interface QueryExchangeParamsRequest {
}

/** QueryExchangeParamsRequest is the response type for the Query/ExchangeParams RPC method. */
export interface QueryExchangeParamsResponse {
  params: Params | undefined;
}

/** QuerySubaccountDepositsRequest is the request type for the Query/SubaccountDeposits RPC method. */
export interface QuerySubaccountDepositsRequest {
  subaccountId: string;
  subaccount: Subaccount | undefined;
}

/** QuerySubaccountDepositsResponse is the response type for the Query/SubaccountDeposits RPC method. */
export interface QuerySubaccountDepositsResponse {
  deposits: { [key: string]: Deposit };
}

export interface QuerySubaccountDepositsResponse_DepositsEntry {
  key: string;
  value: Deposit | undefined;
}

/** QueryExchangeBalancesRequest is the request type for the Query/ExchangeBalances RPC method. */
export interface QueryExchangeBalancesRequest {
}

/** QuerySubaccountDepositsResponse is the response type for the Query/SubaccountDeposits RPC method. */
export interface QueryExchangeBalancesResponse {
  balances: Balance[];
}

/** QueryAggregateVolumeRequest is the request type for the Query/AggregateVolume RPC method. */
export interface QueryAggregateVolumeRequest {
  /** can either be an address or a subaccount */
  account: string;
}

/** QueryAggregateVolumeResponse is the response type for the Query/AggregateVolume RPC method. */
export interface QueryAggregateVolumeResponse {
  /** if an address is specified, then the aggregate_volumes will aggregate the volumes across all subaccounts for the address */
  aggregateVolumes: MarketVolume[];
}

/** QueryAggregateVolumesRequest is the request type for the Query/AggregateVolumes RPC method. */
export interface QueryAggregateVolumesRequest {
  accounts: string[];
  marketIds: string[];
}

/** QueryAggregateVolumesResponse is the response type for the Query/AggregateVolumes RPC method. */
export interface QueryAggregateVolumesResponse {
  /** the aggregate volume records for the accounts specified */
  aggregateAccountVolumes: AggregateAccountVolumeRecord[];
  /** the aggregate volumes for the markets specified */
  aggregateMarketVolumes: MarketVolume[];
}

/** QueryAggregateMarketVolumeRequest is the request type for the Query/AggregateMarketVolume RPC method. */
export interface QueryAggregateMarketVolumeRequest {
  marketId: string;
}

/** QueryAggregateMarketVolumeResponse is the response type for the Query/AggregateMarketVolume RPC method. */
export interface QueryAggregateMarketVolumeResponse {
  volume: VolumeRecord | undefined;
}

/** QueryDenomDecimalRequest is the request type for the Query/DenomDecimal RPC method. */
export interface QueryDenomDecimalRequest {
  denom: string;
}

/** QueryDenomDecimalResponse is the response type for the Query/DenomDecimal RPC method. */
export interface QueryDenomDecimalResponse {
  decimal: string;
}

/** QueryDenomDecimalsRequest is the request type for the Query/DenomDecimals RPC method. */
export interface QueryDenomDecimalsRequest {
  /** denoms can be empty to query all denom decimals */
  denoms: string[];
}

/** QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals RPC method. */
export interface QueryDenomDecimalsResponse {
  denomDecimals: DenomDecimals[];
}

/** QueryAggregateMarketVolumesRequest is the request type for the Query/AggregateMarketVolumes RPC method. */
export interface QueryAggregateMarketVolumesRequest {
  marketIds: string[];
}

/** QueryAggregateMarketVolumesResponse is the response type for the Query/AggregateMarketVolumes RPC method. */
export interface QueryAggregateMarketVolumesResponse {
  /** the aggregate volumes for the entire market */
  volumes: MarketVolume[];
}

/** QuerySubaccountDepositsRequest is the request type for the Query/SubaccountDeposits RPC method. */
export interface QuerySubaccountDepositRequest {
  subaccountId: string;
  denom: string;
}

/** QuerySubaccountDepositsResponse is the response type for the Query/SubaccountDeposits RPC method. */
export interface QuerySubaccountDepositResponse {
  deposits: Deposit | undefined;
}

/** QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC method. */
export interface QuerySpotMarketsRequest {
  /** Status of the market, for convenience it is set to string - not enum */
  status: string;
}

/** QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC method. */
export interface QuerySpotMarketsResponse {
  markets: SpotMarket[];
}

/** QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC method. */
export interface QuerySpotMarketRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC method. */
export interface QuerySpotMarketResponse {
  market: SpotMarket | undefined;
}

/** QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook RPC method. */
export interface QuerySpotOrderbookRequest {
  /** Market ID for the market */
  marketId: string;
  limit: string;
}

/** QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook RPC method. */
export interface QuerySpotOrderbookResponse {
  buysPriceLevel: Level[];
  sellsPriceLevel: Level[];
}

/** QueryTraderSpotOrdersRequest is the request type for the Query/TraderSpotOrders RPC method. */
export interface QuerySpotOrdersByHashesRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
  /** the order hashes */
  orderHashes: string[];
}

/** QuerySpotOrdersByHashesResponse is the response type for the Query/SpotOrdersByHashes RPC method. */
export interface QuerySpotOrdersByHashesResponse {
  orders: TrimmedSpotLimitOrder[];
}

/** QueryTraderSpotOrdersRequest is the request type for the Query/TraderSpotOrders RPC method. */
export interface QueryTraderSpotOrdersRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
}

export interface TrimmedSpotLimitOrder {
  /** price of the order */
  price: string;
  /** quantity of the order */
  quantity: string;
  /** the amount of the quantity remaining fillable */
  fillable: string;
  /** true if the order is a buy */
  isBuy: boolean;
  orderHash: string;
}

/** QueryTraderSpotOrdersResponse is the response type for the Query/TraderSpotOrders RPC method. */
export interface QueryTraderSpotOrdersResponse {
  orders: TrimmedSpotLimitOrder[];
}

/** QuerySpotMidPriceAndTOBRequest is the request type for the Query/SpotMidPriceAndTOB RPC method. */
export interface QuerySpotMidPriceAndTOBRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QuerySpotMidPriceAndTOBResponse is the response type for the Query/SpotMidPriceAndTOB RPC method. */
export interface QuerySpotMidPriceAndTOBResponse {
  /** mid price of the market */
  midPrice: string;
  /** best buy price of the market */
  bestBuyPrice: string;
  /** best sell price of the market */
  bestSellPrice: string;
}

/** QueryDerivativeMidPriceAndTOBRequest is the request type for the Query/GetDerivativeMidPriceAndTOB RPC method. */
export interface QueryDerivativeMidPriceAndTOBRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QueryDerivativeMidPriceAndTOBResponse is the response type for the Query/GetDerivativeMidPriceAndTOB RPC method. */
export interface QueryDerivativeMidPriceAndTOBResponse {
  /** mid price of the market */
  midPrice: string;
  /** best buy price of the market */
  bestBuyPrice: string;
  /** best sell price of the market */
  bestSellPrice: string;
}

/** QueryDerivativeOrderbookRequest is the request type for the Query/DerivativeOrderbook RPC method. */
export interface QueryDerivativeOrderbookRequest {
  /** Market ID for the market */
  marketId: string;
  limit: string;
}

/** QueryDerivativeOrderbookResponse is the response type for the Query/DerivativeOrderbook RPC method. */
export interface QueryDerivativeOrderbookResponse {
  buysPriceLevel: Level[];
  sellsPriceLevel: Level[];
}

/** QueryTraderSpotOrdersToCancelUpToAmountRequest is the request type for the Query/TraderSpotOrdersToCancelUpToAmountRequest RPC method. */
export interface QueryTraderSpotOrdersToCancelUpToAmountRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
  /** the base amount to cancel (free up) */
  baseAmount: string;
  /** the quote amount to cancel (free up) */
  quoteAmount: string;
  /** The cancellation strategy */
  strategy: CancellationStrategy;
  /** The reference price for the cancellation strategy, e.g. mid price or mark price */
  referencePrice: string;
}

/** QueryTraderDerivativeOrdersToCancelUpToAmountRequest is the request type for the Query/TraderDerivativeOrdersToCancelUpToAmountRequest RPC method. */
export interface QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
  /** the quote amount to cancel (free up) */
  quoteAmount: string;
  /** The cancellation strategy */
  strategy: CancellationStrategy;
  /** The reference price for the cancellation strategy, e.g. mid price or mark price */
  referencePrice: string;
}

/** QueryTraderDerivativeOrdersRequest is the request type for the Query/TraderDerivativeOrders RPC method. */
export interface QueryTraderDerivativeOrdersRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
}

export interface TrimmedDerivativeLimitOrder {
  /** price of the order */
  price: string;
  /** quantity of the order */
  quantity: string;
  /** margin of the order */
  margin: string;
  /** the amount of the quantity remaining fillable */
  fillable: string;
  /** true if the order is a buy */
  isBuy: boolean;
  orderHash: string;
}

/** QueryTraderDerivativeOrdersResponse is the response type for the Query/TraderDerivativeOrders RPC method. */
export interface QueryTraderDerivativeOrdersResponse {
  orders: TrimmedDerivativeLimitOrder[];
}

/** QueryTraderDerivativeOrdersRequest is the request type for the Query/TraderDerivativeOrders RPC method. */
export interface QueryDerivativeOrdersByHashesRequest {
  /** Market ID for the market */
  marketId: string;
  /** SubaccountID of the trader */
  subaccountId: string;
  /** the order hashes */
  orderHashes: string[];
}

/** QueryDerivativeOrdersByHashesResponse is the response type for the Query/DerivativeOrdersByHashes RPC method. */
export interface QueryDerivativeOrdersByHashesResponse {
  orders: TrimmedDerivativeLimitOrder[];
}

/** QueryDerivativeMarketsRequest is the request type for the Query/DerivativeMarkets RPC method. */
export interface QueryDerivativeMarketsRequest {
  /** Status of the market, for convenience it is set to string - not enum */
  status: string;
}

export interface PriceLevel {
  price: string;
  /** quantity */
  quantity: string;
}

export interface PerpetualMarketState {
  marketInfo: PerpetualMarketInfo | undefined;
  fundingInfo: PerpetualMarketFunding | undefined;
}

export interface FullDerivativeMarket {
  market: DerivativeMarket | undefined;
  perpetualInfo?: PerpetualMarketState | undefined;
  futuresInfo?: ExpiryFuturesMarketInfo | undefined;
  markPrice: string;
}

/** QueryDerivativeMarketsResponse is the response type for the Query/DerivativeMarkets RPC method. */
export interface QueryDerivativeMarketsResponse {
  markets: FullDerivativeMarket[];
}

/** QueryDerivativeMarketRequest is the request type for the Query/DerivativeMarket RPC method. */
export interface QueryDerivativeMarketRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QueryDerivativeMarketResponse is the response type for the Query/DerivativeMarket RPC method. */
export interface QueryDerivativeMarketResponse {
  market: FullDerivativeMarket | undefined;
}

/** QueryDerivativeMarketAddressRequest is the request type for the Query/DerivativeMarketAddress RPC method. */
export interface QueryDerivativeMarketAddressRequest {
  /** Market ID for the market */
  marketId: string;
}

/** QueryDerivativeMarketAddressResponse is the response type for the Query/DerivativeMarketAddress RPC method. */
export interface QueryDerivativeMarketAddressResponse {
  /** address for the market */
  address: string;
  /** subaccountID for the market */
  subaccountId: string;
}

/** QuerySubaccountTradeNonceRequest is the request type for the Query/SubaccountTradeNonce RPC method. */
export interface QuerySubaccountTradeNonceRequest {
  subaccountId: string;
}

/** QuerySubaccountPositionsRequest is the request type for the Query/SubaccountPositions RPC method. */
export interface QuerySubaccountPositionsRequest {
  subaccountId: string;
}

/** QuerySubaccountPositionInMarketRequest is the request type for the Query/SubaccountPositionInMarket RPC method. */
export interface QuerySubaccountPositionInMarketRequest {
  subaccountId: string;
  marketId: string;
}

/** QuerySubaccountEffectivePositionInMarketRequest is the request type for the Query/SubaccountEffectivePositionInMarket RPC method. */
export interface QuerySubaccountEffectivePositionInMarketRequest {
  subaccountId: string;
  marketId: string;
}

/** QuerySubaccountOrderMetadataRequest is the request type for the Query/SubaccountOrderMetadata RPC method. */
export interface QuerySubaccountOrderMetadataRequest {
  subaccountId: string;
}

/** QuerySubaccountPositionsResponse is the response type for the Query/SubaccountPositions RPC method. */
export interface QuerySubaccountPositionsResponse {
  state: DerivativePosition[];
}

/** QuerySubaccountPositionInMarketResponse is the response type for the Query/SubaccountPositionInMarket RPC method. */
export interface QuerySubaccountPositionInMarketResponse {
  state: Position | undefined;
}

export interface EffectivePosition {
  isLong: boolean;
  quantity: string;
  entryPrice: string;
  effectiveMargin: string;
}

/** QuerySubaccountEffectivePositionInMarketResponse is the response type for the Query/SubaccountEffectivePositionInMarket RPC method. */
export interface QuerySubaccountEffectivePositionInMarketResponse {
  state: EffectivePosition | undefined;
}

/** QueryPerpetualMarketInfoRequest is the request type for the Query/PerpetualMarketInfo RPC method. */
export interface QueryPerpetualMarketInfoRequest {
  marketId: string;
}

/** QueryPerpetualMarketInfoResponse is the response type for the Query/PerpetualMarketInfo RPC method. */
export interface QueryPerpetualMarketInfoResponse {
  info: PerpetualMarketInfo | undefined;
}

/** QueryExpiryFuturesMarketInfoRequest is the request type for the Query/ ExpiryFuturesMarketInfo RPC method. */
export interface QueryExpiryFuturesMarketInfoRequest {
  marketId: string;
}

/** QueryExpiryFuturesMarketInfoResponse is the response type for the Query/ ExpiryFuturesMarketInfo RPC method. */
export interface QueryExpiryFuturesMarketInfoResponse {
  info: ExpiryFuturesMarketInfo | undefined;
}

/** QueryPerpetualMarketFundingRequest is the request type for the Query/PerpetualMarketFunding RPC method. */
export interface QueryPerpetualMarketFundingRequest {
  marketId: string;
}

/** QueryPerpetualMarketFundingResponse is the response type for the Query/PerpetualMarketFunding RPC method. */
export interface QueryPerpetualMarketFundingResponse {
  state: PerpetualMarketFunding | undefined;
}

/** QuerySubaccountOrderMetadataResponse is the response type for the Query/SubaccountOrderMetadata RPC method. */
export interface QuerySubaccountOrderMetadataResponse {
  metadata: SubaccountOrderbookMetadataWithMarket[];
}

/** QuerySubaccountTradeNonceResponse is the response type for the Query/SubaccountTradeNonce RPC method. */
export interface QuerySubaccountTradeNonceResponse {
  nonce: number;
}

/** QueryModuleStateRequest is the request type for the Query/ExchangeModuleState RPC method. */
export interface QueryModuleStateRequest {
}

/** QueryModuleStateResponse is the response type for the Query/ExchangeModuleState RPC method. */
export interface QueryModuleStateResponse {
  state: GenesisState | undefined;
}

/** QueryPositionsRequest is the request type for the Query/Positions RPC method. */
export interface QueryPositionsRequest {
}

/** QueryPositionsResponse is the response type for the Query/Positions RPC method. */
export interface QueryPositionsResponse {
  state: DerivativePosition[];
}

/** QueryTradeRewardPointsRequest is the request type for the Query/TradeRewardPoints RPC method. */
export interface QueryTradeRewardPointsRequest {
  accounts: string[];
  pendingPoolTimestamp: string;
}

/** QueryTradeRewardPointsResponse is the response type for the Query/TradeRewardPoints RPC method. */
export interface QueryTradeRewardPointsResponse {
  accountTradeRewardPoints: string[];
}

/** QueryTradeRewardCampaignRequest is the request type for the Query/TradeRewardCampaign RPC method. */
export interface QueryTradeRewardCampaignRequest {
}

/** QueryTradeRewardCampaignResponse is the response type for the Query/TradeRewardCampaign RPC method. */
export interface QueryTradeRewardCampaignResponse {
  tradingRewardCampaignInfo: TradingRewardCampaignInfo | undefined;
  tradingRewardPoolCampaignSchedule: CampaignRewardPool[];
  totalTradeRewardPoints: string;
  pendingTradingRewardPoolCampaignSchedule: CampaignRewardPool[];
  pendingTotalTradeRewardPoints: string[];
}

/** QueryIsRegisteredDMMRequest is the request type for the Query/IsRegisteredDMM RPC method. */
export interface QueryIsOptedOutOfRewardsRequest {
  account: string;
}

/** QueryIsRegisteredDMMResponse is the response type for the Query/IsRegisteredDMM RPC method. */
export interface QueryIsOptedOutOfRewardsResponse {
  isOptedOut: boolean;
}

/** QueryRegisteredDMMsRequest is the request type for the Query/RegisteredDMMs RPC method. */
export interface QueryOptedOutOfRewardsAccountsRequest {
}

/** QueryRegisteredDMMsResponse is the response type for the Query/RegisteredDMMs RPC method. */
export interface QueryOptedOutOfRewardsAccountsResponse {
  accounts: string[];
}

/** QueryFeeDiscountAccountInfoRequest is the request type for the Query/FeeDiscountAccountInfo RPC method. */
export interface QueryFeeDiscountAccountInfoRequest {
  account: string;
}

/** QueryFeeDiscountAccountInfoResponse is the response type for the Query/FeeDiscountAccountInfo RPC method. */
export interface QueryFeeDiscountAccountInfoResponse {
  tierLevel: string;
  accountInfo: FeeDiscountTierInfo | undefined;
  accountTtl: FeeDiscountTierTTL | undefined;
}

/** QueryFeeDiscountScheduleRequest is the request type for the Query/FeeDiscountSchedule RPC method. */
export interface QueryFeeDiscountScheduleRequest {
}

/** QueryFeeDiscountScheduleResponse is the response type for the Query/FeeDiscountSchedule RPC method. */
export interface QueryFeeDiscountScheduleResponse {
  feeDiscountSchedule: FeeDiscountSchedule | undefined;
}

/** QueryBalanceMismatchesRequest is the request type for the Query/QueryBalanceMismatches RPC method. */
export interface QueryBalanceMismatchesRequest {
  dustFactor: string;
}

export interface BalanceMismatch {
  subaccountId: string;
  denom: string;
  available: string;
  total: string;
  balanceHold: string;
  expectedTotal: string;
  difference: string;
}

/** QueryBalanceMismatchesResponse is the response type for the Query/QueryBalanceMismatches RPC method. */
export interface QueryBalanceMismatchesResponse {
  balanceMismatches: BalanceMismatch[];
}

/** QueryBalanceWithBalanceHoldsRequest is the request type for the Query/QueryBalanceWithBalanceHolds RPC method. */
export interface QueryBalanceWithBalanceHoldsRequest {
}

export interface BalanceWithMarginHold {
  subaccountId: string;
  denom: string;
  available: string;
  total: string;
  balanceHold: string;
}

/** QueryBalanceWithBalanceHoldsResponse is the response type for the Query/QueryBalanceWithBalanceHolds RPC method. */
export interface QueryBalanceWithBalanceHoldsResponse {
  balanceWithBalanceHolds: BalanceWithMarginHold[];
}

/** QueryFeeDiscountTierStatisticsRequest is the request type for the Query/QueryFeeDiscountTierStatistics RPC method. */
export interface QueryFeeDiscountTierStatisticsRequest {
}

export interface TierStatistic {
  tier: string;
  count: string;
}

/** QueryFeeDiscountTierStatisticsResponse is the response type for the Query/QueryFeeDiscountTierStatistics RPC method. */
export interface QueryFeeDiscountTierStatisticsResponse {
  statistics: TierStatistic[];
}

/** MitoVaultInfosRequest is the request type for the Query/MitoVaultInfos RPC method. */
export interface MitoVaultInfosRequest {
}

/** MitoVaultInfosResponse is the response type for the Query/MitoVaultInfos RPC method. */
export interface MitoVaultInfosResponse {
  masterAddresses: string[];
  derivativeAddresses: string[];
  spotAddresses: string[];
  cw20Addresses: string[];
}

/** QueryMarketIDFromVaultRequest is the request type for the Query/QueryMarketIDFromVault RPC method. */
export interface QueryMarketIDFromVaultRequest {
  vaultSubaccountId: string;
}

/** QueryMarketIDFromVaultResponse is the response type for the Query/QueryMarketIDFromVault RPC method. */
export interface QueryMarketIDFromVaultResponse {
  marketId: string;
}

export interface QueryHistoricalTradeRecordsRequest {
  marketId: string;
}

export interface QueryHistoricalTradeRecordsResponse {
  tradeRecords: TradeRecords[];
}

/** TradeHistoryOptions are the optional params for Query/MarketVolatility RPC method. */
export interface TradeHistoryOptions {
  /** TradeGroupingSec of 0 means use the chain's default grouping */
  tradeGroupingSec: string;
  /**
   * MaxAge restricts the trade records oldest age in seconds from the current block time to consider.
   * A value of 0 means use all the records present on the chain.
   */
  maxAge: string;
  /** If IncludeRawHistory is true, the raw underlying data used for the computation is included in the response */
  includeRawHistory: boolean;
  /** If IncludeMetadata is true, metadata on the computation is included in the response */
  includeMetadata: boolean;
}

/** QueryMarketVolatilityRequest are the request params for the Query/MarketVolatility RPC method. */
export interface QueryMarketVolatilityRequest {
  marketId: string;
  tradeHistoryOptions: TradeHistoryOptions | undefined;
}

/** QueryMarketVolatilityResponse is the response type for the Query/MarketVolatility RPC method. */
export interface QueryMarketVolatilityResponse {
  volatility: string;
  historyMetadata: MetadataStatistics | undefined;
  rawHistory: TradeRecord[];
}

/** QuerBinaryMarketsRequest is the request type for the Query/BinaryMarkets RPC method. */
export interface QueryBinaryMarketsRequest {
  /** Status of the market, for convenience it is set to string - not enum */
  status: string;
}

/** QueryBinaryMarketsResponse is the response type for the Query/BinaryMarkets RPC method. */
export interface QueryBinaryMarketsResponse {
  markets: BinaryOptionsMarket[];
}

/** QueryConditionalOrdersRequest is the request type for the Query/ConditionalOrders RPC method. */
export interface QueryTraderDerivativeConditionalOrdersRequest {
  subaccountId: string;
  marketId: string;
}

export interface TrimmedDerivativeConditionalOrder {
  /** price of the order */
  price: string;
  /** quantity of the order */
  quantity: string;
  /** margin of the order */
  margin: string;
  /** price to trigger the order */
  triggerPrice: string;
  /** true if the order is a buy */
  isBuy: boolean;
  isLimit: boolean;
  orderHash: string;
}

/** QueryTraderDerivativeOrdersResponse is the response type for the Query/TraderDerivativeOrders RPC method. */
export interface QueryTraderDerivativeConditionalOrdersResponse {
  orders: TrimmedDerivativeConditionalOrder[];
}

export interface QueryMarketAtomicExecutionFeeMultiplierRequest {
  marketId: string;
}

export interface QueryMarketAtomicExecutionFeeMultiplierResponse {
  multiplier: string;
}

function createBaseSubaccount(): Subaccount {
  return { trader: "", subaccountNonce: 0 };
}

export const Subaccount = {
  encode(message: Subaccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trader !== "") {
      writer.uint32(10).string(message.trader);
    }
    if (message.subaccountNonce !== 0) {
      writer.uint32(16).uint32(message.subaccountNonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Subaccount {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trader = reader.string();
          break;
        case 2:
          message.subaccountNonce = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Subaccount {
    return {
      trader: isSet(object.trader) ? String(object.trader) : "",
      subaccountNonce: isSet(object.subaccountNonce) ? Number(object.subaccountNonce) : 0,
    };
  },

  toJSON(message: Subaccount): unknown {
    const obj: any = {};
    message.trader !== undefined && (obj.trader = message.trader);
    message.subaccountNonce !== undefined && (obj.subaccountNonce = Math.round(message.subaccountNonce));
    return obj;
  },

  create(base?: DeepPartial<Subaccount>): Subaccount {
    return Subaccount.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<Subaccount>): Subaccount {
    const message = createBaseSubaccount();
    message.trader = object.trader ?? "";
    message.subaccountNonce = object.subaccountNonce ?? 0;
    return message;
  },
};

function createBaseQuerySubaccountOrdersRequest(): QuerySubaccountOrdersRequest {
  return { subaccountId: "", marketId: "" };
}

export const QuerySubaccountOrdersRequest = {
  encode(message: QuerySubaccountOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountOrdersRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: QuerySubaccountOrdersRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountOrdersRequest>): QuerySubaccountOrdersRequest {
    return QuerySubaccountOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountOrdersRequest>): QuerySubaccountOrdersRequest {
    const message = createBaseQuerySubaccountOrdersRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountOrdersResponse(): QuerySubaccountOrdersResponse {
  return { buyOrders: [], sellOrders: [] };
}

export const QuerySubaccountOrdersResponse = {
  encode(message: QuerySubaccountOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buyOrders) {
      SubaccountOrderData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sellOrders) {
      SubaccountOrderData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buyOrders.push(SubaccountOrderData.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sellOrders.push(SubaccountOrderData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountOrdersResponse {
    return {
      buyOrders: Array.isArray(object?.buyOrders)
        ? object.buyOrders.map((e: any) => SubaccountOrderData.fromJSON(e))
        : [],
      sellOrders: Array.isArray(object?.sellOrders)
        ? object.sellOrders.map((e: any) => SubaccountOrderData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySubaccountOrdersResponse): unknown {
    const obj: any = {};
    if (message.buyOrders) {
      obj.buyOrders = message.buyOrders.map((e) => e ? SubaccountOrderData.toJSON(e) : undefined);
    } else {
      obj.buyOrders = [];
    }
    if (message.sellOrders) {
      obj.sellOrders = message.sellOrders.map((e) => e ? SubaccountOrderData.toJSON(e) : undefined);
    } else {
      obj.sellOrders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountOrdersResponse>): QuerySubaccountOrdersResponse {
    return QuerySubaccountOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountOrdersResponse>): QuerySubaccountOrdersResponse {
    const message = createBaseQuerySubaccountOrdersResponse();
    message.buyOrders = object.buyOrders?.map((e) => SubaccountOrderData.fromPartial(e)) || [];
    message.sellOrders = object.sellOrders?.map((e) => SubaccountOrderData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubaccountOrderbookMetadataWithMarket(): SubaccountOrderbookMetadataWithMarket {
  return { metadata: undefined, marketId: "", isBuy: false };
}

export const SubaccountOrderbookMetadataWithMarket = {
  encode(message: SubaccountOrderbookMetadataWithMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      SubaccountOrderbookMetadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.isBuy === true) {
      writer.uint32(24).bool(message.isBuy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubaccountOrderbookMetadataWithMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubaccountOrderbookMetadataWithMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadata = SubaccountOrderbookMetadata.decode(reader, reader.uint32());
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.isBuy = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubaccountOrderbookMetadataWithMarket {
    return {
      metadata: isSet(object.metadata) ? SubaccountOrderbookMetadata.fromJSON(object.metadata) : undefined,
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      isBuy: isSet(object.isBuy) ? Boolean(object.isBuy) : false,
    };
  },

  toJSON(message: SubaccountOrderbookMetadataWithMarket): unknown {
    const obj: any = {};
    message.metadata !== undefined &&
      (obj.metadata = message.metadata ? SubaccountOrderbookMetadata.toJSON(message.metadata) : undefined);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.isBuy !== undefined && (obj.isBuy = message.isBuy);
    return obj;
  },

  create(base?: DeepPartial<SubaccountOrderbookMetadataWithMarket>): SubaccountOrderbookMetadataWithMarket {
    return SubaccountOrderbookMetadataWithMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SubaccountOrderbookMetadataWithMarket>): SubaccountOrderbookMetadataWithMarket {
    const message = createBaseSubaccountOrderbookMetadataWithMarket();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? SubaccountOrderbookMetadata.fromPartial(object.metadata)
      : undefined;
    message.marketId = object.marketId ?? "";
    message.isBuy = object.isBuy ?? false;
    return message;
  },
};

function createBaseQueryExchangeParamsRequest(): QueryExchangeParamsRequest {
  return {};
}

export const QueryExchangeParamsRequest = {
  encode(_: QueryExchangeParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExchangeParamsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExchangeParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryExchangeParamsRequest {
    return {};
  },

  toJSON(_: QueryExchangeParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryExchangeParamsRequest>): QueryExchangeParamsRequest {
    return QueryExchangeParamsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryExchangeParamsRequest>): QueryExchangeParamsRequest {
    const message = createBaseQueryExchangeParamsRequest();
    return message;
  },
};

function createBaseQueryExchangeParamsResponse(): QueryExchangeParamsResponse {
  return { params: undefined };
}

export const QueryExchangeParamsResponse = {
  encode(message: QueryExchangeParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExchangeParamsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExchangeParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryExchangeParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryExchangeParamsResponse): unknown {
    const obj: any = {};
    message.params !== undefined && (obj.params = message.params ? Params.toJSON(message.params) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryExchangeParamsResponse>): QueryExchangeParamsResponse {
    return QueryExchangeParamsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryExchangeParamsResponse>): QueryExchangeParamsResponse {
    const message = createBaseQueryExchangeParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQuerySubaccountDepositsRequest(): QuerySubaccountDepositsRequest {
  return { subaccountId: "", subaccount: undefined };
}

export const QuerySubaccountDepositsRequest = {
  encode(message: QuerySubaccountDepositsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.subaccount !== undefined) {
      Subaccount.encode(message.subaccount, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountDepositsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountDepositsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.subaccount = Subaccount.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountDepositsRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      subaccount: isSet(object.subaccount) ? Subaccount.fromJSON(object.subaccount) : undefined,
    };
  },

  toJSON(message: QuerySubaccountDepositsRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.subaccount !== undefined &&
      (obj.subaccount = message.subaccount ? Subaccount.toJSON(message.subaccount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountDepositsRequest>): QuerySubaccountDepositsRequest {
    return QuerySubaccountDepositsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountDepositsRequest>): QuerySubaccountDepositsRequest {
    const message = createBaseQuerySubaccountDepositsRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.subaccount = (object.subaccount !== undefined && object.subaccount !== null)
      ? Subaccount.fromPartial(object.subaccount)
      : undefined;
    return message;
  },
};

function createBaseQuerySubaccountDepositsResponse(): QuerySubaccountDepositsResponse {
  return { deposits: {} };
}

export const QuerySubaccountDepositsResponse = {
  encode(message: QuerySubaccountDepositsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.deposits).forEach(([key, value]) => {
      QuerySubaccountDepositsResponse_DepositsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountDepositsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountDepositsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = QuerySubaccountDepositsResponse_DepositsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.deposits[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountDepositsResponse {
    return {
      deposits: isObject(object.deposits)
        ? Object.entries(object.deposits).reduce<{ [key: string]: Deposit }>((acc, [key, value]) => {
          acc[key] = Deposit.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QuerySubaccountDepositsResponse): unknown {
    const obj: any = {};
    obj.deposits = {};
    if (message.deposits) {
      Object.entries(message.deposits).forEach(([k, v]) => {
        obj.deposits[k] = Deposit.toJSON(v);
      });
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountDepositsResponse>): QuerySubaccountDepositsResponse {
    return QuerySubaccountDepositsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountDepositsResponse>): QuerySubaccountDepositsResponse {
    const message = createBaseQuerySubaccountDepositsResponse();
    message.deposits = Object.entries(object.deposits ?? {}).reduce<{ [key: string]: Deposit }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Deposit.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQuerySubaccountDepositsResponse_DepositsEntry(): QuerySubaccountDepositsResponse_DepositsEntry {
  return { key: "", value: undefined };
}

export const QuerySubaccountDepositsResponse_DepositsEntry = {
  encode(message: QuerySubaccountDepositsResponse_DepositsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Deposit.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountDepositsResponse_DepositsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountDepositsResponse_DepositsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Deposit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountDepositsResponse_DepositsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Deposit.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: QuerySubaccountDepositsResponse_DepositsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Deposit.toJSON(message.value) : undefined);
    return obj;
  },

  create(
    base?: DeepPartial<QuerySubaccountDepositsResponse_DepositsEntry>,
  ): QuerySubaccountDepositsResponse_DepositsEntry {
    return QuerySubaccountDepositsResponse_DepositsEntry.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QuerySubaccountDepositsResponse_DepositsEntry>,
  ): QuerySubaccountDepositsResponse_DepositsEntry {
    const message = createBaseQuerySubaccountDepositsResponse_DepositsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Deposit.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryExchangeBalancesRequest(): QueryExchangeBalancesRequest {
  return {};
}

export const QueryExchangeBalancesRequest = {
  encode(_: QueryExchangeBalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExchangeBalancesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExchangeBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryExchangeBalancesRequest {
    return {};
  },

  toJSON(_: QueryExchangeBalancesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryExchangeBalancesRequest>): QueryExchangeBalancesRequest {
    return QueryExchangeBalancesRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryExchangeBalancesRequest>): QueryExchangeBalancesRequest {
    const message = createBaseQueryExchangeBalancesRequest();
    return message;
  },
};

function createBaseQueryExchangeBalancesResponse(): QueryExchangeBalancesResponse {
  return { balances: [] };
}

export const QueryExchangeBalancesResponse = {
  encode(message: QueryExchangeBalancesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      Balance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExchangeBalancesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExchangeBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balances.push(Balance.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryExchangeBalancesResponse {
    return { balances: Array.isArray(object?.balances) ? object.balances.map((e: any) => Balance.fromJSON(e)) : [] };
  },

  toJSON(message: QueryExchangeBalancesResponse): unknown {
    const obj: any = {};
    if (message.balances) {
      obj.balances = message.balances.map((e) => e ? Balance.toJSON(e) : undefined);
    } else {
      obj.balances = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryExchangeBalancesResponse>): QueryExchangeBalancesResponse {
    return QueryExchangeBalancesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryExchangeBalancesResponse>): QueryExchangeBalancesResponse {
    const message = createBaseQueryExchangeBalancesResponse();
    message.balances = object.balances?.map((e) => Balance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAggregateVolumeRequest(): QueryAggregateVolumeRequest {
  return { account: "" };
}

export const QueryAggregateVolumeRequest = {
  encode(message: QueryAggregateVolumeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateVolumeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateVolumeRequest {
    return { account: isSet(object.account) ? String(object.account) : "" };
  },

  toJSON(message: QueryAggregateVolumeRequest): unknown {
    const obj: any = {};
    message.account !== undefined && (obj.account = message.account);
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateVolumeRequest>): QueryAggregateVolumeRequest {
    return QueryAggregateVolumeRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateVolumeRequest>): QueryAggregateVolumeRequest {
    const message = createBaseQueryAggregateVolumeRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseQueryAggregateVolumeResponse(): QueryAggregateVolumeResponse {
  return { aggregateVolumes: [] };
}

export const QueryAggregateVolumeResponse = {
  encode(message: QueryAggregateVolumeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.aggregateVolumes) {
      MarketVolume.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateVolumeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateVolumeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.aggregateVolumes.push(MarketVolume.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateVolumeResponse {
    return {
      aggregateVolumes: Array.isArray(object?.aggregateVolumes)
        ? object.aggregateVolumes.map((e: any) => MarketVolume.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAggregateVolumeResponse): unknown {
    const obj: any = {};
    if (message.aggregateVolumes) {
      obj.aggregateVolumes = message.aggregateVolumes.map((e) => e ? MarketVolume.toJSON(e) : undefined);
    } else {
      obj.aggregateVolumes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateVolumeResponse>): QueryAggregateVolumeResponse {
    return QueryAggregateVolumeResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateVolumeResponse>): QueryAggregateVolumeResponse {
    const message = createBaseQueryAggregateVolumeResponse();
    message.aggregateVolumes = object.aggregateVolumes?.map((e) => MarketVolume.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAggregateVolumesRequest(): QueryAggregateVolumesRequest {
  return { accounts: [], marketIds: [] };
}

export const QueryAggregateVolumesRequest = {
  encode(message: QueryAggregateVolumesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.marketIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateVolumesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateVolumesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accounts.push(reader.string());
          break;
        case 2:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateVolumesRequest {
    return {
      accounts: Array.isArray(object?.accounts) ? object.accounts.map((e: any) => String(e)) : [],
      marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: QueryAggregateVolumesRequest): unknown {
    const obj: any = {};
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e);
    } else {
      obj.accounts = [];
    }
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateVolumesRequest>): QueryAggregateVolumesRequest {
    return QueryAggregateVolumesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateVolumesRequest>): QueryAggregateVolumesRequest {
    const message = createBaseQueryAggregateVolumesRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryAggregateVolumesResponse(): QueryAggregateVolumesResponse {
  return { aggregateAccountVolumes: [], aggregateMarketVolumes: [] };
}

export const QueryAggregateVolumesResponse = {
  encode(message: QueryAggregateVolumesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.aggregateAccountVolumes) {
      AggregateAccountVolumeRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.aggregateMarketVolumes) {
      MarketVolume.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateVolumesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateVolumesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.aggregateAccountVolumes.push(AggregateAccountVolumeRecord.decode(reader, reader.uint32()));
          break;
        case 2:
          message.aggregateMarketVolumes.push(MarketVolume.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateVolumesResponse {
    return {
      aggregateAccountVolumes: Array.isArray(object?.aggregateAccountVolumes)
        ? object.aggregateAccountVolumes.map((e: any) => AggregateAccountVolumeRecord.fromJSON(e))
        : [],
      aggregateMarketVolumes: Array.isArray(object?.aggregateMarketVolumes)
        ? object.aggregateMarketVolumes.map((e: any) => MarketVolume.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAggregateVolumesResponse): unknown {
    const obj: any = {};
    if (message.aggregateAccountVolumes) {
      obj.aggregateAccountVolumes = message.aggregateAccountVolumes.map((e) =>
        e ? AggregateAccountVolumeRecord.toJSON(e) : undefined
      );
    } else {
      obj.aggregateAccountVolumes = [];
    }
    if (message.aggregateMarketVolumes) {
      obj.aggregateMarketVolumes = message.aggregateMarketVolumes.map((e) => e ? MarketVolume.toJSON(e) : undefined);
    } else {
      obj.aggregateMarketVolumes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateVolumesResponse>): QueryAggregateVolumesResponse {
    return QueryAggregateVolumesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateVolumesResponse>): QueryAggregateVolumesResponse {
    const message = createBaseQueryAggregateVolumesResponse();
    message.aggregateAccountVolumes =
      object.aggregateAccountVolumes?.map((e) => AggregateAccountVolumeRecord.fromPartial(e)) || [];
    message.aggregateMarketVolumes = object.aggregateMarketVolumes?.map((e) => MarketVolume.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAggregateMarketVolumeRequest(): QueryAggregateMarketVolumeRequest {
  return { marketId: "" };
}

export const QueryAggregateMarketVolumeRequest = {
  encode(message: QueryAggregateMarketVolumeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateMarketVolumeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateMarketVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateMarketVolumeRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryAggregateMarketVolumeRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateMarketVolumeRequest>): QueryAggregateMarketVolumeRequest {
    return QueryAggregateMarketVolumeRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateMarketVolumeRequest>): QueryAggregateMarketVolumeRequest {
    const message = createBaseQueryAggregateMarketVolumeRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryAggregateMarketVolumeResponse(): QueryAggregateMarketVolumeResponse {
  return { volume: undefined };
}

export const QueryAggregateMarketVolumeResponse = {
  encode(message: QueryAggregateMarketVolumeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.volume !== undefined) {
      VolumeRecord.encode(message.volume, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateMarketVolumeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateMarketVolumeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.volume = VolumeRecord.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateMarketVolumeResponse {
    return { volume: isSet(object.volume) ? VolumeRecord.fromJSON(object.volume) : undefined };
  },

  toJSON(message: QueryAggregateMarketVolumeResponse): unknown {
    const obj: any = {};
    message.volume !== undefined && (obj.volume = message.volume ? VolumeRecord.toJSON(message.volume) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateMarketVolumeResponse>): QueryAggregateMarketVolumeResponse {
    return QueryAggregateMarketVolumeResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateMarketVolumeResponse>): QueryAggregateMarketVolumeResponse {
    const message = createBaseQueryAggregateMarketVolumeResponse();
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? VolumeRecord.fromPartial(object.volume)
      : undefined;
    return message;
  },
};

function createBaseQueryDenomDecimalRequest(): QueryDenomDecimalRequest {
  return { denom: "" };
}

export const QueryDenomDecimalRequest = {
  encode(message: QueryDenomDecimalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomDecimalRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomDecimalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDenomDecimalRequest {
    return { denom: isSet(object.denom) ? String(object.denom) : "" };
  },

  toJSON(message: QueryDenomDecimalRequest): unknown {
    const obj: any = {};
    message.denom !== undefined && (obj.denom = message.denom);
    return obj;
  },

  create(base?: DeepPartial<QueryDenomDecimalRequest>): QueryDenomDecimalRequest {
    return QueryDenomDecimalRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDenomDecimalRequest>): QueryDenomDecimalRequest {
    const message = createBaseQueryDenomDecimalRequest();
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryDenomDecimalResponse(): QueryDenomDecimalResponse {
  return { decimal: "0" };
}

export const QueryDenomDecimalResponse = {
  encode(message: QueryDenomDecimalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.decimal !== "0") {
      writer.uint32(8).uint64(message.decimal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomDecimalResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomDecimalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.decimal = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDenomDecimalResponse {
    return { decimal: isSet(object.decimal) ? String(object.decimal) : "0" };
  },

  toJSON(message: QueryDenomDecimalResponse): unknown {
    const obj: any = {};
    message.decimal !== undefined && (obj.decimal = message.decimal);
    return obj;
  },

  create(base?: DeepPartial<QueryDenomDecimalResponse>): QueryDenomDecimalResponse {
    return QueryDenomDecimalResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDenomDecimalResponse>): QueryDenomDecimalResponse {
    const message = createBaseQueryDenomDecimalResponse();
    message.decimal = object.decimal ?? "0";
    return message;
  },
};

function createBaseQueryDenomDecimalsRequest(): QueryDenomDecimalsRequest {
  return { denoms: [] };
}

export const QueryDenomDecimalsRequest = {
  encode(message: QueryDenomDecimalsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.denoms) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomDecimalsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomDecimalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denoms.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDenomDecimalsRequest {
    return { denoms: Array.isArray(object?.denoms) ? object.denoms.map((e: any) => String(e)) : [] };
  },

  toJSON(message: QueryDenomDecimalsRequest): unknown {
    const obj: any = {};
    if (message.denoms) {
      obj.denoms = message.denoms.map((e) => e);
    } else {
      obj.denoms = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDenomDecimalsRequest>): QueryDenomDecimalsRequest {
    return QueryDenomDecimalsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDenomDecimalsRequest>): QueryDenomDecimalsRequest {
    const message = createBaseQueryDenomDecimalsRequest();
    message.denoms = object.denoms?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryDenomDecimalsResponse(): QueryDenomDecimalsResponse {
  return { denomDecimals: [] };
}

export const QueryDenomDecimalsResponse = {
  encode(message: QueryDenomDecimalsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.denomDecimals) {
      DenomDecimals.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomDecimalsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomDecimalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denomDecimals.push(DenomDecimals.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDenomDecimalsResponse {
    return {
      denomDecimals: Array.isArray(object?.denomDecimals)
        ? object.denomDecimals.map((e: any) => DenomDecimals.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDenomDecimalsResponse): unknown {
    const obj: any = {};
    if (message.denomDecimals) {
      obj.denomDecimals = message.denomDecimals.map((e) => e ? DenomDecimals.toJSON(e) : undefined);
    } else {
      obj.denomDecimals = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDenomDecimalsResponse>): QueryDenomDecimalsResponse {
    return QueryDenomDecimalsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDenomDecimalsResponse>): QueryDenomDecimalsResponse {
    const message = createBaseQueryDenomDecimalsResponse();
    message.denomDecimals = object.denomDecimals?.map((e) => DenomDecimals.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAggregateMarketVolumesRequest(): QueryAggregateMarketVolumesRequest {
  return { marketIds: [] };
}

export const QueryAggregateMarketVolumesRequest = {
  encode(message: QueryAggregateMarketVolumesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.marketIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateMarketVolumesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateMarketVolumesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateMarketVolumesRequest {
    return { marketIds: Array.isArray(object?.marketIds) ? object.marketIds.map((e: any) => String(e)) : [] };
  },

  toJSON(message: QueryAggregateMarketVolumesRequest): unknown {
    const obj: any = {};
    if (message.marketIds) {
      obj.marketIds = message.marketIds.map((e) => e);
    } else {
      obj.marketIds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateMarketVolumesRequest>): QueryAggregateMarketVolumesRequest {
    return QueryAggregateMarketVolumesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateMarketVolumesRequest>): QueryAggregateMarketVolumesRequest {
    const message = createBaseQueryAggregateMarketVolumesRequest();
    message.marketIds = object.marketIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryAggregateMarketVolumesResponse(): QueryAggregateMarketVolumesResponse {
  return { volumes: [] };
}

export const QueryAggregateMarketVolumesResponse = {
  encode(message: QueryAggregateMarketVolumesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.volumes) {
      MarketVolume.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAggregateMarketVolumesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAggregateMarketVolumesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.volumes.push(MarketVolume.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryAggregateMarketVolumesResponse {
    return { volumes: Array.isArray(object?.volumes) ? object.volumes.map((e: any) => MarketVolume.fromJSON(e)) : [] };
  },

  toJSON(message: QueryAggregateMarketVolumesResponse): unknown {
    const obj: any = {};
    if (message.volumes) {
      obj.volumes = message.volumes.map((e) => e ? MarketVolume.toJSON(e) : undefined);
    } else {
      obj.volumes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAggregateMarketVolumesResponse>): QueryAggregateMarketVolumesResponse {
    return QueryAggregateMarketVolumesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryAggregateMarketVolumesResponse>): QueryAggregateMarketVolumesResponse {
    const message = createBaseQueryAggregateMarketVolumesResponse();
    message.volumes = object.volumes?.map((e) => MarketVolume.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySubaccountDepositRequest(): QuerySubaccountDepositRequest {
  return { subaccountId: "", denom: "" };
}

export const QuerySubaccountDepositRequest = {
  encode(message: QuerySubaccountDepositRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountDepositRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountDepositRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountDepositRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
    };
  },

  toJSON(message: QuerySubaccountDepositRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountDepositRequest>): QuerySubaccountDepositRequest {
    return QuerySubaccountDepositRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountDepositRequest>): QuerySubaccountDepositRequest {
    const message = createBaseQuerySubaccountDepositRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQuerySubaccountDepositResponse(): QuerySubaccountDepositResponse {
  return { deposits: undefined };
}

export const QuerySubaccountDepositResponse = {
  encode(message: QuerySubaccountDepositResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deposits !== undefined) {
      Deposit.encode(message.deposits, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountDepositResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountDepositResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.deposits = Deposit.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountDepositResponse {
    return { deposits: isSet(object.deposits) ? Deposit.fromJSON(object.deposits) : undefined };
  },

  toJSON(message: QuerySubaccountDepositResponse): unknown {
    const obj: any = {};
    message.deposits !== undefined && (obj.deposits = message.deposits ? Deposit.toJSON(message.deposits) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountDepositResponse>): QuerySubaccountDepositResponse {
    return QuerySubaccountDepositResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountDepositResponse>): QuerySubaccountDepositResponse {
    const message = createBaseQuerySubaccountDepositResponse();
    message.deposits = (object.deposits !== undefined && object.deposits !== null)
      ? Deposit.fromPartial(object.deposits)
      : undefined;
    return message;
  },
};

function createBaseQuerySpotMarketsRequest(): QuerySpotMarketsRequest {
  return { status: "" };
}

export const QuerySpotMarketsRequest = {
  encode(message: QuerySpotMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMarketsRequest {
    return { status: isSet(object.status) ? String(object.status) : "" };
  },

  toJSON(message: QuerySpotMarketsRequest): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMarketsRequest>): QuerySpotMarketsRequest {
    return QuerySpotMarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMarketsRequest>): QuerySpotMarketsRequest {
    const message = createBaseQuerySpotMarketsRequest();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseQuerySpotMarketsResponse(): QuerySpotMarketsResponse {
  return { markets: [] };
}

export const QuerySpotMarketsResponse = {
  encode(message: QuerySpotMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      SpotMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(SpotMarket.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMarketsResponse {
    return { markets: Array.isArray(object?.markets) ? object.markets.map((e: any) => SpotMarket.fromJSON(e)) : [] };
  },

  toJSON(message: QuerySpotMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? SpotMarket.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMarketsResponse>): QuerySpotMarketsResponse {
    return QuerySpotMarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMarketsResponse>): QuerySpotMarketsResponse {
    const message = createBaseQuerySpotMarketsResponse();
    message.markets = object.markets?.map((e) => SpotMarket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySpotMarketRequest(): QuerySpotMarketRequest {
  return { marketId: "" };
}

export const QuerySpotMarketRequest = {
  encode(message: QuerySpotMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMarketRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QuerySpotMarketRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMarketRequest>): QuerySpotMarketRequest {
    return QuerySpotMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMarketRequest>): QuerySpotMarketRequest {
    const message = createBaseQuerySpotMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQuerySpotMarketResponse(): QuerySpotMarketResponse {
  return { market: undefined };
}

export const QuerySpotMarketResponse = {
  encode(message: QuerySpotMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      SpotMarket.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = SpotMarket.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMarketResponse {
    return { market: isSet(object.market) ? SpotMarket.fromJSON(object.market) : undefined };
  },

  toJSON(message: QuerySpotMarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined && (obj.market = message.market ? SpotMarket.toJSON(message.market) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMarketResponse>): QuerySpotMarketResponse {
    return QuerySpotMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMarketResponse>): QuerySpotMarketResponse {
    const message = createBaseQuerySpotMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? SpotMarket.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseQuerySpotOrderbookRequest(): QuerySpotOrderbookRequest {
  return { marketId: "", limit: "0" };
}

export const QuerySpotOrderbookRequest = {
  encode(message: QuerySpotOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.limit !== "0") {
      writer.uint32(16).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.limit = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotOrderbookRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      limit: isSet(object.limit) ? String(object.limit) : "0",
    };
  },

  toJSON(message: QuerySpotOrderbookRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.limit !== undefined && (obj.limit = message.limit);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotOrderbookRequest>): QuerySpotOrderbookRequest {
    return QuerySpotOrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotOrderbookRequest>): QuerySpotOrderbookRequest {
    const message = createBaseQuerySpotOrderbookRequest();
    message.marketId = object.marketId ?? "";
    message.limit = object.limit ?? "0";
    return message;
  },
};

function createBaseQuerySpotOrderbookResponse(): QuerySpotOrderbookResponse {
  return { buysPriceLevel: [], sellsPriceLevel: [] };
}

export const QuerySpotOrderbookResponse = {
  encode(message: QuerySpotOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buysPriceLevel) {
      Level.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sellsPriceLevel) {
      Level.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buysPriceLevel.push(Level.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sellsPriceLevel.push(Level.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotOrderbookResponse {
    return {
      buysPriceLevel: Array.isArray(object?.buysPriceLevel)
        ? object.buysPriceLevel.map((e: any) => Level.fromJSON(e))
        : [],
      sellsPriceLevel: Array.isArray(object?.sellsPriceLevel)
        ? object.sellsPriceLevel.map((e: any) => Level.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySpotOrderbookResponse): unknown {
    const obj: any = {};
    if (message.buysPriceLevel) {
      obj.buysPriceLevel = message.buysPriceLevel.map((e) => e ? Level.toJSON(e) : undefined);
    } else {
      obj.buysPriceLevel = [];
    }
    if (message.sellsPriceLevel) {
      obj.sellsPriceLevel = message.sellsPriceLevel.map((e) => e ? Level.toJSON(e) : undefined);
    } else {
      obj.sellsPriceLevel = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySpotOrderbookResponse>): QuerySpotOrderbookResponse {
    return QuerySpotOrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotOrderbookResponse>): QuerySpotOrderbookResponse {
    const message = createBaseQuerySpotOrderbookResponse();
    message.buysPriceLevel = object.buysPriceLevel?.map((e) => Level.fromPartial(e)) || [];
    message.sellsPriceLevel = object.sellsPriceLevel?.map((e) => Level.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySpotOrdersByHashesRequest(): QuerySpotOrdersByHashesRequest {
  return { marketId: "", subaccountId: "", orderHashes: [] };
}

export const QuerySpotOrdersByHashesRequest = {
  encode(message: QuerySpotOrdersByHashesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    for (const v of message.orderHashes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotOrdersByHashesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotOrdersByHashesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.orderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotOrdersByHashesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHashes: Array.isArray(object?.orderHashes) ? object.orderHashes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: QuerySpotOrdersByHashesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.orderHashes) {
      obj.orderHashes = message.orderHashes.map((e) => e);
    } else {
      obj.orderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySpotOrdersByHashesRequest>): QuerySpotOrdersByHashesRequest {
    return QuerySpotOrdersByHashesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotOrdersByHashesRequest>): QuerySpotOrdersByHashesRequest {
    const message = createBaseQuerySpotOrdersByHashesRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHashes = object.orderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseQuerySpotOrdersByHashesResponse(): QuerySpotOrdersByHashesResponse {
  return { orders: [] };
}

export const QuerySpotOrdersByHashesResponse = {
  encode(message: QuerySpotOrdersByHashesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      TrimmedSpotLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotOrdersByHashesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotOrdersByHashesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(TrimmedSpotLimitOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotOrdersByHashesResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => TrimmedSpotLimitOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: QuerySpotOrdersByHashesResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? TrimmedSpotLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySpotOrdersByHashesResponse>): QuerySpotOrdersByHashesResponse {
    return QuerySpotOrdersByHashesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotOrdersByHashesResponse>): QuerySpotOrdersByHashesResponse {
    const message = createBaseQuerySpotOrdersByHashesResponse();
    message.orders = object.orders?.map((e) => TrimmedSpotLimitOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryTraderSpotOrdersRequest(): QueryTraderSpotOrdersRequest {
  return { marketId: "", subaccountId: "" };
}

export const QueryTraderSpotOrdersRequest = {
  encode(message: QueryTraderSpotOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderSpotOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderSpotOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderSpotOrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
    };
  },

  toJSON(message: QueryTraderSpotOrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QueryTraderSpotOrdersRequest>): QueryTraderSpotOrdersRequest {
    return QueryTraderSpotOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTraderSpotOrdersRequest>): QueryTraderSpotOrdersRequest {
    const message = createBaseQueryTraderSpotOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseTrimmedSpotLimitOrder(): TrimmedSpotLimitOrder {
  return { price: "", quantity: "", fillable: "", isBuy: false, orderHash: "" };
}

export const TrimmedSpotLimitOrder = {
  encode(message: TrimmedSpotLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.fillable !== "") {
      writer.uint32(26).string(message.fillable);
    }
    if (message.isBuy === true) {
      writer.uint32(32).bool(message.isBuy);
    }
    if (message.orderHash !== "") {
      writer.uint32(42).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrimmedSpotLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrimmedSpotLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.fillable = reader.string();
          break;
        case 4:
          message.isBuy = reader.bool();
          break;
        case 5:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TrimmedSpotLimitOrder {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      fillable: isSet(object.fillable) ? String(object.fillable) : "",
      isBuy: isSet(object.isBuy) ? Boolean(object.isBuy) : false,
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
    };
  },

  toJSON(message: TrimmedSpotLimitOrder): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.fillable !== undefined && (obj.fillable = message.fillable);
    message.isBuy !== undefined && (obj.isBuy = message.isBuy);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<TrimmedSpotLimitOrder>): TrimmedSpotLimitOrder {
    return TrimmedSpotLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TrimmedSpotLimitOrder>): TrimmedSpotLimitOrder {
    const message = createBaseTrimmedSpotLimitOrder();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.fillable = object.fillable ?? "";
    message.isBuy = object.isBuy ?? false;
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseQueryTraderSpotOrdersResponse(): QueryTraderSpotOrdersResponse {
  return { orders: [] };
}

export const QueryTraderSpotOrdersResponse = {
  encode(message: QueryTraderSpotOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      TrimmedSpotLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderSpotOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderSpotOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(TrimmedSpotLimitOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderSpotOrdersResponse {
    return {
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => TrimmedSpotLimitOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryTraderSpotOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? TrimmedSpotLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTraderSpotOrdersResponse>): QueryTraderSpotOrdersResponse {
    return QueryTraderSpotOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTraderSpotOrdersResponse>): QueryTraderSpotOrdersResponse {
    const message = createBaseQueryTraderSpotOrdersResponse();
    message.orders = object.orders?.map((e) => TrimmedSpotLimitOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySpotMidPriceAndTOBRequest(): QuerySpotMidPriceAndTOBRequest {
  return { marketId: "" };
}

export const QuerySpotMidPriceAndTOBRequest = {
  encode(message: QuerySpotMidPriceAndTOBRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMidPriceAndTOBRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMidPriceAndTOBRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMidPriceAndTOBRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QuerySpotMidPriceAndTOBRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMidPriceAndTOBRequest>): QuerySpotMidPriceAndTOBRequest {
    return QuerySpotMidPriceAndTOBRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMidPriceAndTOBRequest>): QuerySpotMidPriceAndTOBRequest {
    const message = createBaseQuerySpotMidPriceAndTOBRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQuerySpotMidPriceAndTOBResponse(): QuerySpotMidPriceAndTOBResponse {
  return { midPrice: "", bestBuyPrice: "", bestSellPrice: "" };
}

export const QuerySpotMidPriceAndTOBResponse = {
  encode(message: QuerySpotMidPriceAndTOBResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.midPrice !== "") {
      writer.uint32(10).string(message.midPrice);
    }
    if (message.bestBuyPrice !== "") {
      writer.uint32(18).string(message.bestBuyPrice);
    }
    if (message.bestSellPrice !== "") {
      writer.uint32(26).string(message.bestSellPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpotMidPriceAndTOBResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpotMidPriceAndTOBResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.midPrice = reader.string();
          break;
        case 2:
          message.bestBuyPrice = reader.string();
          break;
        case 3:
          message.bestSellPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySpotMidPriceAndTOBResponse {
    return {
      midPrice: isSet(object.midPrice) ? String(object.midPrice) : "",
      bestBuyPrice: isSet(object.bestBuyPrice) ? String(object.bestBuyPrice) : "",
      bestSellPrice: isSet(object.bestSellPrice) ? String(object.bestSellPrice) : "",
    };
  },

  toJSON(message: QuerySpotMidPriceAndTOBResponse): unknown {
    const obj: any = {};
    message.midPrice !== undefined && (obj.midPrice = message.midPrice);
    message.bestBuyPrice !== undefined && (obj.bestBuyPrice = message.bestBuyPrice);
    message.bestSellPrice !== undefined && (obj.bestSellPrice = message.bestSellPrice);
    return obj;
  },

  create(base?: DeepPartial<QuerySpotMidPriceAndTOBResponse>): QuerySpotMidPriceAndTOBResponse {
    return QuerySpotMidPriceAndTOBResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySpotMidPriceAndTOBResponse>): QuerySpotMidPriceAndTOBResponse {
    const message = createBaseQuerySpotMidPriceAndTOBResponse();
    message.midPrice = object.midPrice ?? "";
    message.bestBuyPrice = object.bestBuyPrice ?? "";
    message.bestSellPrice = object.bestSellPrice ?? "";
    return message;
  },
};

function createBaseQueryDerivativeMidPriceAndTOBRequest(): QueryDerivativeMidPriceAndTOBRequest {
  return { marketId: "" };
}

export const QueryDerivativeMidPriceAndTOBRequest = {
  encode(message: QueryDerivativeMidPriceAndTOBRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMidPriceAndTOBRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMidPriceAndTOBRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMidPriceAndTOBRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryDerivativeMidPriceAndTOBRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMidPriceAndTOBRequest>): QueryDerivativeMidPriceAndTOBRequest {
    return QueryDerivativeMidPriceAndTOBRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMidPriceAndTOBRequest>): QueryDerivativeMidPriceAndTOBRequest {
    const message = createBaseQueryDerivativeMidPriceAndTOBRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryDerivativeMidPriceAndTOBResponse(): QueryDerivativeMidPriceAndTOBResponse {
  return { midPrice: "", bestBuyPrice: "", bestSellPrice: "" };
}

export const QueryDerivativeMidPriceAndTOBResponse = {
  encode(message: QueryDerivativeMidPriceAndTOBResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.midPrice !== "") {
      writer.uint32(10).string(message.midPrice);
    }
    if (message.bestBuyPrice !== "") {
      writer.uint32(18).string(message.bestBuyPrice);
    }
    if (message.bestSellPrice !== "") {
      writer.uint32(26).string(message.bestSellPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMidPriceAndTOBResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMidPriceAndTOBResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.midPrice = reader.string();
          break;
        case 2:
          message.bestBuyPrice = reader.string();
          break;
        case 3:
          message.bestSellPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMidPriceAndTOBResponse {
    return {
      midPrice: isSet(object.midPrice) ? String(object.midPrice) : "",
      bestBuyPrice: isSet(object.bestBuyPrice) ? String(object.bestBuyPrice) : "",
      bestSellPrice: isSet(object.bestSellPrice) ? String(object.bestSellPrice) : "",
    };
  },

  toJSON(message: QueryDerivativeMidPriceAndTOBResponse): unknown {
    const obj: any = {};
    message.midPrice !== undefined && (obj.midPrice = message.midPrice);
    message.bestBuyPrice !== undefined && (obj.bestBuyPrice = message.bestBuyPrice);
    message.bestSellPrice !== undefined && (obj.bestSellPrice = message.bestSellPrice);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMidPriceAndTOBResponse>): QueryDerivativeMidPriceAndTOBResponse {
    return QueryDerivativeMidPriceAndTOBResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMidPriceAndTOBResponse>): QueryDerivativeMidPriceAndTOBResponse {
    const message = createBaseQueryDerivativeMidPriceAndTOBResponse();
    message.midPrice = object.midPrice ?? "";
    message.bestBuyPrice = object.bestBuyPrice ?? "";
    message.bestSellPrice = object.bestSellPrice ?? "";
    return message;
  },
};

function createBaseQueryDerivativeOrderbookRequest(): QueryDerivativeOrderbookRequest {
  return { marketId: "", limit: "0" };
}

export const QueryDerivativeOrderbookRequest = {
  encode(message: QueryDerivativeOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.limit !== "0") {
      writer.uint32(16).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.limit = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeOrderbookRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      limit: isSet(object.limit) ? String(object.limit) : "0",
    };
  },

  toJSON(message: QueryDerivativeOrderbookRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.limit !== undefined && (obj.limit = message.limit);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeOrderbookRequest>): QueryDerivativeOrderbookRequest {
    return QueryDerivativeOrderbookRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeOrderbookRequest>): QueryDerivativeOrderbookRequest {
    const message = createBaseQueryDerivativeOrderbookRequest();
    message.marketId = object.marketId ?? "";
    message.limit = object.limit ?? "0";
    return message;
  },
};

function createBaseQueryDerivativeOrderbookResponse(): QueryDerivativeOrderbookResponse {
  return { buysPriceLevel: [], sellsPriceLevel: [] };
}

export const QueryDerivativeOrderbookResponse = {
  encode(message: QueryDerivativeOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.buysPriceLevel) {
      Level.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.sellsPriceLevel) {
      Level.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buysPriceLevel.push(Level.decode(reader, reader.uint32()));
          break;
        case 2:
          message.sellsPriceLevel.push(Level.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeOrderbookResponse {
    return {
      buysPriceLevel: Array.isArray(object?.buysPriceLevel)
        ? object.buysPriceLevel.map((e: any) => Level.fromJSON(e))
        : [],
      sellsPriceLevel: Array.isArray(object?.sellsPriceLevel)
        ? object.sellsPriceLevel.map((e: any) => Level.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDerivativeOrderbookResponse): unknown {
    const obj: any = {};
    if (message.buysPriceLevel) {
      obj.buysPriceLevel = message.buysPriceLevel.map((e) => e ? Level.toJSON(e) : undefined);
    } else {
      obj.buysPriceLevel = [];
    }
    if (message.sellsPriceLevel) {
      obj.sellsPriceLevel = message.sellsPriceLevel.map((e) => e ? Level.toJSON(e) : undefined);
    } else {
      obj.sellsPriceLevel = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeOrderbookResponse>): QueryDerivativeOrderbookResponse {
    return QueryDerivativeOrderbookResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeOrderbookResponse>): QueryDerivativeOrderbookResponse {
    const message = createBaseQueryDerivativeOrderbookResponse();
    message.buysPriceLevel = object.buysPriceLevel?.map((e) => Level.fromPartial(e)) || [];
    message.sellsPriceLevel = object.sellsPriceLevel?.map((e) => Level.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryTraderSpotOrdersToCancelUpToAmountRequest(): QueryTraderSpotOrdersToCancelUpToAmountRequest {
  return { marketId: "", subaccountId: "", baseAmount: "", quoteAmount: "", strategy: 0, referencePrice: "" };
}

export const QueryTraderSpotOrdersToCancelUpToAmountRequest = {
  encode(
    message: QueryTraderSpotOrdersToCancelUpToAmountRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.baseAmount !== "") {
      writer.uint32(26).string(message.baseAmount);
    }
    if (message.quoteAmount !== "") {
      writer.uint32(34).string(message.quoteAmount);
    }
    if (message.strategy !== 0) {
      writer.uint32(40).int32(message.strategy);
    }
    if (message.referencePrice !== "") {
      writer.uint32(50).string(message.referencePrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderSpotOrdersToCancelUpToAmountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.baseAmount = reader.string();
          break;
        case 4:
          message.quoteAmount = reader.string();
          break;
        case 5:
          message.strategy = reader.int32() as any;
          break;
        case 6:
          message.referencePrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      baseAmount: isSet(object.baseAmount) ? String(object.baseAmount) : "",
      quoteAmount: isSet(object.quoteAmount) ? String(object.quoteAmount) : "",
      strategy: isSet(object.strategy) ? cancellationStrategyFromJSON(object.strategy) : 0,
      referencePrice: isSet(object.referencePrice) ? String(object.referencePrice) : "",
    };
  },

  toJSON(message: QueryTraderSpotOrdersToCancelUpToAmountRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.baseAmount !== undefined && (obj.baseAmount = message.baseAmount);
    message.quoteAmount !== undefined && (obj.quoteAmount = message.quoteAmount);
    message.strategy !== undefined && (obj.strategy = cancellationStrategyToJSON(message.strategy));
    message.referencePrice !== undefined && (obj.referencePrice = message.referencePrice);
    return obj;
  },

  create(
    base?: DeepPartial<QueryTraderSpotOrdersToCancelUpToAmountRequest>,
  ): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    return QueryTraderSpotOrdersToCancelUpToAmountRequest.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryTraderSpotOrdersToCancelUpToAmountRequest>,
  ): QueryTraderSpotOrdersToCancelUpToAmountRequest {
    const message = createBaseQueryTraderSpotOrdersToCancelUpToAmountRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.baseAmount = object.baseAmount ?? "";
    message.quoteAmount = object.quoteAmount ?? "";
    message.strategy = object.strategy ?? 0;
    message.referencePrice = object.referencePrice ?? "";
    return message;
  },
};

function createBaseQueryTraderDerivativeOrdersToCancelUpToAmountRequest(): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
  return { marketId: "", subaccountId: "", quoteAmount: "", strategy: 0, referencePrice: "" };
}

export const QueryTraderDerivativeOrdersToCancelUpToAmountRequest = {
  encode(
    message: QueryTraderDerivativeOrdersToCancelUpToAmountRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.quoteAmount !== "") {
      writer.uint32(26).string(message.quoteAmount);
    }
    if (message.strategy !== 0) {
      writer.uint32(32).int32(message.strategy);
    }
    if (message.referencePrice !== "") {
      writer.uint32(42).string(message.referencePrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderDerivativeOrdersToCancelUpToAmountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.quoteAmount = reader.string();
          break;
        case 4:
          message.strategy = reader.int32() as any;
          break;
        case 5:
          message.referencePrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      quoteAmount: isSet(object.quoteAmount) ? String(object.quoteAmount) : "",
      strategy: isSet(object.strategy) ? cancellationStrategyFromJSON(object.strategy) : 0,
      referencePrice: isSet(object.referencePrice) ? String(object.referencePrice) : "",
    };
  },

  toJSON(message: QueryTraderDerivativeOrdersToCancelUpToAmountRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.quoteAmount !== undefined && (obj.quoteAmount = message.quoteAmount);
    message.strategy !== undefined && (obj.strategy = cancellationStrategyToJSON(message.strategy));
    message.referencePrice !== undefined && (obj.referencePrice = message.referencePrice);
    return obj;
  },

  create(
    base?: DeepPartial<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>,
  ): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    return QueryTraderDerivativeOrdersToCancelUpToAmountRequest.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>,
  ): QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    const message = createBaseQueryTraderDerivativeOrdersToCancelUpToAmountRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.quoteAmount = object.quoteAmount ?? "";
    message.strategy = object.strategy ?? 0;
    message.referencePrice = object.referencePrice ?? "";
    return message;
  },
};

function createBaseQueryTraderDerivativeOrdersRequest(): QueryTraderDerivativeOrdersRequest {
  return { marketId: "", subaccountId: "" };
}

export const QueryTraderDerivativeOrdersRequest = {
  encode(message: QueryTraderDerivativeOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderDerivativeOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderDerivativeOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderDerivativeOrdersRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
    };
  },

  toJSON(message: QueryTraderDerivativeOrdersRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QueryTraderDerivativeOrdersRequest>): QueryTraderDerivativeOrdersRequest {
    return QueryTraderDerivativeOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTraderDerivativeOrdersRequest>): QueryTraderDerivativeOrdersRequest {
    const message = createBaseQueryTraderDerivativeOrdersRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseTrimmedDerivativeLimitOrder(): TrimmedDerivativeLimitOrder {
  return { price: "", quantity: "", margin: "", fillable: "", isBuy: false, orderHash: "" };
}

export const TrimmedDerivativeLimitOrder = {
  encode(message: TrimmedDerivativeLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.margin !== "") {
      writer.uint32(26).string(message.margin);
    }
    if (message.fillable !== "") {
      writer.uint32(34).string(message.fillable);
    }
    if (message.isBuy === true) {
      writer.uint32(40).bool(message.isBuy);
    }
    if (message.orderHash !== "") {
      writer.uint32(50).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrimmedDerivativeLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrimmedDerivativeLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.margin = reader.string();
          break;
        case 4:
          message.fillable = reader.string();
          break;
        case 5:
          message.isBuy = reader.bool();
          break;
        case 6:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TrimmedDerivativeLimitOrder {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
      fillable: isSet(object.fillable) ? String(object.fillable) : "",
      isBuy: isSet(object.isBuy) ? Boolean(object.isBuy) : false,
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
    };
  },

  toJSON(message: TrimmedDerivativeLimitOrder): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.margin !== undefined && (obj.margin = message.margin);
    message.fillable !== undefined && (obj.fillable = message.fillable);
    message.isBuy !== undefined && (obj.isBuy = message.isBuy);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<TrimmedDerivativeLimitOrder>): TrimmedDerivativeLimitOrder {
    return TrimmedDerivativeLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TrimmedDerivativeLimitOrder>): TrimmedDerivativeLimitOrder {
    const message = createBaseTrimmedDerivativeLimitOrder();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.margin = object.margin ?? "";
    message.fillable = object.fillable ?? "";
    message.isBuy = object.isBuy ?? false;
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseQueryTraderDerivativeOrdersResponse(): QueryTraderDerivativeOrdersResponse {
  return { orders: [] };
}

export const QueryTraderDerivativeOrdersResponse = {
  encode(message: QueryTraderDerivativeOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      TrimmedDerivativeLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderDerivativeOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderDerivativeOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(TrimmedDerivativeLimitOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderDerivativeOrdersResponse {
    return {
      orders: Array.isArray(object?.orders)
        ? object.orders.map((e: any) => TrimmedDerivativeLimitOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryTraderDerivativeOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? TrimmedDerivativeLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTraderDerivativeOrdersResponse>): QueryTraderDerivativeOrdersResponse {
    return QueryTraderDerivativeOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTraderDerivativeOrdersResponse>): QueryTraderDerivativeOrdersResponse {
    const message = createBaseQueryTraderDerivativeOrdersResponse();
    message.orders = object.orders?.map((e) => TrimmedDerivativeLimitOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryDerivativeOrdersByHashesRequest(): QueryDerivativeOrdersByHashesRequest {
  return { marketId: "", subaccountId: "", orderHashes: [] };
}

export const QueryDerivativeOrdersByHashesRequest = {
  encode(message: QueryDerivativeOrdersByHashesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    for (const v of message.orderHashes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeOrdersByHashesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeOrdersByHashesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.orderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeOrdersByHashesRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHashes: Array.isArray(object?.orderHashes) ? object.orderHashes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: QueryDerivativeOrdersByHashesRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.orderHashes) {
      obj.orderHashes = message.orderHashes.map((e) => e);
    } else {
      obj.orderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeOrdersByHashesRequest>): QueryDerivativeOrdersByHashesRequest {
    return QueryDerivativeOrdersByHashesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeOrdersByHashesRequest>): QueryDerivativeOrdersByHashesRequest {
    const message = createBaseQueryDerivativeOrdersByHashesRequest();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHashes = object.orderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryDerivativeOrdersByHashesResponse(): QueryDerivativeOrdersByHashesResponse {
  return { orders: [] };
}

export const QueryDerivativeOrdersByHashesResponse = {
  encode(message: QueryDerivativeOrdersByHashesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      TrimmedDerivativeLimitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeOrdersByHashesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeOrdersByHashesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(TrimmedDerivativeLimitOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeOrdersByHashesResponse {
    return {
      orders: Array.isArray(object?.orders)
        ? object.orders.map((e: any) => TrimmedDerivativeLimitOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDerivativeOrdersByHashesResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? TrimmedDerivativeLimitOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeOrdersByHashesResponse>): QueryDerivativeOrdersByHashesResponse {
    return QueryDerivativeOrdersByHashesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeOrdersByHashesResponse>): QueryDerivativeOrdersByHashesResponse {
    const message = createBaseQueryDerivativeOrdersByHashesResponse();
    message.orders = object.orders?.map((e) => TrimmedDerivativeLimitOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryDerivativeMarketsRequest(): QueryDerivativeMarketsRequest {
  return { status: "" };
}

export const QueryDerivativeMarketsRequest = {
  encode(message: QueryDerivativeMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketsRequest {
    return { status: isSet(object.status) ? String(object.status) : "" };
  },

  toJSON(message: QueryDerivativeMarketsRequest): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketsRequest>): QueryDerivativeMarketsRequest {
    return QueryDerivativeMarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketsRequest>): QueryDerivativeMarketsRequest {
    const message = createBaseQueryDerivativeMarketsRequest();
    message.status = object.status ?? "";
    return message;
  },
};

function createBasePriceLevel(): PriceLevel {
  return { price: "", quantity: "" };
}

export const PriceLevel = {
  encode(message: PriceLevel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PriceLevel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PriceLevel {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
    };
  },

  toJSON(message: PriceLevel): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    return obj;
  },

  create(base?: DeepPartial<PriceLevel>): PriceLevel {
    return PriceLevel.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PriceLevel>): PriceLevel {
    const message = createBasePriceLevel();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    return message;
  },
};

function createBasePerpetualMarketState(): PerpetualMarketState {
  return { marketInfo: undefined, fundingInfo: undefined };
}

export const PerpetualMarketState = {
  encode(message: PerpetualMarketState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketInfo !== undefined) {
      PerpetualMarketInfo.encode(message.marketInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.fundingInfo !== undefined) {
      PerpetualMarketFunding.encode(message.fundingInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketInfo = PerpetualMarketInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.fundingInfo = PerpetualMarketFunding.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketState {
    return {
      marketInfo: isSet(object.marketInfo) ? PerpetualMarketInfo.fromJSON(object.marketInfo) : undefined,
      fundingInfo: isSet(object.fundingInfo) ? PerpetualMarketFunding.fromJSON(object.fundingInfo) : undefined,
    };
  },

  toJSON(message: PerpetualMarketState): unknown {
    const obj: any = {};
    message.marketInfo !== undefined &&
      (obj.marketInfo = message.marketInfo ? PerpetualMarketInfo.toJSON(message.marketInfo) : undefined);
    message.fundingInfo !== undefined &&
      (obj.fundingInfo = message.fundingInfo ? PerpetualMarketFunding.toJSON(message.fundingInfo) : undefined);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketState>): PerpetualMarketState {
    return PerpetualMarketState.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketState>): PerpetualMarketState {
    const message = createBasePerpetualMarketState();
    message.marketInfo = (object.marketInfo !== undefined && object.marketInfo !== null)
      ? PerpetualMarketInfo.fromPartial(object.marketInfo)
      : undefined;
    message.fundingInfo = (object.fundingInfo !== undefined && object.fundingInfo !== null)
      ? PerpetualMarketFunding.fromPartial(object.fundingInfo)
      : undefined;
    return message;
  },
};

function createBaseFullDerivativeMarket(): FullDerivativeMarket {
  return { market: undefined, perpetualInfo: undefined, futuresInfo: undefined, markPrice: "" };
}

export const FullDerivativeMarket = {
  encode(message: FullDerivativeMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      DerivativeMarket.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    if (message.perpetualInfo !== undefined) {
      PerpetualMarketState.encode(message.perpetualInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.futuresInfo !== undefined) {
      ExpiryFuturesMarketInfo.encode(message.futuresInfo, writer.uint32(26).fork()).ldelim();
    }
    if (message.markPrice !== "") {
      writer.uint32(34).string(message.markPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FullDerivativeMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullDerivativeMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = DerivativeMarket.decode(reader, reader.uint32());
          break;
        case 2:
          message.perpetualInfo = PerpetualMarketState.decode(reader, reader.uint32());
          break;
        case 3:
          message.futuresInfo = ExpiryFuturesMarketInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.markPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FullDerivativeMarket {
    return {
      market: isSet(object.market) ? DerivativeMarket.fromJSON(object.market) : undefined,
      perpetualInfo: isSet(object.perpetualInfo) ? PerpetualMarketState.fromJSON(object.perpetualInfo) : undefined,
      futuresInfo: isSet(object.futuresInfo) ? ExpiryFuturesMarketInfo.fromJSON(object.futuresInfo) : undefined,
      markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
    };
  },

  toJSON(message: FullDerivativeMarket): unknown {
    const obj: any = {};
    message.market !== undefined && (obj.market = message.market ? DerivativeMarket.toJSON(message.market) : undefined);
    message.perpetualInfo !== undefined &&
      (obj.perpetualInfo = message.perpetualInfo ? PerpetualMarketState.toJSON(message.perpetualInfo) : undefined);
    message.futuresInfo !== undefined &&
      (obj.futuresInfo = message.futuresInfo ? ExpiryFuturesMarketInfo.toJSON(message.futuresInfo) : undefined);
    message.markPrice !== undefined && (obj.markPrice = message.markPrice);
    return obj;
  },

  create(base?: DeepPartial<FullDerivativeMarket>): FullDerivativeMarket {
    return FullDerivativeMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FullDerivativeMarket>): FullDerivativeMarket {
    const message = createBaseFullDerivativeMarket();
    message.market = (object.market !== undefined && object.market !== null)
      ? DerivativeMarket.fromPartial(object.market)
      : undefined;
    message.perpetualInfo = (object.perpetualInfo !== undefined && object.perpetualInfo !== null)
      ? PerpetualMarketState.fromPartial(object.perpetualInfo)
      : undefined;
    message.futuresInfo = (object.futuresInfo !== undefined && object.futuresInfo !== null)
      ? ExpiryFuturesMarketInfo.fromPartial(object.futuresInfo)
      : undefined;
    message.markPrice = object.markPrice ?? "";
    return message;
  },
};

function createBaseQueryDerivativeMarketsResponse(): QueryDerivativeMarketsResponse {
  return { markets: [] };
}

export const QueryDerivativeMarketsResponse = {
  encode(message: QueryDerivativeMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      FullDerivativeMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(FullDerivativeMarket.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketsResponse {
    return {
      markets: Array.isArray(object?.markets) ? object.markets.map((e: any) => FullDerivativeMarket.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryDerivativeMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? FullDerivativeMarket.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketsResponse>): QueryDerivativeMarketsResponse {
    return QueryDerivativeMarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketsResponse>): QueryDerivativeMarketsResponse {
    const message = createBaseQueryDerivativeMarketsResponse();
    message.markets = object.markets?.map((e) => FullDerivativeMarket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryDerivativeMarketRequest(): QueryDerivativeMarketRequest {
  return { marketId: "" };
}

export const QueryDerivativeMarketRequest = {
  encode(message: QueryDerivativeMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryDerivativeMarketRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketRequest>): QueryDerivativeMarketRequest {
    return QueryDerivativeMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketRequest>): QueryDerivativeMarketRequest {
    const message = createBaseQueryDerivativeMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryDerivativeMarketResponse(): QueryDerivativeMarketResponse {
  return { market: undefined };
}

export const QueryDerivativeMarketResponse = {
  encode(message: QueryDerivativeMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.market !== undefined) {
      FullDerivativeMarket.encode(message.market, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.market = FullDerivativeMarket.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketResponse {
    return { market: isSet(object.market) ? FullDerivativeMarket.fromJSON(object.market) : undefined };
  },

  toJSON(message: QueryDerivativeMarketResponse): unknown {
    const obj: any = {};
    message.market !== undefined &&
      (obj.market = message.market ? FullDerivativeMarket.toJSON(message.market) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketResponse>): QueryDerivativeMarketResponse {
    return QueryDerivativeMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketResponse>): QueryDerivativeMarketResponse {
    const message = createBaseQueryDerivativeMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? FullDerivativeMarket.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseQueryDerivativeMarketAddressRequest(): QueryDerivativeMarketAddressRequest {
  return { marketId: "" };
}

export const QueryDerivativeMarketAddressRequest = {
  encode(message: QueryDerivativeMarketAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketAddressRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketAddressRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryDerivativeMarketAddressRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketAddressRequest>): QueryDerivativeMarketAddressRequest {
    return QueryDerivativeMarketAddressRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketAddressRequest>): QueryDerivativeMarketAddressRequest {
    const message = createBaseQueryDerivativeMarketAddressRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryDerivativeMarketAddressResponse(): QueryDerivativeMarketAddressResponse {
  return { address: "", subaccountId: "" };
}

export const QueryDerivativeMarketAddressResponse = {
  encode(message: QueryDerivativeMarketAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDerivativeMarketAddressResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivativeMarketAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryDerivativeMarketAddressResponse {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
    };
  },

  toJSON(message: QueryDerivativeMarketAddressResponse): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QueryDerivativeMarketAddressResponse>): QueryDerivativeMarketAddressResponse {
    return QueryDerivativeMarketAddressResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryDerivativeMarketAddressResponse>): QueryDerivativeMarketAddressResponse {
    const message = createBaseQueryDerivativeMarketAddressResponse();
    message.address = object.address ?? "";
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountTradeNonceRequest(): QuerySubaccountTradeNonceRequest {
  return { subaccountId: "" };
}

export const QuerySubaccountTradeNonceRequest = {
  encode(message: QuerySubaccountTradeNonceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountTradeNonceRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountTradeNonceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountTradeNonceRequest {
    return { subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "" };
  },

  toJSON(message: QuerySubaccountTradeNonceRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountTradeNonceRequest>): QuerySubaccountTradeNonceRequest {
    return QuerySubaccountTradeNonceRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountTradeNonceRequest>): QuerySubaccountTradeNonceRequest {
    const message = createBaseQuerySubaccountTradeNonceRequest();
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountPositionsRequest(): QuerySubaccountPositionsRequest {
  return { subaccountId: "" };
}

export const QuerySubaccountPositionsRequest = {
  encode(message: QuerySubaccountPositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountPositionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountPositionsRequest {
    return { subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "" };
  },

  toJSON(message: QuerySubaccountPositionsRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountPositionsRequest>): QuerySubaccountPositionsRequest {
    return QuerySubaccountPositionsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountPositionsRequest>): QuerySubaccountPositionsRequest {
    const message = createBaseQuerySubaccountPositionsRequest();
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountPositionInMarketRequest(): QuerySubaccountPositionInMarketRequest {
  return { subaccountId: "", marketId: "" };
}

export const QuerySubaccountPositionInMarketRequest = {
  encode(message: QuerySubaccountPositionInMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountPositionInMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountPositionInMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountPositionInMarketRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: QuerySubaccountPositionInMarketRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountPositionInMarketRequest>): QuerySubaccountPositionInMarketRequest {
    return QuerySubaccountPositionInMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountPositionInMarketRequest>): QuerySubaccountPositionInMarketRequest {
    const message = createBaseQuerySubaccountPositionInMarketRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountEffectivePositionInMarketRequest(): QuerySubaccountEffectivePositionInMarketRequest {
  return { subaccountId: "", marketId: "" };
}

export const QuerySubaccountEffectivePositionInMarketRequest = {
  encode(
    message: QuerySubaccountEffectivePositionInMarketRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountEffectivePositionInMarketRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountEffectivePositionInMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountEffectivePositionInMarketRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: QuerySubaccountEffectivePositionInMarketRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(
    base?: DeepPartial<QuerySubaccountEffectivePositionInMarketRequest>,
  ): QuerySubaccountEffectivePositionInMarketRequest {
    return QuerySubaccountEffectivePositionInMarketRequest.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QuerySubaccountEffectivePositionInMarketRequest>,
  ): QuerySubaccountEffectivePositionInMarketRequest {
    const message = createBaseQuerySubaccountEffectivePositionInMarketRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountOrderMetadataRequest(): QuerySubaccountOrderMetadataRequest {
  return { subaccountId: "" };
}

export const QuerySubaccountOrderMetadataRequest = {
  encode(message: QuerySubaccountOrderMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountOrderMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountOrderMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountOrderMetadataRequest {
    return { subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "" };
  },

  toJSON(message: QuerySubaccountOrderMetadataRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountOrderMetadataRequest>): QuerySubaccountOrderMetadataRequest {
    return QuerySubaccountOrderMetadataRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountOrderMetadataRequest>): QuerySubaccountOrderMetadataRequest {
    const message = createBaseQuerySubaccountOrderMetadataRequest();
    message.subaccountId = object.subaccountId ?? "";
    return message;
  },
};

function createBaseQuerySubaccountPositionsResponse(): QuerySubaccountPositionsResponse {
  return { state: [] };
}

export const QuerySubaccountPositionsResponse = {
  encode(message: QuerySubaccountPositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.state) {
      DerivativePosition.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountPositionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state.push(DerivativePosition.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountPositionsResponse {
    return { state: Array.isArray(object?.state) ? object.state.map((e: any) => DerivativePosition.fromJSON(e)) : [] };
  },

  toJSON(message: QuerySubaccountPositionsResponse): unknown {
    const obj: any = {};
    if (message.state) {
      obj.state = message.state.map((e) => e ? DerivativePosition.toJSON(e) : undefined);
    } else {
      obj.state = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountPositionsResponse>): QuerySubaccountPositionsResponse {
    return QuerySubaccountPositionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountPositionsResponse>): QuerySubaccountPositionsResponse {
    const message = createBaseQuerySubaccountPositionsResponse();
    message.state = object.state?.map((e) => DerivativePosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySubaccountPositionInMarketResponse(): QuerySubaccountPositionInMarketResponse {
  return { state: undefined };
}

export const QuerySubaccountPositionInMarketResponse = {
  encode(message: QuerySubaccountPositionInMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      Position.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountPositionInMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountPositionInMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = Position.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountPositionInMarketResponse {
    return { state: isSet(object.state) ? Position.fromJSON(object.state) : undefined };
  },

  toJSON(message: QuerySubaccountPositionInMarketResponse): unknown {
    const obj: any = {};
    message.state !== undefined && (obj.state = message.state ? Position.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountPositionInMarketResponse>): QuerySubaccountPositionInMarketResponse {
    return QuerySubaccountPositionInMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountPositionInMarketResponse>): QuerySubaccountPositionInMarketResponse {
    const message = createBaseQuerySubaccountPositionInMarketResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? Position.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseEffectivePosition(): EffectivePosition {
  return { isLong: false, quantity: "", entryPrice: "", effectiveMargin: "" };
}

export const EffectivePosition = {
  encode(message: EffectivePosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isLong === true) {
      writer.uint32(8).bool(message.isLong);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.entryPrice !== "") {
      writer.uint32(26).string(message.entryPrice);
    }
    if (message.effectiveMargin !== "") {
      writer.uint32(34).string(message.effectiveMargin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectivePosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectivePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isLong = reader.bool();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.entryPrice = reader.string();
          break;
        case 4:
          message.effectiveMargin = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EffectivePosition {
    return {
      isLong: isSet(object.isLong) ? Boolean(object.isLong) : false,
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      entryPrice: isSet(object.entryPrice) ? String(object.entryPrice) : "",
      effectiveMargin: isSet(object.effectiveMargin) ? String(object.effectiveMargin) : "",
    };
  },

  toJSON(message: EffectivePosition): unknown {
    const obj: any = {};
    message.isLong !== undefined && (obj.isLong = message.isLong);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.entryPrice !== undefined && (obj.entryPrice = message.entryPrice);
    message.effectiveMargin !== undefined && (obj.effectiveMargin = message.effectiveMargin);
    return obj;
  },

  create(base?: DeepPartial<EffectivePosition>): EffectivePosition {
    return EffectivePosition.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<EffectivePosition>): EffectivePosition {
    const message = createBaseEffectivePosition();
    message.isLong = object.isLong ?? false;
    message.quantity = object.quantity ?? "";
    message.entryPrice = object.entryPrice ?? "";
    message.effectiveMargin = object.effectiveMargin ?? "";
    return message;
  },
};

function createBaseQuerySubaccountEffectivePositionInMarketResponse(): QuerySubaccountEffectivePositionInMarketResponse {
  return { state: undefined };
}

export const QuerySubaccountEffectivePositionInMarketResponse = {
  encode(
    message: QuerySubaccountEffectivePositionInMarketResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.state !== undefined) {
      EffectivePosition.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountEffectivePositionInMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountEffectivePositionInMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = EffectivePosition.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountEffectivePositionInMarketResponse {
    return { state: isSet(object.state) ? EffectivePosition.fromJSON(object.state) : undefined };
  },

  toJSON(message: QuerySubaccountEffectivePositionInMarketResponse): unknown {
    const obj: any = {};
    message.state !== undefined && (obj.state = message.state ? EffectivePosition.toJSON(message.state) : undefined);
    return obj;
  },

  create(
    base?: DeepPartial<QuerySubaccountEffectivePositionInMarketResponse>,
  ): QuerySubaccountEffectivePositionInMarketResponse {
    return QuerySubaccountEffectivePositionInMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QuerySubaccountEffectivePositionInMarketResponse>,
  ): QuerySubaccountEffectivePositionInMarketResponse {
    const message = createBaseQuerySubaccountEffectivePositionInMarketResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? EffectivePosition.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseQueryPerpetualMarketInfoRequest(): QueryPerpetualMarketInfoRequest {
  return { marketId: "" };
}

export const QueryPerpetualMarketInfoRequest = {
  encode(message: QueryPerpetualMarketInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPerpetualMarketInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPerpetualMarketInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPerpetualMarketInfoRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryPerpetualMarketInfoRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryPerpetualMarketInfoRequest>): QueryPerpetualMarketInfoRequest {
    return QueryPerpetualMarketInfoRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPerpetualMarketInfoRequest>): QueryPerpetualMarketInfoRequest {
    const message = createBaseQueryPerpetualMarketInfoRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryPerpetualMarketInfoResponse(): QueryPerpetualMarketInfoResponse {
  return { info: undefined };
}

export const QueryPerpetualMarketInfoResponse = {
  encode(message: QueryPerpetualMarketInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.info !== undefined) {
      PerpetualMarketInfo.encode(message.info, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPerpetualMarketInfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPerpetualMarketInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.info = PerpetualMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPerpetualMarketInfoResponse {
    return { info: isSet(object.info) ? PerpetualMarketInfo.fromJSON(object.info) : undefined };
  },

  toJSON(message: QueryPerpetualMarketInfoResponse): unknown {
    const obj: any = {};
    message.info !== undefined && (obj.info = message.info ? PerpetualMarketInfo.toJSON(message.info) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryPerpetualMarketInfoResponse>): QueryPerpetualMarketInfoResponse {
    return QueryPerpetualMarketInfoResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPerpetualMarketInfoResponse>): QueryPerpetualMarketInfoResponse {
    const message = createBaseQueryPerpetualMarketInfoResponse();
    message.info = (object.info !== undefined && object.info !== null)
      ? PerpetualMarketInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseQueryExpiryFuturesMarketInfoRequest(): QueryExpiryFuturesMarketInfoRequest {
  return { marketId: "" };
}

export const QueryExpiryFuturesMarketInfoRequest = {
  encode(message: QueryExpiryFuturesMarketInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExpiryFuturesMarketInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExpiryFuturesMarketInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryExpiryFuturesMarketInfoRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryExpiryFuturesMarketInfoRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryExpiryFuturesMarketInfoRequest>): QueryExpiryFuturesMarketInfoRequest {
    return QueryExpiryFuturesMarketInfoRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryExpiryFuturesMarketInfoRequest>): QueryExpiryFuturesMarketInfoRequest {
    const message = createBaseQueryExpiryFuturesMarketInfoRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryExpiryFuturesMarketInfoResponse(): QueryExpiryFuturesMarketInfoResponse {
  return { info: undefined };
}

export const QueryExpiryFuturesMarketInfoResponse = {
  encode(message: QueryExpiryFuturesMarketInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.info !== undefined) {
      ExpiryFuturesMarketInfo.encode(message.info, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryExpiryFuturesMarketInfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryExpiryFuturesMarketInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.info = ExpiryFuturesMarketInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryExpiryFuturesMarketInfoResponse {
    return { info: isSet(object.info) ? ExpiryFuturesMarketInfo.fromJSON(object.info) : undefined };
  },

  toJSON(message: QueryExpiryFuturesMarketInfoResponse): unknown {
    const obj: any = {};
    message.info !== undefined && (obj.info = message.info ? ExpiryFuturesMarketInfo.toJSON(message.info) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryExpiryFuturesMarketInfoResponse>): QueryExpiryFuturesMarketInfoResponse {
    return QueryExpiryFuturesMarketInfoResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryExpiryFuturesMarketInfoResponse>): QueryExpiryFuturesMarketInfoResponse {
    const message = createBaseQueryExpiryFuturesMarketInfoResponse();
    message.info = (object.info !== undefined && object.info !== null)
      ? ExpiryFuturesMarketInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseQueryPerpetualMarketFundingRequest(): QueryPerpetualMarketFundingRequest {
  return { marketId: "" };
}

export const QueryPerpetualMarketFundingRequest = {
  encode(message: QueryPerpetualMarketFundingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPerpetualMarketFundingRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPerpetualMarketFundingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPerpetualMarketFundingRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryPerpetualMarketFundingRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryPerpetualMarketFundingRequest>): QueryPerpetualMarketFundingRequest {
    return QueryPerpetualMarketFundingRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPerpetualMarketFundingRequest>): QueryPerpetualMarketFundingRequest {
    const message = createBaseQueryPerpetualMarketFundingRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryPerpetualMarketFundingResponse(): QueryPerpetualMarketFundingResponse {
  return { state: undefined };
}

export const QueryPerpetualMarketFundingResponse = {
  encode(message: QueryPerpetualMarketFundingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      PerpetualMarketFunding.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPerpetualMarketFundingResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPerpetualMarketFundingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = PerpetualMarketFunding.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPerpetualMarketFundingResponse {
    return { state: isSet(object.state) ? PerpetualMarketFunding.fromJSON(object.state) : undefined };
  },

  toJSON(message: QueryPerpetualMarketFundingResponse): unknown {
    const obj: any = {};
    message.state !== undefined &&
      (obj.state = message.state ? PerpetualMarketFunding.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryPerpetualMarketFundingResponse>): QueryPerpetualMarketFundingResponse {
    return QueryPerpetualMarketFundingResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPerpetualMarketFundingResponse>): QueryPerpetualMarketFundingResponse {
    const message = createBaseQueryPerpetualMarketFundingResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? PerpetualMarketFunding.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseQuerySubaccountOrderMetadataResponse(): QuerySubaccountOrderMetadataResponse {
  return { metadata: [] };
}

export const QuerySubaccountOrderMetadataResponse = {
  encode(message: QuerySubaccountOrderMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.metadata) {
      SubaccountOrderbookMetadataWithMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountOrderMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountOrderMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadata.push(SubaccountOrderbookMetadataWithMarket.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountOrderMetadataResponse {
    return {
      metadata: Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => SubaccountOrderbookMetadataWithMarket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySubaccountOrderMetadataResponse): unknown {
    const obj: any = {};
    if (message.metadata) {
      obj.metadata = message.metadata.map((e) => e ? SubaccountOrderbookMetadataWithMarket.toJSON(e) : undefined);
    } else {
      obj.metadata = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountOrderMetadataResponse>): QuerySubaccountOrderMetadataResponse {
    return QuerySubaccountOrderMetadataResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountOrderMetadataResponse>): QuerySubaccountOrderMetadataResponse {
    const message = createBaseQuerySubaccountOrderMetadataResponse();
    message.metadata = object.metadata?.map((e) => SubaccountOrderbookMetadataWithMarket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySubaccountTradeNonceResponse(): QuerySubaccountTradeNonceResponse {
  return { nonce: 0 };
}

export const QuerySubaccountTradeNonceResponse = {
  encode(message: QuerySubaccountTradeNonceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonce !== 0) {
      writer.uint32(8).uint32(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySubaccountTradeNonceResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySubaccountTradeNonceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nonce = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuerySubaccountTradeNonceResponse {
    return { nonce: isSet(object.nonce) ? Number(object.nonce) : 0 };
  },

  toJSON(message: QuerySubaccountTradeNonceResponse): unknown {
    const obj: any = {};
    message.nonce !== undefined && (obj.nonce = Math.round(message.nonce));
    return obj;
  },

  create(base?: DeepPartial<QuerySubaccountTradeNonceResponse>): QuerySubaccountTradeNonceResponse {
    return QuerySubaccountTradeNonceResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QuerySubaccountTradeNonceResponse>): QuerySubaccountTradeNonceResponse {
    const message = createBaseQuerySubaccountTradeNonceResponse();
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseQueryModuleStateRequest(): QueryModuleStateRequest {
  return {};
}

export const QueryModuleStateRequest = {
  encode(_: QueryModuleStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryModuleStateRequest {
    return {};
  },

  toJSON(_: QueryModuleStateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    return QueryModuleStateRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryModuleStateRequest>): QueryModuleStateRequest {
    const message = createBaseQueryModuleStateRequest();
    return message;
  },
};

function createBaseQueryModuleStateResponse(): QueryModuleStateResponse {
  return { state: undefined };
}

export const QueryModuleStateResponse = {
  encode(message: QueryModuleStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined) {
      GenesisState.encode(message.state, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryModuleStateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModuleStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state = GenesisState.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryModuleStateResponse {
    return { state: isSet(object.state) ? GenesisState.fromJSON(object.state) : undefined };
  },

  toJSON(message: QueryModuleStateResponse): unknown {
    const obj: any = {};
    message.state !== undefined && (obj.state = message.state ? GenesisState.toJSON(message.state) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    return QueryModuleStateResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryModuleStateResponse>): QueryModuleStateResponse {
    const message = createBaseQueryModuleStateResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? GenesisState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseQueryPositionsRequest(): QueryPositionsRequest {
  return {};
}

export const QueryPositionsRequest = {
  encode(_: QueryPositionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPositionsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryPositionsRequest {
    return {};
  },

  toJSON(_: QueryPositionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryPositionsRequest>): QueryPositionsRequest {
    return QueryPositionsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryPositionsRequest>): QueryPositionsRequest {
    const message = createBaseQueryPositionsRequest();
    return message;
  },
};

function createBaseQueryPositionsResponse(): QueryPositionsResponse {
  return { state: [] };
}

export const QueryPositionsResponse = {
  encode(message: QueryPositionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.state) {
      DerivativePosition.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryPositionsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.state.push(DerivativePosition.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryPositionsResponse {
    return { state: Array.isArray(object?.state) ? object.state.map((e: any) => DerivativePosition.fromJSON(e)) : [] };
  },

  toJSON(message: QueryPositionsResponse): unknown {
    const obj: any = {};
    if (message.state) {
      obj.state = message.state.map((e) => e ? DerivativePosition.toJSON(e) : undefined);
    } else {
      obj.state = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPositionsResponse>): QueryPositionsResponse {
    return QueryPositionsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryPositionsResponse>): QueryPositionsResponse {
    const message = createBaseQueryPositionsResponse();
    message.state = object.state?.map((e) => DerivativePosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryTradeRewardPointsRequest(): QueryTradeRewardPointsRequest {
  return { accounts: [], pendingPoolTimestamp: "0" };
}

export const QueryTradeRewardPointsRequest = {
  encode(message: QueryTradeRewardPointsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.pendingPoolTimestamp !== "0") {
      writer.uint32(16).int64(message.pendingPoolTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTradeRewardPointsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTradeRewardPointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accounts.push(reader.string());
          break;
        case 2:
          message.pendingPoolTimestamp = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTradeRewardPointsRequest {
    return {
      accounts: Array.isArray(object?.accounts) ? object.accounts.map((e: any) => String(e)) : [],
      pendingPoolTimestamp: isSet(object.pendingPoolTimestamp) ? String(object.pendingPoolTimestamp) : "0",
    };
  },

  toJSON(message: QueryTradeRewardPointsRequest): unknown {
    const obj: any = {};
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e);
    } else {
      obj.accounts = [];
    }
    message.pendingPoolTimestamp !== undefined && (obj.pendingPoolTimestamp = message.pendingPoolTimestamp);
    return obj;
  },

  create(base?: DeepPartial<QueryTradeRewardPointsRequest>): QueryTradeRewardPointsRequest {
    return QueryTradeRewardPointsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTradeRewardPointsRequest>): QueryTradeRewardPointsRequest {
    const message = createBaseQueryTradeRewardPointsRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.pendingPoolTimestamp = object.pendingPoolTimestamp ?? "0";
    return message;
  },
};

function createBaseQueryTradeRewardPointsResponse(): QueryTradeRewardPointsResponse {
  return { accountTradeRewardPoints: [] };
}

export const QueryTradeRewardPointsResponse = {
  encode(message: QueryTradeRewardPointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accountTradeRewardPoints) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTradeRewardPointsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTradeRewardPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountTradeRewardPoints.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTradeRewardPointsResponse {
    return {
      accountTradeRewardPoints: Array.isArray(object?.accountTradeRewardPoints)
        ? object.accountTradeRewardPoints.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: QueryTradeRewardPointsResponse): unknown {
    const obj: any = {};
    if (message.accountTradeRewardPoints) {
      obj.accountTradeRewardPoints = message.accountTradeRewardPoints.map((e) => e);
    } else {
      obj.accountTradeRewardPoints = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTradeRewardPointsResponse>): QueryTradeRewardPointsResponse {
    return QueryTradeRewardPointsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTradeRewardPointsResponse>): QueryTradeRewardPointsResponse {
    const message = createBaseQueryTradeRewardPointsResponse();
    message.accountTradeRewardPoints = object.accountTradeRewardPoints?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTradeRewardCampaignRequest(): QueryTradeRewardCampaignRequest {
  return {};
}

export const QueryTradeRewardCampaignRequest = {
  encode(_: QueryTradeRewardCampaignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTradeRewardCampaignRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTradeRewardCampaignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryTradeRewardCampaignRequest {
    return {};
  },

  toJSON(_: QueryTradeRewardCampaignRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryTradeRewardCampaignRequest>): QueryTradeRewardCampaignRequest {
    return QueryTradeRewardCampaignRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryTradeRewardCampaignRequest>): QueryTradeRewardCampaignRequest {
    const message = createBaseQueryTradeRewardCampaignRequest();
    return message;
  },
};

function createBaseQueryTradeRewardCampaignResponse(): QueryTradeRewardCampaignResponse {
  return {
    tradingRewardCampaignInfo: undefined,
    tradingRewardPoolCampaignSchedule: [],
    totalTradeRewardPoints: "",
    pendingTradingRewardPoolCampaignSchedule: [],
    pendingTotalTradeRewardPoints: [],
  };
}

export const QueryTradeRewardCampaignResponse = {
  encode(message: QueryTradeRewardCampaignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tradingRewardCampaignInfo !== undefined) {
      TradingRewardCampaignInfo.encode(message.tradingRewardCampaignInfo, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.tradingRewardPoolCampaignSchedule) {
      CampaignRewardPool.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.totalTradeRewardPoints !== "") {
      writer.uint32(26).string(message.totalTradeRewardPoints);
    }
    for (const v of message.pendingTradingRewardPoolCampaignSchedule) {
      CampaignRewardPool.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.pendingTotalTradeRewardPoints) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTradeRewardCampaignResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTradeRewardCampaignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tradingRewardCampaignInfo = TradingRewardCampaignInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.tradingRewardPoolCampaignSchedule.push(CampaignRewardPool.decode(reader, reader.uint32()));
          break;
        case 3:
          message.totalTradeRewardPoints = reader.string();
          break;
        case 4:
          message.pendingTradingRewardPoolCampaignSchedule.push(CampaignRewardPool.decode(reader, reader.uint32()));
          break;
        case 5:
          message.pendingTotalTradeRewardPoints.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTradeRewardCampaignResponse {
    return {
      tradingRewardCampaignInfo: isSet(object.tradingRewardCampaignInfo)
        ? TradingRewardCampaignInfo.fromJSON(object.tradingRewardCampaignInfo)
        : undefined,
      tradingRewardPoolCampaignSchedule: Array.isArray(object?.tradingRewardPoolCampaignSchedule)
        ? object.tradingRewardPoolCampaignSchedule.map((e: any) => CampaignRewardPool.fromJSON(e))
        : [],
      totalTradeRewardPoints: isSet(object.totalTradeRewardPoints) ? String(object.totalTradeRewardPoints) : "",
      pendingTradingRewardPoolCampaignSchedule: Array.isArray(object?.pendingTradingRewardPoolCampaignSchedule)
        ? object.pendingTradingRewardPoolCampaignSchedule.map((e: any) => CampaignRewardPool.fromJSON(e))
        : [],
      pendingTotalTradeRewardPoints: Array.isArray(object?.pendingTotalTradeRewardPoints)
        ? object.pendingTotalTradeRewardPoints.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: QueryTradeRewardCampaignResponse): unknown {
    const obj: any = {};
    message.tradingRewardCampaignInfo !== undefined &&
      (obj.tradingRewardCampaignInfo = message.tradingRewardCampaignInfo
        ? TradingRewardCampaignInfo.toJSON(message.tradingRewardCampaignInfo)
        : undefined);
    if (message.tradingRewardPoolCampaignSchedule) {
      obj.tradingRewardPoolCampaignSchedule = message.tradingRewardPoolCampaignSchedule.map((e) =>
        e ? CampaignRewardPool.toJSON(e) : undefined
      );
    } else {
      obj.tradingRewardPoolCampaignSchedule = [];
    }
    message.totalTradeRewardPoints !== undefined && (obj.totalTradeRewardPoints = message.totalTradeRewardPoints);
    if (message.pendingTradingRewardPoolCampaignSchedule) {
      obj.pendingTradingRewardPoolCampaignSchedule = message.pendingTradingRewardPoolCampaignSchedule.map((e) =>
        e ? CampaignRewardPool.toJSON(e) : undefined
      );
    } else {
      obj.pendingTradingRewardPoolCampaignSchedule = [];
    }
    if (message.pendingTotalTradeRewardPoints) {
      obj.pendingTotalTradeRewardPoints = message.pendingTotalTradeRewardPoints.map((e) => e);
    } else {
      obj.pendingTotalTradeRewardPoints = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTradeRewardCampaignResponse>): QueryTradeRewardCampaignResponse {
    return QueryTradeRewardCampaignResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryTradeRewardCampaignResponse>): QueryTradeRewardCampaignResponse {
    const message = createBaseQueryTradeRewardCampaignResponse();
    message.tradingRewardCampaignInfo =
      (object.tradingRewardCampaignInfo !== undefined && object.tradingRewardCampaignInfo !== null)
        ? TradingRewardCampaignInfo.fromPartial(object.tradingRewardCampaignInfo)
        : undefined;
    message.tradingRewardPoolCampaignSchedule =
      object.tradingRewardPoolCampaignSchedule?.map((e) => CampaignRewardPool.fromPartial(e)) || [];
    message.totalTradeRewardPoints = object.totalTradeRewardPoints ?? "";
    message.pendingTradingRewardPoolCampaignSchedule =
      object.pendingTradingRewardPoolCampaignSchedule?.map((e) => CampaignRewardPool.fromPartial(e)) || [];
    message.pendingTotalTradeRewardPoints = object.pendingTotalTradeRewardPoints?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryIsOptedOutOfRewardsRequest(): QueryIsOptedOutOfRewardsRequest {
  return { account: "" };
}

export const QueryIsOptedOutOfRewardsRequest = {
  encode(message: QueryIsOptedOutOfRewardsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsOptedOutOfRewardsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsOptedOutOfRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryIsOptedOutOfRewardsRequest {
    return { account: isSet(object.account) ? String(object.account) : "" };
  },

  toJSON(message: QueryIsOptedOutOfRewardsRequest): unknown {
    const obj: any = {};
    message.account !== undefined && (obj.account = message.account);
    return obj;
  },

  create(base?: DeepPartial<QueryIsOptedOutOfRewardsRequest>): QueryIsOptedOutOfRewardsRequest {
    return QueryIsOptedOutOfRewardsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryIsOptedOutOfRewardsRequest>): QueryIsOptedOutOfRewardsRequest {
    const message = createBaseQueryIsOptedOutOfRewardsRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseQueryIsOptedOutOfRewardsResponse(): QueryIsOptedOutOfRewardsResponse {
  return { isOptedOut: false };
}

export const QueryIsOptedOutOfRewardsResponse = {
  encode(message: QueryIsOptedOutOfRewardsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isOptedOut === true) {
      writer.uint32(8).bool(message.isOptedOut);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsOptedOutOfRewardsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIsOptedOutOfRewardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isOptedOut = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryIsOptedOutOfRewardsResponse {
    return { isOptedOut: isSet(object.isOptedOut) ? Boolean(object.isOptedOut) : false };
  },

  toJSON(message: QueryIsOptedOutOfRewardsResponse): unknown {
    const obj: any = {};
    message.isOptedOut !== undefined && (obj.isOptedOut = message.isOptedOut);
    return obj;
  },

  create(base?: DeepPartial<QueryIsOptedOutOfRewardsResponse>): QueryIsOptedOutOfRewardsResponse {
    return QueryIsOptedOutOfRewardsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryIsOptedOutOfRewardsResponse>): QueryIsOptedOutOfRewardsResponse {
    const message = createBaseQueryIsOptedOutOfRewardsResponse();
    message.isOptedOut = object.isOptedOut ?? false;
    return message;
  },
};

function createBaseQueryOptedOutOfRewardsAccountsRequest(): QueryOptedOutOfRewardsAccountsRequest {
  return {};
}

export const QueryOptedOutOfRewardsAccountsRequest = {
  encode(_: QueryOptedOutOfRewardsAccountsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOptedOutOfRewardsAccountsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOptedOutOfRewardsAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryOptedOutOfRewardsAccountsRequest {
    return {};
  },

  toJSON(_: QueryOptedOutOfRewardsAccountsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryOptedOutOfRewardsAccountsRequest>): QueryOptedOutOfRewardsAccountsRequest {
    return QueryOptedOutOfRewardsAccountsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryOptedOutOfRewardsAccountsRequest>): QueryOptedOutOfRewardsAccountsRequest {
    const message = createBaseQueryOptedOutOfRewardsAccountsRequest();
    return message;
  },
};

function createBaseQueryOptedOutOfRewardsAccountsResponse(): QueryOptedOutOfRewardsAccountsResponse {
  return { accounts: [] };
}

export const QueryOptedOutOfRewardsAccountsResponse = {
  encode(message: QueryOptedOutOfRewardsAccountsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOptedOutOfRewardsAccountsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOptedOutOfRewardsAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accounts.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryOptedOutOfRewardsAccountsResponse {
    return { accounts: Array.isArray(object?.accounts) ? object.accounts.map((e: any) => String(e)) : [] };
  },

  toJSON(message: QueryOptedOutOfRewardsAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e);
    } else {
      obj.accounts = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOptedOutOfRewardsAccountsResponse>): QueryOptedOutOfRewardsAccountsResponse {
    return QueryOptedOutOfRewardsAccountsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryOptedOutOfRewardsAccountsResponse>): QueryOptedOutOfRewardsAccountsResponse {
    const message = createBaseQueryOptedOutOfRewardsAccountsResponse();
    message.accounts = object.accounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryFeeDiscountAccountInfoRequest(): QueryFeeDiscountAccountInfoRequest {
  return { account: "" };
}

export const QueryFeeDiscountAccountInfoRequest = {
  encode(message: QueryFeeDiscountAccountInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountAccountInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountAccountInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryFeeDiscountAccountInfoRequest {
    return { account: isSet(object.account) ? String(object.account) : "" };
  },

  toJSON(message: QueryFeeDiscountAccountInfoRequest): unknown {
    const obj: any = {};
    message.account !== undefined && (obj.account = message.account);
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountAccountInfoRequest>): QueryFeeDiscountAccountInfoRequest {
    return QueryFeeDiscountAccountInfoRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryFeeDiscountAccountInfoRequest>): QueryFeeDiscountAccountInfoRequest {
    const message = createBaseQueryFeeDiscountAccountInfoRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseQueryFeeDiscountAccountInfoResponse(): QueryFeeDiscountAccountInfoResponse {
  return { tierLevel: "0", accountInfo: undefined, accountTtl: undefined };
}

export const QueryFeeDiscountAccountInfoResponse = {
  encode(message: QueryFeeDiscountAccountInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tierLevel !== "0") {
      writer.uint32(8).uint64(message.tierLevel);
    }
    if (message.accountInfo !== undefined) {
      FeeDiscountTierInfo.encode(message.accountInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.accountTtl !== undefined) {
      FeeDiscountTierTTL.encode(message.accountTtl, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountAccountInfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountAccountInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tierLevel = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.accountInfo = FeeDiscountTierInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.accountTtl = FeeDiscountTierTTL.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryFeeDiscountAccountInfoResponse {
    return {
      tierLevel: isSet(object.tierLevel) ? String(object.tierLevel) : "0",
      accountInfo: isSet(object.accountInfo) ? FeeDiscountTierInfo.fromJSON(object.accountInfo) : undefined,
      accountTtl: isSet(object.accountTtl) ? FeeDiscountTierTTL.fromJSON(object.accountTtl) : undefined,
    };
  },

  toJSON(message: QueryFeeDiscountAccountInfoResponse): unknown {
    const obj: any = {};
    message.tierLevel !== undefined && (obj.tierLevel = message.tierLevel);
    message.accountInfo !== undefined &&
      (obj.accountInfo = message.accountInfo ? FeeDiscountTierInfo.toJSON(message.accountInfo) : undefined);
    message.accountTtl !== undefined &&
      (obj.accountTtl = message.accountTtl ? FeeDiscountTierTTL.toJSON(message.accountTtl) : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountAccountInfoResponse>): QueryFeeDiscountAccountInfoResponse {
    return QueryFeeDiscountAccountInfoResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryFeeDiscountAccountInfoResponse>): QueryFeeDiscountAccountInfoResponse {
    const message = createBaseQueryFeeDiscountAccountInfoResponse();
    message.tierLevel = object.tierLevel ?? "0";
    message.accountInfo = (object.accountInfo !== undefined && object.accountInfo !== null)
      ? FeeDiscountTierInfo.fromPartial(object.accountInfo)
      : undefined;
    message.accountTtl = (object.accountTtl !== undefined && object.accountTtl !== null)
      ? FeeDiscountTierTTL.fromPartial(object.accountTtl)
      : undefined;
    return message;
  },
};

function createBaseQueryFeeDiscountScheduleRequest(): QueryFeeDiscountScheduleRequest {
  return {};
}

export const QueryFeeDiscountScheduleRequest = {
  encode(_: QueryFeeDiscountScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryFeeDiscountScheduleRequest {
    return {};
  },

  toJSON(_: QueryFeeDiscountScheduleRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountScheduleRequest>): QueryFeeDiscountScheduleRequest {
    return QueryFeeDiscountScheduleRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryFeeDiscountScheduleRequest>): QueryFeeDiscountScheduleRequest {
    const message = createBaseQueryFeeDiscountScheduleRequest();
    return message;
  },
};

function createBaseQueryFeeDiscountScheduleResponse(): QueryFeeDiscountScheduleResponse {
  return { feeDiscountSchedule: undefined };
}

export const QueryFeeDiscountScheduleResponse = {
  encode(message: QueryFeeDiscountScheduleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feeDiscountSchedule !== undefined) {
      FeeDiscountSchedule.encode(message.feeDiscountSchedule, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountScheduleResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.feeDiscountSchedule = FeeDiscountSchedule.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryFeeDiscountScheduleResponse {
    return {
      feeDiscountSchedule: isSet(object.feeDiscountSchedule)
        ? FeeDiscountSchedule.fromJSON(object.feeDiscountSchedule)
        : undefined,
    };
  },

  toJSON(message: QueryFeeDiscountScheduleResponse): unknown {
    const obj: any = {};
    message.feeDiscountSchedule !== undefined && (obj.feeDiscountSchedule = message.feeDiscountSchedule
      ? FeeDiscountSchedule.toJSON(message.feeDiscountSchedule)
      : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountScheduleResponse>): QueryFeeDiscountScheduleResponse {
    return QueryFeeDiscountScheduleResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryFeeDiscountScheduleResponse>): QueryFeeDiscountScheduleResponse {
    const message = createBaseQueryFeeDiscountScheduleResponse();
    message.feeDiscountSchedule = (object.feeDiscountSchedule !== undefined && object.feeDiscountSchedule !== null)
      ? FeeDiscountSchedule.fromPartial(object.feeDiscountSchedule)
      : undefined;
    return message;
  },
};

function createBaseQueryBalanceMismatchesRequest(): QueryBalanceMismatchesRequest {
  return { dustFactor: "0" };
}

export const QueryBalanceMismatchesRequest = {
  encode(message: QueryBalanceMismatchesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dustFactor !== "0") {
      writer.uint32(8).int64(message.dustFactor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceMismatchesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceMismatchesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dustFactor = longToString(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceMismatchesRequest {
    return { dustFactor: isSet(object.dustFactor) ? String(object.dustFactor) : "0" };
  },

  toJSON(message: QueryBalanceMismatchesRequest): unknown {
    const obj: any = {};
    message.dustFactor !== undefined && (obj.dustFactor = message.dustFactor);
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceMismatchesRequest>): QueryBalanceMismatchesRequest {
    return QueryBalanceMismatchesRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBalanceMismatchesRequest>): QueryBalanceMismatchesRequest {
    const message = createBaseQueryBalanceMismatchesRequest();
    message.dustFactor = object.dustFactor ?? "0";
    return message;
  },
};

function createBaseBalanceMismatch(): BalanceMismatch {
  return { subaccountId: "", denom: "", available: "", total: "", balanceHold: "", expectedTotal: "", difference: "" };
}

export const BalanceMismatch = {
  encode(message: BalanceMismatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.available !== "") {
      writer.uint32(26).string(message.available);
    }
    if (message.total !== "") {
      writer.uint32(34).string(message.total);
    }
    if (message.balanceHold !== "") {
      writer.uint32(42).string(message.balanceHold);
    }
    if (message.expectedTotal !== "") {
      writer.uint32(50).string(message.expectedTotal);
    }
    if (message.difference !== "") {
      writer.uint32(58).string(message.difference);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceMismatch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceMismatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.available = reader.string();
          break;
        case 4:
          message.total = reader.string();
          break;
        case 5:
          message.balanceHold = reader.string();
          break;
        case 6:
          message.expectedTotal = reader.string();
          break;
        case 7:
          message.difference = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BalanceMismatch {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      available: isSet(object.available) ? String(object.available) : "",
      total: isSet(object.total) ? String(object.total) : "",
      balanceHold: isSet(object.balanceHold) ? String(object.balanceHold) : "",
      expectedTotal: isSet(object.expectedTotal) ? String(object.expectedTotal) : "",
      difference: isSet(object.difference) ? String(object.difference) : "",
    };
  },

  toJSON(message: BalanceMismatch): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    message.available !== undefined && (obj.available = message.available);
    message.total !== undefined && (obj.total = message.total);
    message.balanceHold !== undefined && (obj.balanceHold = message.balanceHold);
    message.expectedTotal !== undefined && (obj.expectedTotal = message.expectedTotal);
    message.difference !== undefined && (obj.difference = message.difference);
    return obj;
  },

  create(base?: DeepPartial<BalanceMismatch>): BalanceMismatch {
    return BalanceMismatch.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BalanceMismatch>): BalanceMismatch {
    const message = createBaseBalanceMismatch();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    message.available = object.available ?? "";
    message.total = object.total ?? "";
    message.balanceHold = object.balanceHold ?? "";
    message.expectedTotal = object.expectedTotal ?? "";
    message.difference = object.difference ?? "";
    return message;
  },
};

function createBaseQueryBalanceMismatchesResponse(): QueryBalanceMismatchesResponse {
  return { balanceMismatches: [] };
}

export const QueryBalanceMismatchesResponse = {
  encode(message: QueryBalanceMismatchesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balanceMismatches) {
      BalanceMismatch.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceMismatchesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceMismatchesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balanceMismatches.push(BalanceMismatch.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceMismatchesResponse {
    return {
      balanceMismatches: Array.isArray(object?.balanceMismatches)
        ? object.balanceMismatches.map((e: any) => BalanceMismatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBalanceMismatchesResponse): unknown {
    const obj: any = {};
    if (message.balanceMismatches) {
      obj.balanceMismatches = message.balanceMismatches.map((e) => e ? BalanceMismatch.toJSON(e) : undefined);
    } else {
      obj.balanceMismatches = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceMismatchesResponse>): QueryBalanceMismatchesResponse {
    return QueryBalanceMismatchesResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBalanceMismatchesResponse>): QueryBalanceMismatchesResponse {
    const message = createBaseQueryBalanceMismatchesResponse();
    message.balanceMismatches = object.balanceMismatches?.map((e) => BalanceMismatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBalanceWithBalanceHoldsRequest(): QueryBalanceWithBalanceHoldsRequest {
  return {};
}

export const QueryBalanceWithBalanceHoldsRequest = {
  encode(_: QueryBalanceWithBalanceHoldsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceWithBalanceHoldsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceWithBalanceHoldsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryBalanceWithBalanceHoldsRequest {
    return {};
  },

  toJSON(_: QueryBalanceWithBalanceHoldsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceWithBalanceHoldsRequest>): QueryBalanceWithBalanceHoldsRequest {
    return QueryBalanceWithBalanceHoldsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryBalanceWithBalanceHoldsRequest>): QueryBalanceWithBalanceHoldsRequest {
    const message = createBaseQueryBalanceWithBalanceHoldsRequest();
    return message;
  },
};

function createBaseBalanceWithMarginHold(): BalanceWithMarginHold {
  return { subaccountId: "", denom: "", available: "", total: "", balanceHold: "" };
}

export const BalanceWithMarginHold = {
  encode(message: BalanceWithMarginHold, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.available !== "") {
      writer.uint32(26).string(message.available);
    }
    if (message.total !== "") {
      writer.uint32(34).string(message.total);
    }
    if (message.balanceHold !== "") {
      writer.uint32(42).string(message.balanceHold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceWithMarginHold {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceWithMarginHold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.denom = reader.string();
          break;
        case 3:
          message.available = reader.string();
          break;
        case 4:
          message.total = reader.string();
          break;
        case 5:
          message.balanceHold = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BalanceWithMarginHold {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      denom: isSet(object.denom) ? String(object.denom) : "",
      available: isSet(object.available) ? String(object.available) : "",
      total: isSet(object.total) ? String(object.total) : "",
      balanceHold: isSet(object.balanceHold) ? String(object.balanceHold) : "",
    };
  },

  toJSON(message: BalanceWithMarginHold): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.denom !== undefined && (obj.denom = message.denom);
    message.available !== undefined && (obj.available = message.available);
    message.total !== undefined && (obj.total = message.total);
    message.balanceHold !== undefined && (obj.balanceHold = message.balanceHold);
    return obj;
  },

  create(base?: DeepPartial<BalanceWithMarginHold>): BalanceWithMarginHold {
    return BalanceWithMarginHold.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BalanceWithMarginHold>): BalanceWithMarginHold {
    const message = createBaseBalanceWithMarginHold();
    message.subaccountId = object.subaccountId ?? "";
    message.denom = object.denom ?? "";
    message.available = object.available ?? "";
    message.total = object.total ?? "";
    message.balanceHold = object.balanceHold ?? "";
    return message;
  },
};

function createBaseQueryBalanceWithBalanceHoldsResponse(): QueryBalanceWithBalanceHoldsResponse {
  return { balanceWithBalanceHolds: [] };
}

export const QueryBalanceWithBalanceHoldsResponse = {
  encode(message: QueryBalanceWithBalanceHoldsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balanceWithBalanceHolds) {
      BalanceWithMarginHold.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceWithBalanceHoldsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceWithBalanceHoldsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balanceWithBalanceHolds.push(BalanceWithMarginHold.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceWithBalanceHoldsResponse {
    return {
      balanceWithBalanceHolds: Array.isArray(object?.balanceWithBalanceHolds)
        ? object.balanceWithBalanceHolds.map((e: any) => BalanceWithMarginHold.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBalanceWithBalanceHoldsResponse): unknown {
    const obj: any = {};
    if (message.balanceWithBalanceHolds) {
      obj.balanceWithBalanceHolds = message.balanceWithBalanceHolds.map((e) =>
        e ? BalanceWithMarginHold.toJSON(e) : undefined
      );
    } else {
      obj.balanceWithBalanceHolds = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceWithBalanceHoldsResponse>): QueryBalanceWithBalanceHoldsResponse {
    return QueryBalanceWithBalanceHoldsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBalanceWithBalanceHoldsResponse>): QueryBalanceWithBalanceHoldsResponse {
    const message = createBaseQueryBalanceWithBalanceHoldsResponse();
    message.balanceWithBalanceHolds =
      object.balanceWithBalanceHolds?.map((e) => BalanceWithMarginHold.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryFeeDiscountTierStatisticsRequest(): QueryFeeDiscountTierStatisticsRequest {
  return {};
}

export const QueryFeeDiscountTierStatisticsRequest = {
  encode(_: QueryFeeDiscountTierStatisticsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountTierStatisticsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountTierStatisticsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryFeeDiscountTierStatisticsRequest {
    return {};
  },

  toJSON(_: QueryFeeDiscountTierStatisticsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountTierStatisticsRequest>): QueryFeeDiscountTierStatisticsRequest {
    return QueryFeeDiscountTierStatisticsRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<QueryFeeDiscountTierStatisticsRequest>): QueryFeeDiscountTierStatisticsRequest {
    const message = createBaseQueryFeeDiscountTierStatisticsRequest();
    return message;
  },
};

function createBaseTierStatistic(): TierStatistic {
  return { tier: "0", count: "0" };
}

export const TierStatistic = {
  encode(message: TierStatistic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tier !== "0") {
      writer.uint32(8).uint64(message.tier);
    }
    if (message.count !== "0") {
      writer.uint32(16).uint64(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TierStatistic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTierStatistic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tier = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.count = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TierStatistic {
    return {
      tier: isSet(object.tier) ? String(object.tier) : "0",
      count: isSet(object.count) ? String(object.count) : "0",
    };
  },

  toJSON(message: TierStatistic): unknown {
    const obj: any = {};
    message.tier !== undefined && (obj.tier = message.tier);
    message.count !== undefined && (obj.count = message.count);
    return obj;
  },

  create(base?: DeepPartial<TierStatistic>): TierStatistic {
    return TierStatistic.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TierStatistic>): TierStatistic {
    const message = createBaseTierStatistic();
    message.tier = object.tier ?? "0";
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseQueryFeeDiscountTierStatisticsResponse(): QueryFeeDiscountTierStatisticsResponse {
  return { statistics: [] };
}

export const QueryFeeDiscountTierStatisticsResponse = {
  encode(message: QueryFeeDiscountTierStatisticsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.statistics) {
      TierStatistic.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFeeDiscountTierStatisticsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFeeDiscountTierStatisticsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.statistics.push(TierStatistic.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryFeeDiscountTierStatisticsResponse {
    return {
      statistics: Array.isArray(object?.statistics) ? object.statistics.map((e: any) => TierStatistic.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryFeeDiscountTierStatisticsResponse): unknown {
    const obj: any = {};
    if (message.statistics) {
      obj.statistics = message.statistics.map((e) => e ? TierStatistic.toJSON(e) : undefined);
    } else {
      obj.statistics = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryFeeDiscountTierStatisticsResponse>): QueryFeeDiscountTierStatisticsResponse {
    return QueryFeeDiscountTierStatisticsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryFeeDiscountTierStatisticsResponse>): QueryFeeDiscountTierStatisticsResponse {
    const message = createBaseQueryFeeDiscountTierStatisticsResponse();
    message.statistics = object.statistics?.map((e) => TierStatistic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMitoVaultInfosRequest(): MitoVaultInfosRequest {
  return {};
}

export const MitoVaultInfosRequest = {
  encode(_: MitoVaultInfosRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MitoVaultInfosRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMitoVaultInfosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MitoVaultInfosRequest {
    return {};
  },

  toJSON(_: MitoVaultInfosRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MitoVaultInfosRequest>): MitoVaultInfosRequest {
    return MitoVaultInfosRequest.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MitoVaultInfosRequest>): MitoVaultInfosRequest {
    const message = createBaseMitoVaultInfosRequest();
    return message;
  },
};

function createBaseMitoVaultInfosResponse(): MitoVaultInfosResponse {
  return { masterAddresses: [], derivativeAddresses: [], spotAddresses: [], cw20Addresses: [] };
}

export const MitoVaultInfosResponse = {
  encode(message: MitoVaultInfosResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.masterAddresses) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.derivativeAddresses) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.spotAddresses) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.cw20Addresses) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MitoVaultInfosResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMitoVaultInfosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.masterAddresses.push(reader.string());
          break;
        case 2:
          message.derivativeAddresses.push(reader.string());
          break;
        case 3:
          message.spotAddresses.push(reader.string());
          break;
        case 4:
          message.cw20Addresses.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MitoVaultInfosResponse {
    return {
      masterAddresses: Array.isArray(object?.masterAddresses) ? object.masterAddresses.map((e: any) => String(e)) : [],
      derivativeAddresses: Array.isArray(object?.derivativeAddresses)
        ? object.derivativeAddresses.map((e: any) => String(e))
        : [],
      spotAddresses: Array.isArray(object?.spotAddresses) ? object.spotAddresses.map((e: any) => String(e)) : [],
      cw20Addresses: Array.isArray(object?.cw20Addresses) ? object.cw20Addresses.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: MitoVaultInfosResponse): unknown {
    const obj: any = {};
    if (message.masterAddresses) {
      obj.masterAddresses = message.masterAddresses.map((e) => e);
    } else {
      obj.masterAddresses = [];
    }
    if (message.derivativeAddresses) {
      obj.derivativeAddresses = message.derivativeAddresses.map((e) => e);
    } else {
      obj.derivativeAddresses = [];
    }
    if (message.spotAddresses) {
      obj.spotAddresses = message.spotAddresses.map((e) => e);
    } else {
      obj.spotAddresses = [];
    }
    if (message.cw20Addresses) {
      obj.cw20Addresses = message.cw20Addresses.map((e) => e);
    } else {
      obj.cw20Addresses = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MitoVaultInfosResponse>): MitoVaultInfosResponse {
    return MitoVaultInfosResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MitoVaultInfosResponse>): MitoVaultInfosResponse {
    const message = createBaseMitoVaultInfosResponse();
    message.masterAddresses = object.masterAddresses?.map((e) => e) || [];
    message.derivativeAddresses = object.derivativeAddresses?.map((e) => e) || [];
    message.spotAddresses = object.spotAddresses?.map((e) => e) || [];
    message.cw20Addresses = object.cw20Addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryMarketIDFromVaultRequest(): QueryMarketIDFromVaultRequest {
  return { vaultSubaccountId: "" };
}

export const QueryMarketIDFromVaultRequest = {
  encode(message: QueryMarketIDFromVaultRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vaultSubaccountId !== "") {
      writer.uint32(10).string(message.vaultSubaccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketIDFromVaultRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketIDFromVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vaultSubaccountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketIDFromVaultRequest {
    return { vaultSubaccountId: isSet(object.vaultSubaccountId) ? String(object.vaultSubaccountId) : "" };
  },

  toJSON(message: QueryMarketIDFromVaultRequest): unknown {
    const obj: any = {};
    message.vaultSubaccountId !== undefined && (obj.vaultSubaccountId = message.vaultSubaccountId);
    return obj;
  },

  create(base?: DeepPartial<QueryMarketIDFromVaultRequest>): QueryMarketIDFromVaultRequest {
    return QueryMarketIDFromVaultRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryMarketIDFromVaultRequest>): QueryMarketIDFromVaultRequest {
    const message = createBaseQueryMarketIDFromVaultRequest();
    message.vaultSubaccountId = object.vaultSubaccountId ?? "";
    return message;
  },
};

function createBaseQueryMarketIDFromVaultResponse(): QueryMarketIDFromVaultResponse {
  return { marketId: "" };
}

export const QueryMarketIDFromVaultResponse = {
  encode(message: QueryMarketIDFromVaultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketIDFromVaultResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketIDFromVaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketIDFromVaultResponse {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryMarketIDFromVaultResponse): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryMarketIDFromVaultResponse>): QueryMarketIDFromVaultResponse {
    return QueryMarketIDFromVaultResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryMarketIDFromVaultResponse>): QueryMarketIDFromVaultResponse {
    const message = createBaseQueryMarketIDFromVaultResponse();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryHistoricalTradeRecordsRequest(): QueryHistoricalTradeRecordsRequest {
  return { marketId: "" };
}

export const QueryHistoricalTradeRecordsRequest = {
  encode(message: QueryHistoricalTradeRecordsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalTradeRecordsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHistoricalTradeRecordsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryHistoricalTradeRecordsRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryHistoricalTradeRecordsRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(base?: DeepPartial<QueryHistoricalTradeRecordsRequest>): QueryHistoricalTradeRecordsRequest {
    return QueryHistoricalTradeRecordsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryHistoricalTradeRecordsRequest>): QueryHistoricalTradeRecordsRequest {
    const message = createBaseQueryHistoricalTradeRecordsRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryHistoricalTradeRecordsResponse(): QueryHistoricalTradeRecordsResponse {
  return { tradeRecords: [] };
}

export const QueryHistoricalTradeRecordsResponse = {
  encode(message: QueryHistoricalTradeRecordsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tradeRecords) {
      TradeRecords.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalTradeRecordsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHistoricalTradeRecordsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tradeRecords.push(TradeRecords.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryHistoricalTradeRecordsResponse {
    return {
      tradeRecords: Array.isArray(object?.tradeRecords)
        ? object.tradeRecords.map((e: any) => TradeRecords.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryHistoricalTradeRecordsResponse): unknown {
    const obj: any = {};
    if (message.tradeRecords) {
      obj.tradeRecords = message.tradeRecords.map((e) => e ? TradeRecords.toJSON(e) : undefined);
    } else {
      obj.tradeRecords = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryHistoricalTradeRecordsResponse>): QueryHistoricalTradeRecordsResponse {
    return QueryHistoricalTradeRecordsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryHistoricalTradeRecordsResponse>): QueryHistoricalTradeRecordsResponse {
    const message = createBaseQueryHistoricalTradeRecordsResponse();
    message.tradeRecords = object.tradeRecords?.map((e) => TradeRecords.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeHistoryOptions(): TradeHistoryOptions {
  return { tradeGroupingSec: "0", maxAge: "0", includeRawHistory: false, includeMetadata: false };
}

export const TradeHistoryOptions = {
  encode(message: TradeHistoryOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tradeGroupingSec !== "0") {
      writer.uint32(8).uint64(message.tradeGroupingSec);
    }
    if (message.maxAge !== "0") {
      writer.uint32(16).uint64(message.maxAge);
    }
    if (message.includeRawHistory === true) {
      writer.uint32(32).bool(message.includeRawHistory);
    }
    if (message.includeMetadata === true) {
      writer.uint32(40).bool(message.includeMetadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeHistoryOptions {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeHistoryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tradeGroupingSec = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.maxAge = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.includeRawHistory = reader.bool();
          break;
        case 5:
          message.includeMetadata = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradeHistoryOptions {
    return {
      tradeGroupingSec: isSet(object.tradeGroupingSec) ? String(object.tradeGroupingSec) : "0",
      maxAge: isSet(object.maxAge) ? String(object.maxAge) : "0",
      includeRawHistory: isSet(object.includeRawHistory) ? Boolean(object.includeRawHistory) : false,
      includeMetadata: isSet(object.includeMetadata) ? Boolean(object.includeMetadata) : false,
    };
  },

  toJSON(message: TradeHistoryOptions): unknown {
    const obj: any = {};
    message.tradeGroupingSec !== undefined && (obj.tradeGroupingSec = message.tradeGroupingSec);
    message.maxAge !== undefined && (obj.maxAge = message.maxAge);
    message.includeRawHistory !== undefined && (obj.includeRawHistory = message.includeRawHistory);
    message.includeMetadata !== undefined && (obj.includeMetadata = message.includeMetadata);
    return obj;
  },

  create(base?: DeepPartial<TradeHistoryOptions>): TradeHistoryOptions {
    return TradeHistoryOptions.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradeHistoryOptions>): TradeHistoryOptions {
    const message = createBaseTradeHistoryOptions();
    message.tradeGroupingSec = object.tradeGroupingSec ?? "0";
    message.maxAge = object.maxAge ?? "0";
    message.includeRawHistory = object.includeRawHistory ?? false;
    message.includeMetadata = object.includeMetadata ?? false;
    return message;
  },
};

function createBaseQueryMarketVolatilityRequest(): QueryMarketVolatilityRequest {
  return { marketId: "", tradeHistoryOptions: undefined };
}

export const QueryMarketVolatilityRequest = {
  encode(message: QueryMarketVolatilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.tradeHistoryOptions !== undefined) {
      TradeHistoryOptions.encode(message.tradeHistoryOptions, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketVolatilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketVolatilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.tradeHistoryOptions = TradeHistoryOptions.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketVolatilityRequest {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      tradeHistoryOptions: isSet(object.tradeHistoryOptions)
        ? TradeHistoryOptions.fromJSON(object.tradeHistoryOptions)
        : undefined,
    };
  },

  toJSON(message: QueryMarketVolatilityRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.tradeHistoryOptions !== undefined && (obj.tradeHistoryOptions = message.tradeHistoryOptions
      ? TradeHistoryOptions.toJSON(message.tradeHistoryOptions)
      : undefined);
    return obj;
  },

  create(base?: DeepPartial<QueryMarketVolatilityRequest>): QueryMarketVolatilityRequest {
    return QueryMarketVolatilityRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryMarketVolatilityRequest>): QueryMarketVolatilityRequest {
    const message = createBaseQueryMarketVolatilityRequest();
    message.marketId = object.marketId ?? "";
    message.tradeHistoryOptions = (object.tradeHistoryOptions !== undefined && object.tradeHistoryOptions !== null)
      ? TradeHistoryOptions.fromPartial(object.tradeHistoryOptions)
      : undefined;
    return message;
  },
};

function createBaseQueryMarketVolatilityResponse(): QueryMarketVolatilityResponse {
  return { volatility: "", historyMetadata: undefined, rawHistory: [] };
}

export const QueryMarketVolatilityResponse = {
  encode(message: QueryMarketVolatilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.volatility !== "") {
      writer.uint32(10).string(message.volatility);
    }
    if (message.historyMetadata !== undefined) {
      MetadataStatistics.encode(message.historyMetadata, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.rawHistory) {
      TradeRecord.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketVolatilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketVolatilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.volatility = reader.string();
          break;
        case 2:
          message.historyMetadata = MetadataStatistics.decode(reader, reader.uint32());
          break;
        case 3:
          message.rawHistory.push(TradeRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketVolatilityResponse {
    return {
      volatility: isSet(object.volatility) ? String(object.volatility) : "",
      historyMetadata: isSet(object.historyMetadata) ? MetadataStatistics.fromJSON(object.historyMetadata) : undefined,
      rawHistory: Array.isArray(object?.rawHistory) ? object.rawHistory.map((e: any) => TradeRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryMarketVolatilityResponse): unknown {
    const obj: any = {};
    message.volatility !== undefined && (obj.volatility = message.volatility);
    message.historyMetadata !== undefined &&
      (obj.historyMetadata = message.historyMetadata ? MetadataStatistics.toJSON(message.historyMetadata) : undefined);
    if (message.rawHistory) {
      obj.rawHistory = message.rawHistory.map((e) => e ? TradeRecord.toJSON(e) : undefined);
    } else {
      obj.rawHistory = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryMarketVolatilityResponse>): QueryMarketVolatilityResponse {
    return QueryMarketVolatilityResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryMarketVolatilityResponse>): QueryMarketVolatilityResponse {
    const message = createBaseQueryMarketVolatilityResponse();
    message.volatility = object.volatility ?? "";
    message.historyMetadata = (object.historyMetadata !== undefined && object.historyMetadata !== null)
      ? MetadataStatistics.fromPartial(object.historyMetadata)
      : undefined;
    message.rawHistory = object.rawHistory?.map((e) => TradeRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBinaryMarketsRequest(): QueryBinaryMarketsRequest {
  return { status: "" };
}

export const QueryBinaryMarketsRequest = {
  encode(message: QueryBinaryMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBinaryMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBinaryMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBinaryMarketsRequest {
    return { status: isSet(object.status) ? String(object.status) : "" };
  },

  toJSON(message: QueryBinaryMarketsRequest): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create(base?: DeepPartial<QueryBinaryMarketsRequest>): QueryBinaryMarketsRequest {
    return QueryBinaryMarketsRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBinaryMarketsRequest>): QueryBinaryMarketsRequest {
    const message = createBaseQueryBinaryMarketsRequest();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseQueryBinaryMarketsResponse(): QueryBinaryMarketsResponse {
  return { markets: [] };
}

export const QueryBinaryMarketsResponse = {
  encode(message: QueryBinaryMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.markets) {
      BinaryOptionsMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBinaryMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBinaryMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.markets.push(BinaryOptionsMarket.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryBinaryMarketsResponse {
    return {
      markets: Array.isArray(object?.markets) ? object.markets.map((e: any) => BinaryOptionsMarket.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryBinaryMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets) {
      obj.markets = message.markets.map((e) => e ? BinaryOptionsMarket.toJSON(e) : undefined);
    } else {
      obj.markets = [];
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBinaryMarketsResponse>): QueryBinaryMarketsResponse {
    return QueryBinaryMarketsResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<QueryBinaryMarketsResponse>): QueryBinaryMarketsResponse {
    const message = createBaseQueryBinaryMarketsResponse();
    message.markets = object.markets?.map((e) => BinaryOptionsMarket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryTraderDerivativeConditionalOrdersRequest(): QueryTraderDerivativeConditionalOrdersRequest {
  return { subaccountId: "", marketId: "" };
}

export const QueryTraderDerivativeConditionalOrdersRequest = {
  encode(message: QueryTraderDerivativeConditionalOrdersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subaccountId !== "") {
      writer.uint32(10).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderDerivativeConditionalOrdersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderDerivativeConditionalOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subaccountId = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderDerivativeConditionalOrdersRequest {
    return {
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
    };
  },

  toJSON(message: QueryTraderDerivativeConditionalOrdersRequest): unknown {
    const obj: any = {};
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(
    base?: DeepPartial<QueryTraderDerivativeConditionalOrdersRequest>,
  ): QueryTraderDerivativeConditionalOrdersRequest {
    return QueryTraderDerivativeConditionalOrdersRequest.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryTraderDerivativeConditionalOrdersRequest>,
  ): QueryTraderDerivativeConditionalOrdersRequest {
    const message = createBaseQueryTraderDerivativeConditionalOrdersRequest();
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseTrimmedDerivativeConditionalOrder(): TrimmedDerivativeConditionalOrder {
  return { price: "", quantity: "", margin: "", triggerPrice: "", isBuy: false, isLimit: false, orderHash: "" };
}

export const TrimmedDerivativeConditionalOrder = {
  encode(message: TrimmedDerivativeConditionalOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.margin !== "") {
      writer.uint32(26).string(message.margin);
    }
    if (message.triggerPrice !== "") {
      writer.uint32(34).string(message.triggerPrice);
    }
    if (message.isBuy === true) {
      writer.uint32(40).bool(message.isBuy);
    }
    if (message.isLimit === true) {
      writer.uint32(48).bool(message.isLimit);
    }
    if (message.orderHash !== "") {
      writer.uint32(58).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrimmedDerivativeConditionalOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrimmedDerivativeConditionalOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.price = reader.string();
          break;
        case 2:
          message.quantity = reader.string();
          break;
        case 3:
          message.margin = reader.string();
          break;
        case 4:
          message.triggerPrice = reader.string();
          break;
        case 5:
          message.isBuy = reader.bool();
          break;
        case 6:
          message.isLimit = reader.bool();
          break;
        case 7:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TrimmedDerivativeConditionalOrder {
    return {
      price: isSet(object.price) ? String(object.price) : "",
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      margin: isSet(object.margin) ? String(object.margin) : "",
      triggerPrice: isSet(object.triggerPrice) ? String(object.triggerPrice) : "",
      isBuy: isSet(object.isBuy) ? Boolean(object.isBuy) : false,
      isLimit: isSet(object.isLimit) ? Boolean(object.isLimit) : false,
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
    };
  },

  toJSON(message: TrimmedDerivativeConditionalOrder): unknown {
    const obj: any = {};
    message.price !== undefined && (obj.price = message.price);
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.margin !== undefined && (obj.margin = message.margin);
    message.triggerPrice !== undefined && (obj.triggerPrice = message.triggerPrice);
    message.isBuy !== undefined && (obj.isBuy = message.isBuy);
    message.isLimit !== undefined && (obj.isLimit = message.isLimit);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<TrimmedDerivativeConditionalOrder>): TrimmedDerivativeConditionalOrder {
    return TrimmedDerivativeConditionalOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TrimmedDerivativeConditionalOrder>): TrimmedDerivativeConditionalOrder {
    const message = createBaseTrimmedDerivativeConditionalOrder();
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.margin = object.margin ?? "";
    message.triggerPrice = object.triggerPrice ?? "";
    message.isBuy = object.isBuy ?? false;
    message.isLimit = object.isLimit ?? false;
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseQueryTraderDerivativeConditionalOrdersResponse(): QueryTraderDerivativeConditionalOrdersResponse {
  return { orders: [] };
}

export const QueryTraderDerivativeConditionalOrdersResponse = {
  encode(
    message: QueryTraderDerivativeConditionalOrdersResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.orders) {
      TrimmedDerivativeConditionalOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryTraderDerivativeConditionalOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraderDerivativeConditionalOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orders.push(TrimmedDerivativeConditionalOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryTraderDerivativeConditionalOrdersResponse {
    return {
      orders: Array.isArray(object?.orders)
        ? object.orders.map((e: any) => TrimmedDerivativeConditionalOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryTraderDerivativeConditionalOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? TrimmedDerivativeConditionalOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryTraderDerivativeConditionalOrdersResponse>,
  ): QueryTraderDerivativeConditionalOrdersResponse {
    return QueryTraderDerivativeConditionalOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryTraderDerivativeConditionalOrdersResponse>,
  ): QueryTraderDerivativeConditionalOrdersResponse {
    const message = createBaseQueryTraderDerivativeConditionalOrdersResponse();
    message.orders = object.orders?.map((e) => TrimmedDerivativeConditionalOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryMarketAtomicExecutionFeeMultiplierRequest(): QueryMarketAtomicExecutionFeeMultiplierRequest {
  return { marketId: "" };
}

export const QueryMarketAtomicExecutionFeeMultiplierRequest = {
  encode(
    message: QueryMarketAtomicExecutionFeeMultiplierRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketAtomicExecutionFeeMultiplierRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketAtomicExecutionFeeMultiplierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketAtomicExecutionFeeMultiplierRequest {
    return { marketId: isSet(object.marketId) ? String(object.marketId) : "" };
  },

  toJSON(message: QueryMarketAtomicExecutionFeeMultiplierRequest): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    return obj;
  },

  create(
    base?: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierRequest>,
  ): QueryMarketAtomicExecutionFeeMultiplierRequest {
    return QueryMarketAtomicExecutionFeeMultiplierRequest.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierRequest>,
  ): QueryMarketAtomicExecutionFeeMultiplierRequest {
    const message = createBaseQueryMarketAtomicExecutionFeeMultiplierRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseQueryMarketAtomicExecutionFeeMultiplierResponse(): QueryMarketAtomicExecutionFeeMultiplierResponse {
  return { multiplier: "" };
}

export const QueryMarketAtomicExecutionFeeMultiplierResponse = {
  encode(
    message: QueryMarketAtomicExecutionFeeMultiplierResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.multiplier !== "") {
      writer.uint32(10).string(message.multiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryMarketAtomicExecutionFeeMultiplierResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarketAtomicExecutionFeeMultiplierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.multiplier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryMarketAtomicExecutionFeeMultiplierResponse {
    return { multiplier: isSet(object.multiplier) ? String(object.multiplier) : "" };
  },

  toJSON(message: QueryMarketAtomicExecutionFeeMultiplierResponse): unknown {
    const obj: any = {};
    message.multiplier !== undefined && (obj.multiplier = message.multiplier);
    return obj;
  },

  create(
    base?: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierResponse>,
  ): QueryMarketAtomicExecutionFeeMultiplierResponse {
    return QueryMarketAtomicExecutionFeeMultiplierResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierResponse>,
  ): QueryMarketAtomicExecutionFeeMultiplierResponse {
    const message = createBaseQueryMarketAtomicExecutionFeeMultiplierResponse();
    message.multiplier = object.multiplier ?? "";
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Retrieves exchange params */
  QueryExchangeParams(
    request: DeepPartial<QueryExchangeParamsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExchangeParamsResponse>;
  /** Retrieves a Subaccount's Deposits */
  SubaccountDeposits(
    request: DeepPartial<QuerySubaccountDepositsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountDepositsResponse>;
  /** Retrieves a Subaccount's Deposits */
  SubaccountDeposit(
    request: DeepPartial<QuerySubaccountDepositRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountDepositResponse>;
  /** Retrieves all of the balances of all users on the exchange. */
  ExchangeBalances(
    request: DeepPartial<QueryExchangeBalancesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExchangeBalancesResponse>;
  /** Retrieves the aggregate volumes for the specified account or subaccount */
  AggregateVolume(
    request: DeepPartial<QueryAggregateVolumeRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateVolumeResponse>;
  /** Retrieves the aggregate volumes for specified accounts */
  AggregateVolumes(
    request: DeepPartial<QueryAggregateVolumesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateVolumesResponse>;
  /** Retrieves the aggregate volume for the specified market */
  AggregateMarketVolume(
    request: DeepPartial<QueryAggregateMarketVolumeRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateMarketVolumeResponse>;
  /** Retrieves the aggregate market volumes for specified markets */
  AggregateMarketVolumes(
    request: DeepPartial<QueryAggregateMarketVolumesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateMarketVolumesResponse>;
  /** Retrieves the denom decimals for a denom. */
  DenomDecimal(
    request: DeepPartial<QueryDenomDecimalRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDenomDecimalResponse>;
  /** Retrieves the denom decimals for multiple denoms. Returns all denom decimals if unspecified. */
  DenomDecimals(
    request: DeepPartial<QueryDenomDecimalsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDenomDecimalsResponse>;
  /** Retrieves a list of spot markets. */
  SpotMarkets(
    request: DeepPartial<QuerySpotMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotMarketsResponse>;
  /** Retrieves a spot market by ticker */
  SpotMarket(request: DeepPartial<QuerySpotMarketRequest>, metadata?: grpc.Metadata): Promise<QuerySpotMarketResponse>;
  /** Retrieves a spot market's orderbook by marketID */
  SpotOrderbook(
    request: DeepPartial<QuerySpotOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotOrderbookResponse>;
  /** Retrieves a trader's spot orders */
  TraderSpotOrders(
    request: DeepPartial<QueryTraderSpotOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderSpotOrdersResponse>;
  /** Retrieves spot orders corresponding to specified order hashes for a given subaccountID and marketID */
  SpotOrdersByHashes(
    request: DeepPartial<QuerySpotOrdersByHashesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotOrdersByHashesResponse>;
  /** Retrieves subaccount's orders */
  SubaccountOrders(
    request: DeepPartial<QuerySubaccountOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountOrdersResponse>;
  /** Retrieves a trader's transient spot orders */
  TraderSpotTransientOrders(
    request: DeepPartial<QueryTraderSpotOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderSpotOrdersResponse>;
  /** Retrieves a spot market's mid-price */
  SpotMidPriceAndTOB(
    request: DeepPartial<QuerySpotMidPriceAndTOBRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotMidPriceAndTOBResponse>;
  /** Retrieves a derivative market's mid-price */
  DerivativeMidPriceAndTOB(
    request: DeepPartial<QueryDerivativeMidPriceAndTOBRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMidPriceAndTOBResponse>;
  /** Retrieves a derivative market's orderbook by marketID */
  DerivativeOrderbook(
    request: DeepPartial<QueryDerivativeOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeOrderbookResponse>;
  /** Retrieves a trader's derivative orders */
  TraderDerivativeOrders(
    request: DeepPartial<QueryTraderDerivativeOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeOrdersResponse>;
  /** Retrieves a trader's derivative orders */
  DerivativeOrdersByHashes(
    request: DeepPartial<QueryDerivativeOrdersByHashesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeOrdersByHashesResponse>;
  /** Retrieves a trader's transient derivative orders */
  TraderDerivativeTransientOrders(
    request: DeepPartial<QueryTraderDerivativeOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeOrdersResponse>;
  /** Retrieves a list of derivative markets. */
  DerivativeMarkets(
    request: DeepPartial<QueryDerivativeMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketsResponse>;
  /** Retrieves a derivative market by ticker */
  DerivativeMarket(
    request: DeepPartial<QueryDerivativeMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketResponse>;
  /** Retrieves a derivative market's corresponding address for fees that contribute to the market's insurance fund */
  DerivativeMarketAddress(
    request: DeepPartial<QueryDerivativeMarketAddressRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketAddressResponse>;
  /** Retrieves a subaccount's trade nonce */
  SubaccountTradeNonce(
    request: DeepPartial<QuerySubaccountTradeNonceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountTradeNonceResponse>;
  /** Retrieves the entire exchange module's state */
  ExchangeModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse>;
  /** Retrieves the entire exchange module's positions */
  Positions(request: DeepPartial<QueryPositionsRequest>, metadata?: grpc.Metadata): Promise<QueryPositionsResponse>;
  /** Retrieves subaccount's positions */
  SubaccountPositions(
    request: DeepPartial<QuerySubaccountPositionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountPositionsResponse>;
  /** Retrieves subaccount's position in market */
  SubaccountPositionInMarket(
    request: DeepPartial<QuerySubaccountPositionInMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountPositionInMarketResponse>;
  /** Retrieves subaccount's position in market */
  SubaccountEffectivePositionInMarket(
    request: DeepPartial<QuerySubaccountEffectivePositionInMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountEffectivePositionInMarketResponse>;
  /** Retrieves perpetual market info */
  PerpetualMarketInfo(
    request: DeepPartial<QueryPerpetualMarketInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPerpetualMarketInfoResponse>;
  /** Retrieves expiry market info */
  ExpiryFuturesMarketInfo(
    request: DeepPartial<QueryExpiryFuturesMarketInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExpiryFuturesMarketInfoResponse>;
  /** Retrieves perpetual market funding */
  PerpetualMarketFunding(
    request: DeepPartial<QueryPerpetualMarketFundingRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPerpetualMarketFundingResponse>;
  /** Retrieves subaccount's order metadata */
  SubaccountOrderMetadata(
    request: DeepPartial<QuerySubaccountOrderMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountOrderMetadataResponse>;
  /** Retrieves the account and total trade rewards points */
  TradeRewardPoints(
    request: DeepPartial<QueryTradeRewardPointsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardPointsResponse>;
  /** Retrieves the pending account and total trade rewards points */
  PendingTradeRewardPoints(
    request: DeepPartial<QueryTradeRewardPointsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardPointsResponse>;
  /** Retrieves the trade reward campaign */
  TradeRewardCampaign(
    request: DeepPartial<QueryTradeRewardCampaignRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardCampaignResponse>;
  /** Retrieves the account's fee discount info */
  FeeDiscountAccountInfo(
    request: DeepPartial<QueryFeeDiscountAccountInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountAccountInfoResponse>;
  /** Retrieves the fee discount schedule */
  FeeDiscountSchedule(
    request: DeepPartial<QueryFeeDiscountScheduleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountScheduleResponse>;
  /** Retrieves mismatches between available vs. total balance */
  BalanceMismatches(
    request: DeepPartial<QueryBalanceMismatchesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBalanceMismatchesResponse>;
  /** Retrieves available and total balances with balance holds */
  BalanceWithBalanceHolds(
    request: DeepPartial<QueryBalanceWithBalanceHoldsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBalanceWithBalanceHoldsResponse>;
  /** Retrieves fee discount tier stats */
  FeeDiscountTierStatistics(
    request: DeepPartial<QueryFeeDiscountTierStatisticsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountTierStatisticsResponse>;
  /** Retrieves market making pool info */
  MitoVaultInfos(
    request: DeepPartial<MitoVaultInfosRequest>,
    metadata?: grpc.Metadata,
  ): Promise<MitoVaultInfosResponse>;
  /** QueryMarketIDFromVault returns the market ID for a given vault subaccount ID */
  QueryMarketIDFromVault(
    request: DeepPartial<QueryMarketIDFromVaultRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketIDFromVaultResponse>;
  /** Retrieves historical trade records for a given market ID */
  HistoricalTradeRecords(
    request: DeepPartial<QueryHistoricalTradeRecordsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryHistoricalTradeRecordsResponse>;
  /** Retrieves if the account is opted out of rewards */
  IsOptedOutOfRewards(
    request: DeepPartial<QueryIsOptedOutOfRewardsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryIsOptedOutOfRewardsResponse>;
  /** Retrieves all accounts opted out of rewards */
  OptedOutOfRewardsAccounts(
    request: DeepPartial<QueryOptedOutOfRewardsAccountsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOptedOutOfRewardsAccountsResponse>;
  /** MarketVolatility computes the volatility for spot and derivative markets trading history. */
  MarketVolatility(
    request: DeepPartial<QueryMarketVolatilityRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketVolatilityResponse>;
  /** Retrieves a spot market's orderbook by marketID */
  BinaryOptionsMarkets(
    request: DeepPartial<QueryBinaryMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBinaryMarketsResponse>;
  /** Retrieves a trader's derivative conditional orders */
  TraderDerivativeConditionalOrders(
    request: DeepPartial<QueryTraderDerivativeConditionalOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeConditionalOrdersResponse>;
  MarketAtomicExecutionFeeMultiplier(
    request: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketAtomicExecutionFeeMultiplierResponse>;
}

export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.QueryExchangeParams = this.QueryExchangeParams.bind(this);
    this.SubaccountDeposits = this.SubaccountDeposits.bind(this);
    this.SubaccountDeposit = this.SubaccountDeposit.bind(this);
    this.ExchangeBalances = this.ExchangeBalances.bind(this);
    this.AggregateVolume = this.AggregateVolume.bind(this);
    this.AggregateVolumes = this.AggregateVolumes.bind(this);
    this.AggregateMarketVolume = this.AggregateMarketVolume.bind(this);
    this.AggregateMarketVolumes = this.AggregateMarketVolumes.bind(this);
    this.DenomDecimal = this.DenomDecimal.bind(this);
    this.DenomDecimals = this.DenomDecimals.bind(this);
    this.SpotMarkets = this.SpotMarkets.bind(this);
    this.SpotMarket = this.SpotMarket.bind(this);
    this.SpotOrderbook = this.SpotOrderbook.bind(this);
    this.TraderSpotOrders = this.TraderSpotOrders.bind(this);
    this.SpotOrdersByHashes = this.SpotOrdersByHashes.bind(this);
    this.SubaccountOrders = this.SubaccountOrders.bind(this);
    this.TraderSpotTransientOrders = this.TraderSpotTransientOrders.bind(this);
    this.SpotMidPriceAndTOB = this.SpotMidPriceAndTOB.bind(this);
    this.DerivativeMidPriceAndTOB = this.DerivativeMidPriceAndTOB.bind(this);
    this.DerivativeOrderbook = this.DerivativeOrderbook.bind(this);
    this.TraderDerivativeOrders = this.TraderDerivativeOrders.bind(this);
    this.DerivativeOrdersByHashes = this.DerivativeOrdersByHashes.bind(this);
    this.TraderDerivativeTransientOrders = this.TraderDerivativeTransientOrders.bind(this);
    this.DerivativeMarkets = this.DerivativeMarkets.bind(this);
    this.DerivativeMarket = this.DerivativeMarket.bind(this);
    this.DerivativeMarketAddress = this.DerivativeMarketAddress.bind(this);
    this.SubaccountTradeNonce = this.SubaccountTradeNonce.bind(this);
    this.ExchangeModuleState = this.ExchangeModuleState.bind(this);
    this.Positions = this.Positions.bind(this);
    this.SubaccountPositions = this.SubaccountPositions.bind(this);
    this.SubaccountPositionInMarket = this.SubaccountPositionInMarket.bind(this);
    this.SubaccountEffectivePositionInMarket = this.SubaccountEffectivePositionInMarket.bind(this);
    this.PerpetualMarketInfo = this.PerpetualMarketInfo.bind(this);
    this.ExpiryFuturesMarketInfo = this.ExpiryFuturesMarketInfo.bind(this);
    this.PerpetualMarketFunding = this.PerpetualMarketFunding.bind(this);
    this.SubaccountOrderMetadata = this.SubaccountOrderMetadata.bind(this);
    this.TradeRewardPoints = this.TradeRewardPoints.bind(this);
    this.PendingTradeRewardPoints = this.PendingTradeRewardPoints.bind(this);
    this.TradeRewardCampaign = this.TradeRewardCampaign.bind(this);
    this.FeeDiscountAccountInfo = this.FeeDiscountAccountInfo.bind(this);
    this.FeeDiscountSchedule = this.FeeDiscountSchedule.bind(this);
    this.BalanceMismatches = this.BalanceMismatches.bind(this);
    this.BalanceWithBalanceHolds = this.BalanceWithBalanceHolds.bind(this);
    this.FeeDiscountTierStatistics = this.FeeDiscountTierStatistics.bind(this);
    this.MitoVaultInfos = this.MitoVaultInfos.bind(this);
    this.QueryMarketIDFromVault = this.QueryMarketIDFromVault.bind(this);
    this.HistoricalTradeRecords = this.HistoricalTradeRecords.bind(this);
    this.IsOptedOutOfRewards = this.IsOptedOutOfRewards.bind(this);
    this.OptedOutOfRewardsAccounts = this.OptedOutOfRewardsAccounts.bind(this);
    this.MarketVolatility = this.MarketVolatility.bind(this);
    this.BinaryOptionsMarkets = this.BinaryOptionsMarkets.bind(this);
    this.TraderDerivativeConditionalOrders = this.TraderDerivativeConditionalOrders.bind(this);
    this.MarketAtomicExecutionFeeMultiplier = this.MarketAtomicExecutionFeeMultiplier.bind(this);
  }

  QueryExchangeParams(
    request: DeepPartial<QueryExchangeParamsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExchangeParamsResponse> {
    return this.rpc.unary(QueryQueryExchangeParamsDesc, QueryExchangeParamsRequest.fromPartial(request), metadata);
  }

  SubaccountDeposits(
    request: DeepPartial<QuerySubaccountDepositsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountDepositsResponse> {
    return this.rpc.unary(QuerySubaccountDepositsDesc, QuerySubaccountDepositsRequest.fromPartial(request), metadata);
  }

  SubaccountDeposit(
    request: DeepPartial<QuerySubaccountDepositRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountDepositResponse> {
    return this.rpc.unary(QuerySubaccountDepositDesc, QuerySubaccountDepositRequest.fromPartial(request), metadata);
  }

  ExchangeBalances(
    request: DeepPartial<QueryExchangeBalancesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExchangeBalancesResponse> {
    return this.rpc.unary(QueryExchangeBalancesDesc, QueryExchangeBalancesRequest.fromPartial(request), metadata);
  }

  AggregateVolume(
    request: DeepPartial<QueryAggregateVolumeRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateVolumeResponse> {
    return this.rpc.unary(QueryAggregateVolumeDesc, QueryAggregateVolumeRequest.fromPartial(request), metadata);
  }

  AggregateVolumes(
    request: DeepPartial<QueryAggregateVolumesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateVolumesResponse> {
    return this.rpc.unary(QueryAggregateVolumesDesc, QueryAggregateVolumesRequest.fromPartial(request), metadata);
  }

  AggregateMarketVolume(
    request: DeepPartial<QueryAggregateMarketVolumeRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateMarketVolumeResponse> {
    return this.rpc.unary(
      QueryAggregateMarketVolumeDesc,
      QueryAggregateMarketVolumeRequest.fromPartial(request),
      metadata,
    );
  }

  AggregateMarketVolumes(
    request: DeepPartial<QueryAggregateMarketVolumesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryAggregateMarketVolumesResponse> {
    return this.rpc.unary(
      QueryAggregateMarketVolumesDesc,
      QueryAggregateMarketVolumesRequest.fromPartial(request),
      metadata,
    );
  }

  DenomDecimal(
    request: DeepPartial<QueryDenomDecimalRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDenomDecimalResponse> {
    return this.rpc.unary(QueryDenomDecimalDesc, QueryDenomDecimalRequest.fromPartial(request), metadata);
  }

  DenomDecimals(
    request: DeepPartial<QueryDenomDecimalsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDenomDecimalsResponse> {
    return this.rpc.unary(QueryDenomDecimalsDesc, QueryDenomDecimalsRequest.fromPartial(request), metadata);
  }

  SpotMarkets(
    request: DeepPartial<QuerySpotMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotMarketsResponse> {
    return this.rpc.unary(QuerySpotMarketsDesc, QuerySpotMarketsRequest.fromPartial(request), metadata);
  }

  SpotMarket(request: DeepPartial<QuerySpotMarketRequest>, metadata?: grpc.Metadata): Promise<QuerySpotMarketResponse> {
    return this.rpc.unary(QuerySpotMarketDesc, QuerySpotMarketRequest.fromPartial(request), metadata);
  }

  SpotOrderbook(
    request: DeepPartial<QuerySpotOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotOrderbookResponse> {
    return this.rpc.unary(QuerySpotOrderbookDesc, QuerySpotOrderbookRequest.fromPartial(request), metadata);
  }

  TraderSpotOrders(
    request: DeepPartial<QueryTraderSpotOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderSpotOrdersResponse> {
    return this.rpc.unary(QueryTraderSpotOrdersDesc, QueryTraderSpotOrdersRequest.fromPartial(request), metadata);
  }

  SpotOrdersByHashes(
    request: DeepPartial<QuerySpotOrdersByHashesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotOrdersByHashesResponse> {
    return this.rpc.unary(QuerySpotOrdersByHashesDesc, QuerySpotOrdersByHashesRequest.fromPartial(request), metadata);
  }

  SubaccountOrders(
    request: DeepPartial<QuerySubaccountOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountOrdersResponse> {
    return this.rpc.unary(QuerySubaccountOrdersDesc, QuerySubaccountOrdersRequest.fromPartial(request), metadata);
  }

  TraderSpotTransientOrders(
    request: DeepPartial<QueryTraderSpotOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderSpotOrdersResponse> {
    return this.rpc.unary(
      QueryTraderSpotTransientOrdersDesc,
      QueryTraderSpotOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  SpotMidPriceAndTOB(
    request: DeepPartial<QuerySpotMidPriceAndTOBRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySpotMidPriceAndTOBResponse> {
    return this.rpc.unary(QuerySpotMidPriceAndTOBDesc, QuerySpotMidPriceAndTOBRequest.fromPartial(request), metadata);
  }

  DerivativeMidPriceAndTOB(
    request: DeepPartial<QueryDerivativeMidPriceAndTOBRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMidPriceAndTOBResponse> {
    return this.rpc.unary(
      QueryDerivativeMidPriceAndTOBDesc,
      QueryDerivativeMidPriceAndTOBRequest.fromPartial(request),
      metadata,
    );
  }

  DerivativeOrderbook(
    request: DeepPartial<QueryDerivativeOrderbookRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeOrderbookResponse> {
    return this.rpc.unary(QueryDerivativeOrderbookDesc, QueryDerivativeOrderbookRequest.fromPartial(request), metadata);
  }

  TraderDerivativeOrders(
    request: DeepPartial<QueryTraderDerivativeOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeOrdersResponse> {
    return this.rpc.unary(
      QueryTraderDerivativeOrdersDesc,
      QueryTraderDerivativeOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  DerivativeOrdersByHashes(
    request: DeepPartial<QueryDerivativeOrdersByHashesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeOrdersByHashesResponse> {
    return this.rpc.unary(
      QueryDerivativeOrdersByHashesDesc,
      QueryDerivativeOrdersByHashesRequest.fromPartial(request),
      metadata,
    );
  }

  TraderDerivativeTransientOrders(
    request: DeepPartial<QueryTraderDerivativeOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeOrdersResponse> {
    return this.rpc.unary(
      QueryTraderDerivativeTransientOrdersDesc,
      QueryTraderDerivativeOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  DerivativeMarkets(
    request: DeepPartial<QueryDerivativeMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketsResponse> {
    return this.rpc.unary(QueryDerivativeMarketsDesc, QueryDerivativeMarketsRequest.fromPartial(request), metadata);
  }

  DerivativeMarket(
    request: DeepPartial<QueryDerivativeMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketResponse> {
    return this.rpc.unary(QueryDerivativeMarketDesc, QueryDerivativeMarketRequest.fromPartial(request), metadata);
  }

  DerivativeMarketAddress(
    request: DeepPartial<QueryDerivativeMarketAddressRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryDerivativeMarketAddressResponse> {
    return this.rpc.unary(
      QueryDerivativeMarketAddressDesc,
      QueryDerivativeMarketAddressRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountTradeNonce(
    request: DeepPartial<QuerySubaccountTradeNonceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountTradeNonceResponse> {
    return this.rpc.unary(
      QuerySubaccountTradeNonceDesc,
      QuerySubaccountTradeNonceRequest.fromPartial(request),
      metadata,
    );
  }

  ExchangeModuleState(
    request: DeepPartial<QueryModuleStateRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryModuleStateResponse> {
    return this.rpc.unary(QueryExchangeModuleStateDesc, QueryModuleStateRequest.fromPartial(request), metadata);
  }

  Positions(request: DeepPartial<QueryPositionsRequest>, metadata?: grpc.Metadata): Promise<QueryPositionsResponse> {
    return this.rpc.unary(QueryPositionsDesc, QueryPositionsRequest.fromPartial(request), metadata);
  }

  SubaccountPositions(
    request: DeepPartial<QuerySubaccountPositionsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountPositionsResponse> {
    return this.rpc.unary(QuerySubaccountPositionsDesc, QuerySubaccountPositionsRequest.fromPartial(request), metadata);
  }

  SubaccountPositionInMarket(
    request: DeepPartial<QuerySubaccountPositionInMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountPositionInMarketResponse> {
    return this.rpc.unary(
      QuerySubaccountPositionInMarketDesc,
      QuerySubaccountPositionInMarketRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountEffectivePositionInMarket(
    request: DeepPartial<QuerySubaccountEffectivePositionInMarketRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountEffectivePositionInMarketResponse> {
    return this.rpc.unary(
      QuerySubaccountEffectivePositionInMarketDesc,
      QuerySubaccountEffectivePositionInMarketRequest.fromPartial(request),
      metadata,
    );
  }

  PerpetualMarketInfo(
    request: DeepPartial<QueryPerpetualMarketInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPerpetualMarketInfoResponse> {
    return this.rpc.unary(QueryPerpetualMarketInfoDesc, QueryPerpetualMarketInfoRequest.fromPartial(request), metadata);
  }

  ExpiryFuturesMarketInfo(
    request: DeepPartial<QueryExpiryFuturesMarketInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryExpiryFuturesMarketInfoResponse> {
    return this.rpc.unary(
      QueryExpiryFuturesMarketInfoDesc,
      QueryExpiryFuturesMarketInfoRequest.fromPartial(request),
      metadata,
    );
  }

  PerpetualMarketFunding(
    request: DeepPartial<QueryPerpetualMarketFundingRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryPerpetualMarketFundingResponse> {
    return this.rpc.unary(
      QueryPerpetualMarketFundingDesc,
      QueryPerpetualMarketFundingRequest.fromPartial(request),
      metadata,
    );
  }

  SubaccountOrderMetadata(
    request: DeepPartial<QuerySubaccountOrderMetadataRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuerySubaccountOrderMetadataResponse> {
    return this.rpc.unary(
      QuerySubaccountOrderMetadataDesc,
      QuerySubaccountOrderMetadataRequest.fromPartial(request),
      metadata,
    );
  }

  TradeRewardPoints(
    request: DeepPartial<QueryTradeRewardPointsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardPointsResponse> {
    return this.rpc.unary(QueryTradeRewardPointsDesc, QueryTradeRewardPointsRequest.fromPartial(request), metadata);
  }

  PendingTradeRewardPoints(
    request: DeepPartial<QueryTradeRewardPointsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardPointsResponse> {
    return this.rpc.unary(
      QueryPendingTradeRewardPointsDesc,
      QueryTradeRewardPointsRequest.fromPartial(request),
      metadata,
    );
  }

  TradeRewardCampaign(
    request: DeepPartial<QueryTradeRewardCampaignRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTradeRewardCampaignResponse> {
    return this.rpc.unary(QueryTradeRewardCampaignDesc, QueryTradeRewardCampaignRequest.fromPartial(request), metadata);
  }

  FeeDiscountAccountInfo(
    request: DeepPartial<QueryFeeDiscountAccountInfoRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountAccountInfoResponse> {
    return this.rpc.unary(
      QueryFeeDiscountAccountInfoDesc,
      QueryFeeDiscountAccountInfoRequest.fromPartial(request),
      metadata,
    );
  }

  FeeDiscountSchedule(
    request: DeepPartial<QueryFeeDiscountScheduleRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountScheduleResponse> {
    return this.rpc.unary(QueryFeeDiscountScheduleDesc, QueryFeeDiscountScheduleRequest.fromPartial(request), metadata);
  }

  BalanceMismatches(
    request: DeepPartial<QueryBalanceMismatchesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBalanceMismatchesResponse> {
    return this.rpc.unary(QueryBalanceMismatchesDesc, QueryBalanceMismatchesRequest.fromPartial(request), metadata);
  }

  BalanceWithBalanceHolds(
    request: DeepPartial<QueryBalanceWithBalanceHoldsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBalanceWithBalanceHoldsResponse> {
    return this.rpc.unary(
      QueryBalanceWithBalanceHoldsDesc,
      QueryBalanceWithBalanceHoldsRequest.fromPartial(request),
      metadata,
    );
  }

  FeeDiscountTierStatistics(
    request: DeepPartial<QueryFeeDiscountTierStatisticsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryFeeDiscountTierStatisticsResponse> {
    return this.rpc.unary(
      QueryFeeDiscountTierStatisticsDesc,
      QueryFeeDiscountTierStatisticsRequest.fromPartial(request),
      metadata,
    );
  }

  MitoVaultInfos(
    request: DeepPartial<MitoVaultInfosRequest>,
    metadata?: grpc.Metadata,
  ): Promise<MitoVaultInfosResponse> {
    return this.rpc.unary(QueryMitoVaultInfosDesc, MitoVaultInfosRequest.fromPartial(request), metadata);
  }

  QueryMarketIDFromVault(
    request: DeepPartial<QueryMarketIDFromVaultRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketIDFromVaultResponse> {
    return this.rpc.unary(
      QueryQueryMarketIDFromVaultDesc,
      QueryMarketIDFromVaultRequest.fromPartial(request),
      metadata,
    );
  }

  HistoricalTradeRecords(
    request: DeepPartial<QueryHistoricalTradeRecordsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryHistoricalTradeRecordsResponse> {
    return this.rpc.unary(
      QueryHistoricalTradeRecordsDesc,
      QueryHistoricalTradeRecordsRequest.fromPartial(request),
      metadata,
    );
  }

  IsOptedOutOfRewards(
    request: DeepPartial<QueryIsOptedOutOfRewardsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryIsOptedOutOfRewardsResponse> {
    return this.rpc.unary(QueryIsOptedOutOfRewardsDesc, QueryIsOptedOutOfRewardsRequest.fromPartial(request), metadata);
  }

  OptedOutOfRewardsAccounts(
    request: DeepPartial<QueryOptedOutOfRewardsAccountsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryOptedOutOfRewardsAccountsResponse> {
    return this.rpc.unary(
      QueryOptedOutOfRewardsAccountsDesc,
      QueryOptedOutOfRewardsAccountsRequest.fromPartial(request),
      metadata,
    );
  }

  MarketVolatility(
    request: DeepPartial<QueryMarketVolatilityRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketVolatilityResponse> {
    return this.rpc.unary(QueryMarketVolatilityDesc, QueryMarketVolatilityRequest.fromPartial(request), metadata);
  }

  BinaryOptionsMarkets(
    request: DeepPartial<QueryBinaryMarketsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryBinaryMarketsResponse> {
    return this.rpc.unary(QueryBinaryOptionsMarketsDesc, QueryBinaryMarketsRequest.fromPartial(request), metadata);
  }

  TraderDerivativeConditionalOrders(
    request: DeepPartial<QueryTraderDerivativeConditionalOrdersRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryTraderDerivativeConditionalOrdersResponse> {
    return this.rpc.unary(
      QueryTraderDerivativeConditionalOrdersDesc,
      QueryTraderDerivativeConditionalOrdersRequest.fromPartial(request),
      metadata,
    );
  }

  MarketAtomicExecutionFeeMultiplier(
    request: DeepPartial<QueryMarketAtomicExecutionFeeMultiplierRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QueryMarketAtomicExecutionFeeMultiplierResponse> {
    return this.rpc.unary(
      QueryMarketAtomicExecutionFeeMultiplierDesc,
      QueryMarketAtomicExecutionFeeMultiplierRequest.fromPartial(request),
      metadata,
    );
  }
}

export const QueryDesc = { serviceName: "injective.exchange.v1beta1.Query" };

export const QueryQueryExchangeParamsDesc: UnaryMethodDefinitionish = {
  methodName: "QueryExchangeParams",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryExchangeParamsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryExchangeParamsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountDepositsDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountDeposits",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountDepositsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountDepositsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountDepositDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountDeposit",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountDepositRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountDepositResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryExchangeBalancesDesc: UnaryMethodDefinitionish = {
  methodName: "ExchangeBalances",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryExchangeBalancesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryExchangeBalancesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryAggregateVolumeDesc: UnaryMethodDefinitionish = {
  methodName: "AggregateVolume",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAggregateVolumeRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryAggregateVolumeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryAggregateVolumesDesc: UnaryMethodDefinitionish = {
  methodName: "AggregateVolumes",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAggregateVolumesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryAggregateVolumesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryAggregateMarketVolumeDesc: UnaryMethodDefinitionish = {
  methodName: "AggregateMarketVolume",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAggregateMarketVolumeRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryAggregateMarketVolumeResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryAggregateMarketVolumesDesc: UnaryMethodDefinitionish = {
  methodName: "AggregateMarketVolumes",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAggregateMarketVolumesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryAggregateMarketVolumesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDenomDecimalDesc: UnaryMethodDefinitionish = {
  methodName: "DenomDecimal",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDenomDecimalRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDenomDecimalResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDenomDecimalsDesc: UnaryMethodDefinitionish = {
  methodName: "DenomDecimals",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDenomDecimalsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDenomDecimalsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySpotMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "SpotMarkets",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySpotMarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySpotMarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySpotMarketDesc: UnaryMethodDefinitionish = {
  methodName: "SpotMarket",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySpotMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySpotMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySpotOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "SpotOrderbook",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySpotOrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySpotOrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTraderSpotOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "TraderSpotOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTraderSpotOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTraderSpotOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySpotOrdersByHashesDesc: UnaryMethodDefinitionish = {
  methodName: "SpotOrdersByHashes",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySpotOrdersByHashesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySpotOrdersByHashesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTraderSpotTransientOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "TraderSpotTransientOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTraderSpotOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTraderSpotOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySpotMidPriceAndTOBDesc: UnaryMethodDefinitionish = {
  methodName: "SpotMidPriceAndTOB",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySpotMidPriceAndTOBRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySpotMidPriceAndTOBResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeMidPriceAndTOBDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeMidPriceAndTOB",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeMidPriceAndTOBRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeMidPriceAndTOBResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeOrderbookDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeOrderbook",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeOrderbookRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeOrderbookResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTraderDerivativeOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "TraderDerivativeOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTraderDerivativeOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTraderDerivativeOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeOrdersByHashesDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeOrdersByHashes",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeOrdersByHashesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeOrdersByHashesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTraderDerivativeTransientOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "TraderDerivativeTransientOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTraderDerivativeOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTraderDerivativeOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeMarkets",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeMarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeMarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeMarketDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeMarket",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryDerivativeMarketAddressDesc: UnaryMethodDefinitionish = {
  methodName: "DerivativeMarketAddress",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDerivativeMarketAddressRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryDerivativeMarketAddressResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountTradeNonceDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountTradeNonce",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountTradeNonceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountTradeNonceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryExchangeModuleStateDesc: UnaryMethodDefinitionish = {
  methodName: "ExchangeModuleState",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryModuleStateRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryModuleStateResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPositionsDesc: UnaryMethodDefinitionish = {
  methodName: "Positions",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPositionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPositionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountPositionsDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountPositions",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountPositionsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountPositionsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountPositionInMarketDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountPositionInMarket",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountPositionInMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountPositionInMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountEffectivePositionInMarketDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountEffectivePositionInMarket",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountEffectivePositionInMarketRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountEffectivePositionInMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPerpetualMarketInfoDesc: UnaryMethodDefinitionish = {
  methodName: "PerpetualMarketInfo",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPerpetualMarketInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPerpetualMarketInfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryExpiryFuturesMarketInfoDesc: UnaryMethodDefinitionish = {
  methodName: "ExpiryFuturesMarketInfo",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryExpiryFuturesMarketInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryExpiryFuturesMarketInfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPerpetualMarketFundingDesc: UnaryMethodDefinitionish = {
  methodName: "PerpetualMarketFunding",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryPerpetualMarketFundingRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryPerpetualMarketFundingResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QuerySubaccountOrderMetadataDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountOrderMetadata",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySubaccountOrderMetadataRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuerySubaccountOrderMetadataResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTradeRewardPointsDesc: UnaryMethodDefinitionish = {
  methodName: "TradeRewardPoints",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTradeRewardPointsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTradeRewardPointsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryPendingTradeRewardPointsDesc: UnaryMethodDefinitionish = {
  methodName: "PendingTradeRewardPoints",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTradeRewardPointsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTradeRewardPointsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTradeRewardCampaignDesc: UnaryMethodDefinitionish = {
  methodName: "TradeRewardCampaign",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTradeRewardCampaignRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTradeRewardCampaignResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryFeeDiscountAccountInfoDesc: UnaryMethodDefinitionish = {
  methodName: "FeeDiscountAccountInfo",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryFeeDiscountAccountInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryFeeDiscountAccountInfoResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryFeeDiscountScheduleDesc: UnaryMethodDefinitionish = {
  methodName: "FeeDiscountSchedule",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryFeeDiscountScheduleRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryFeeDiscountScheduleResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBalanceMismatchesDesc: UnaryMethodDefinitionish = {
  methodName: "BalanceMismatches",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBalanceMismatchesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBalanceMismatchesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBalanceWithBalanceHoldsDesc: UnaryMethodDefinitionish = {
  methodName: "BalanceWithBalanceHolds",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBalanceWithBalanceHoldsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBalanceWithBalanceHoldsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryFeeDiscountTierStatisticsDesc: UnaryMethodDefinitionish = {
  methodName: "FeeDiscountTierStatistics",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryFeeDiscountTierStatisticsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryFeeDiscountTierStatisticsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryMitoVaultInfosDesc: UnaryMethodDefinitionish = {
  methodName: "MitoVaultInfos",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MitoVaultInfosRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MitoVaultInfosResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryQueryMarketIDFromVaultDesc: UnaryMethodDefinitionish = {
  methodName: "QueryMarketIDFromVault",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryMarketIDFromVaultRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryMarketIDFromVaultResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryHistoricalTradeRecordsDesc: UnaryMethodDefinitionish = {
  methodName: "HistoricalTradeRecords",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryHistoricalTradeRecordsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryHistoricalTradeRecordsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryIsOptedOutOfRewardsDesc: UnaryMethodDefinitionish = {
  methodName: "IsOptedOutOfRewards",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryIsOptedOutOfRewardsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryIsOptedOutOfRewardsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryOptedOutOfRewardsAccountsDesc: UnaryMethodDefinitionish = {
  methodName: "OptedOutOfRewardsAccounts",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryOptedOutOfRewardsAccountsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryOptedOutOfRewardsAccountsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryMarketVolatilityDesc: UnaryMethodDefinitionish = {
  methodName: "MarketVolatility",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryMarketVolatilityRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryMarketVolatilityResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryBinaryOptionsMarketsDesc: UnaryMethodDefinitionish = {
  methodName: "BinaryOptionsMarkets",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBinaryMarketsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryBinaryMarketsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryTraderDerivativeConditionalOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "TraderDerivativeConditionalOrders",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTraderDerivativeConditionalOrdersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryTraderDerivativeConditionalOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const QueryMarketAtomicExecutionFeeMultiplierDesc: UnaryMethodDefinitionish = {
  methodName: "MarketAtomicExecutionFeeMultiplier",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryMarketAtomicExecutionFeeMultiplierRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QueryMarketAtomicExecutionFeeMultiplierResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
