/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { CommunityPoolSpendProposal } from "../../../cosmos/distribution/v1beta1/distribution";
import { OracleType, oracleTypeFromJSON, oracleTypeToJSON } from "../../oracle/v1beta1/oracle";
import {
  CampaignRewardPool,
  DenomDecimals,
  DerivativeOrder,
  FeeDiscountSchedule,
  MarketFeeMultiplier,
  MarketStatus,
  marketStatusFromJSON,
  marketStatusToJSON,
  PositionDelta,
  SpotOrder,
  TradingRewardCampaignInfo,
} from "./exchange";

export enum ExchangeType {
  EXCHANGE_UNSPECIFIED = 0,
  SPOT = 1,
  DERIVATIVES = 2,
  UNRECOGNIZED = -1,
}

export function exchangeTypeFromJSON(object: any): ExchangeType {
  switch (object) {
    case 0:
    case "EXCHANGE_UNSPECIFIED":
      return ExchangeType.EXCHANGE_UNSPECIFIED;
    case 1:
    case "SPOT":
      return ExchangeType.SPOT;
    case 2:
    case "DERIVATIVES":
      return ExchangeType.DERIVATIVES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExchangeType.UNRECOGNIZED;
  }
}

export function exchangeTypeToJSON(object: ExchangeType): string {
  switch (object) {
    case ExchangeType.EXCHANGE_UNSPECIFIED:
      return "EXCHANGE_UNSPECIFIED";
    case ExchangeType.SPOT:
      return "SPOT";
    case ExchangeType.DERIVATIVES:
      return "DERIVATIVES";
    case ExchangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MsgDeposit defines a SDK message for transferring coins from the sender's bank balance into the subaccount's exchange deposits */
export interface MsgDeposit {
  sender: string;
  /**
   * (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin will be deposited to the sender's default
   * subaccount address.
   */
  subaccountId: string;
  amount: Coin | undefined;
}

/** MsgDepositResponse defines the Msg/Deposit response type. */
export interface MsgDepositResponse {
}

/** MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's deposits to the user's bank balance */
export interface MsgWithdraw {
  sender: string;
  /** bytes32 subaccount ID to withdraw funds from */
  subaccountId: string;
  amount: Coin | undefined;
}

/** MsgWithdraw defines the Msg/Withdraw response type. */
export interface MsgWithdrawResponse {
}

/** MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit order. */
export interface MsgCreateSpotLimitOrder {
  sender: string;
  order: SpotOrder | undefined;
}

/** MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response type. */
export interface MsgCreateSpotLimitOrderResponse {
  orderHash: string;
}

/** MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch of spot limit orders. */
export interface MsgBatchCreateSpotLimitOrders {
  sender: string;
  orders: SpotOrder[];
}

/** MsgBatchCreateSpotLimitOrdersResponse defines the Msg/BatchCreateSpotLimitOrders response type. */
export interface MsgBatchCreateSpotLimitOrdersResponse {
  orderHashes: string[];
}

/** MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot market by paying listing fee without governance */
export interface MsgInstantSpotMarketLaunch {
  sender: string;
  /** Ticker for the spot market. */
  ticker: string;
  /** type of coin to use as the base currency */
  baseDenom: string;
  /** type of coin to use as the quote currency */
  quoteDenom: string;
  /** min_price_tick_size defines the minimum tick size of the order's price */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
}

/** MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch response type. */
export interface MsgInstantSpotMarketLaunchResponse {
}

/** MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new perpetual futures market by paying listing fee without governance */
export interface MsgInstantPerpetualMarketLaunch {
  sender: string;
  /** Ticker for the derivative market. */
  ticker: string;
  /** type of coin to use as the base currency */
  quoteDenom: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Oracle type */
  oracleType: OracleType;
  /** maker_fee_rate defines the trade fee rate for makers on the perpetual market */
  makerFeeRate: string;
  /** taker_fee_rate defines the trade fee rate for takers on the perpetual market */
  takerFeeRate: string;
  /** initial_margin_ratio defines the initial margin ratio for the perpetual market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio for the perpetual market */
  maintenanceMarginRatio: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
}

/** MsgInstantPerpetualMarketLaunchResponse defines the Msg/InstantPerpetualMarketLaunchResponse response type. */
export interface MsgInstantPerpetualMarketLaunchResponse {
}

/** MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new perpetual futures market by paying listing fee without governance */
export interface MsgInstantBinaryOptionsMarketLaunch {
  sender: string;
  /** Ticker for the derivative contract. */
  ticker: string;
  /** Oracle symbol */
  oracleSymbol: string;
  /** Oracle Provider */
  oracleProvider: string;
  /** Oracle type */
  oracleType: OracleType;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** maker_fee_rate defines the trade fee rate for makers on the perpetual market */
  makerFeeRate: string;
  /** taker_fee_rate defines the trade fee rate for takers on the perpetual market */
  takerFeeRate: string;
  /** expiration timestamp */
  expirationTimestamp: string;
  /** expiration timestamp */
  settlementTimestamp: string;
  /** admin of the market */
  admin: string;
  /** Address of the quote currency denomination for the binary options contract */
  quoteDenom: string;
  /** min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market */
  minQuantityTickSize: string;
}

/** MsgInstantBinaryOptionsMarketLaunchResponse defines the Msg/InstantBinaryOptionsMarketLaunchResponse response type. */
export interface MsgInstantBinaryOptionsMarketLaunchResponse {
}

/** MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new expiry futures market by paying listing fee without governance */
export interface MsgInstantExpiryFuturesMarketLaunch {
  sender: string;
  /** Ticker for the derivative market. */
  ticker: string;
  /** type of coin to use as the quote currency */
  quoteDenom: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Oracle type */
  oracleType: OracleType;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Expiration time of the market */
  expiry: string;
  /** maker_fee_rate defines the trade fee rate for makers on the expiry futures market */
  makerFeeRate: string;
  /** taker_fee_rate defines the trade fee rate for takers on the expiry futures market */
  takerFeeRate: string;
  /** initial_margin_ratio defines the initial margin ratio for the derivative market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio for the derivative market */
  maintenanceMarginRatio: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
}

/** MsgInstantExpiryFuturesMarketLaunchResponse defines the Msg/InstantExpiryFuturesMarketLaunch response type. */
export interface MsgInstantExpiryFuturesMarketLaunchResponse {
}

/** MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market order. */
export interface MsgCreateSpotMarketOrder {
  sender: string;
  order: SpotOrder | undefined;
}

/** MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder response type. */
export interface MsgCreateSpotMarketOrderResponse {
  orderHash: string;
  results: SpotMarketOrderResults | undefined;
}

export interface SpotMarketOrderResults {
  quantity: string;
  price: string;
  fee: string;
}

/** A Cosmos-SDK MsgCreateDerivativeLimitOrder */
export interface MsgCreateDerivativeLimitOrder {
  sender: string;
  order: DerivativeOrder | undefined;
}

/** MsgCreateDerivativeLimitOrderResponse defines the Msg/CreateDerivativeMarketOrder response type. */
export interface MsgCreateDerivativeLimitOrderResponse {
  orderHash: string;
}

/** A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder */
export interface MsgCreateBinaryOptionsLimitOrder {
  sender: string;
  order: DerivativeOrder | undefined;
}

/** MsgCreateBinaryOptionsLimitOrderResponse defines the Msg/CreateBinaryOptionsLimitOrder response type. */
export interface MsgCreateBinaryOptionsLimitOrderResponse {
  orderHash: string;
}

/** A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders */
export interface MsgBatchCreateDerivativeLimitOrders {
  sender: string;
  orders: DerivativeOrder[];
}

/** MsgBatchCreateDerivativeLimitOrdersResponse defines the Msg/BatchCreateDerivativeLimitOrders response type. */
export interface MsgBatchCreateDerivativeLimitOrdersResponse {
  orderHashes: string[];
}

/** MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type. */
export interface MsgCancelSpotOrder {
  sender: string;
  marketId: string;
  subaccountId: string;
  orderHash: string;
}

/** MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type. */
export interface MsgCancelSpotOrderResponse {
}

/** MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type. */
export interface MsgBatchCancelSpotOrders {
  sender: string;
  data: OrderData[];
}

/** MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders response type. */
export interface MsgBatchCancelSpotOrdersResponse {
  success: boolean[];
}

/** MsgBatchCancelBinaryOptionsOrders defines the Msg/BatchCancelBinaryOptionsOrders response type. */
export interface MsgBatchCancelBinaryOptionsOrders {
  sender: string;
  data: OrderData[];
}

/** BatchCancelBinaryOptionsOrdersResponse defines the Msg/BatchCancelBinaryOptionsOrders response type. */
export interface MsgBatchCancelBinaryOptionsOrdersResponse {
  success: boolean[];
}

/** MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type. */
export interface MsgBatchUpdateOrders {
  sender: string;
  /** subaccount_id only used for the spot_market_ids_to_cancel_all and derivative_market_ids_to_cancel_all. */
  subaccountId: string;
  spotMarketIdsToCancelAll: string[];
  derivativeMarketIdsToCancelAll: string[];
  spotOrdersToCancel: OrderData[];
  derivativeOrdersToCancel: OrderData[];
  spotOrdersToCreate: SpotOrder[];
  derivativeOrdersToCreate: DerivativeOrder[];
  binaryOptionsOrdersToCancel: OrderData[];
  binaryOptionsMarketIdsToCancelAll: string[];
  binaryOptionsOrdersToCreate: DerivativeOrder[];
}

/** MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type. */
export interface MsgBatchUpdateOrdersResponse {
  spotCancelSuccess: boolean[];
  derivativeCancelSuccess: boolean[];
  spotOrderHashes: string[];
  derivativeOrderHashes: string[];
  binaryOptionsCancelSuccess: boolean[];
  binaryOptionsOrderHashes: string[];
}

/** A Cosmos-SDK MsgCreateDerivativeMarketOrder */
export interface MsgCreateDerivativeMarketOrder {
  sender: string;
  order: DerivativeOrder | undefined;
}

/** MsgCreateDerivativeMarketOrderResponse defines the Msg/CreateDerivativeMarketOrder response type. */
export interface MsgCreateDerivativeMarketOrderResponse {
  orderHash: string;
  results: DerivativeMarketOrderResults | undefined;
}

export interface DerivativeMarketOrderResults {
  quantity: string;
  price: string;
  fee: string;
  positionDelta: PositionDelta | undefined;
  payout: string;
}

/** A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder */
export interface MsgCreateBinaryOptionsMarketOrder {
  sender: string;
  order: DerivativeOrder | undefined;
}

/** MsgCreateBinaryOptionsMarketOrderResponse defines the Msg/CreateBinaryOptionsMarketOrder response type. */
export interface MsgCreateBinaryOptionsMarketOrderResponse {
  orderHash: string;
  results: DerivativeMarketOrderResults | undefined;
}

/** MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type. */
export interface MsgCancelDerivativeOrder {
  sender: string;
  marketId: string;
  subaccountId: string;
  orderHash: string;
  /** bitwise combination of OrderMask enum values */
  orderMask: number;
}

/** MsgCancelDerivativeOrderResponse defines the Msg/CancelDerivativeOrderResponse response type. */
export interface MsgCancelDerivativeOrderResponse {
}

/** MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response type. */
export interface MsgCancelBinaryOptionsOrder {
  sender: string;
  marketId: string;
  subaccountId: string;
  orderHash: string;
  /** bitwise combination of OrderMask enum values */
  orderMask: number;
}

/** MsgCancelBinaryOptionsOrderResponse defines the Msg/CancelBinaryOptionsOrderResponse response type. */
export interface MsgCancelBinaryOptionsOrderResponse {
}

export interface OrderData {
  marketId: string;
  subaccountId: string;
  orderHash: string;
  /** bitwise combination of OrderMask enum values */
  orderMask: number;
}

/** MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders response type. */
export interface MsgBatchCancelDerivativeOrders {
  sender: string;
  data: OrderData[];
}

/** MsgBatchCancelDerivativeOrdersResponse defines the Msg/CancelDerivativeOrderResponse response type. */
export interface MsgBatchCancelDerivativeOrdersResponse {
  success: boolean[];
}

/** A Cosmos-SDK MsgSubaccountTransfer */
export interface MsgSubaccountTransfer {
  sender: string;
  sourceSubaccountId: string;
  destinationSubaccountId: string;
  amount: Coin | undefined;
}

/** MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response type. */
export interface MsgSubaccountTransferResponse {
}

/** A Cosmos-SDK MsgExternalTransfer */
export interface MsgExternalTransfer {
  sender: string;
  sourceSubaccountId: string;
  destinationSubaccountId: string;
  amount: Coin | undefined;
}

/** MsgExternalTransferResponse defines the Msg/ExternalTransfer response type. */
export interface MsgExternalTransferResponse {
}

/** A Cosmos-SDK MsgLiquidatePosition */
export interface MsgLiquidatePosition {
  sender: string;
  subaccountId: string;
  marketId: string;
  /** optional order to provide for liquidation */
  order: DerivativeOrder | undefined;
}

/** MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type. */
export interface MsgLiquidatePositionResponse {
}

/** A Cosmos-SDK MsgIncreasePositionMargin */
export interface MsgIncreasePositionMargin {
  sender: string;
  sourceSubaccountId: string;
  destinationSubaccountId: string;
  marketId: string;
  /** amount defines the amount of margin to add to the position */
  amount: string;
}

/** MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin response type. */
export interface MsgIncreasePositionMarginResponse {
}

/** MsgPrivilegedExecuteContract defines the Msg/Exec message type */
export interface MsgPrivilegedExecuteContract {
  sender: string;
  /** funds defines the user's bank coins used to fund the execution (e.g. 100inj). */
  funds: string;
  /** contract_address defines the contract address to execute */
  contractAddress: string;
  /** data defines the call data used when executing the contract */
  data: string;
}

/** MsgPrivilegedExecuteContractResponse defines the Msg/Exec response type. */
export interface MsgPrivilegedExecuteContractResponse {
  fundsDiff: Coin[];
}

export interface SpotMarketParamUpdateProposal {
  title: string;
  description: string;
  marketId: string;
  /** maker_fee_rate defines the trade fee rate for makers on the spot market */
  makerFeeRate: string;
  /** taker_fee_rate defines the trade fee rate for takers on the spot market */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the relayer fee share rate for the spot market */
  relayerFeeShareRate: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
  status: MarketStatus;
}

export interface ExchangeEnableProposal {
  title: string;
  description: string;
  exchangeType: ExchangeType;
}

export interface BatchExchangeModificationProposal {
  title: string;
  description: string;
  spotMarketParamUpdateProposals: SpotMarketParamUpdateProposal[];
  derivativeMarketParamUpdateProposals: DerivativeMarketParamUpdateProposal[];
  spotMarketLaunchProposals: SpotMarketLaunchProposal[];
  perpetualMarketLaunchProposals: PerpetualMarketLaunchProposal[];
  expiryFuturesMarketLaunchProposals: ExpiryFuturesMarketLaunchProposal[];
  tradingRewardCampaignUpdateProposal: TradingRewardCampaignUpdateProposal | undefined;
  binaryOptionsMarketLaunchProposals: BinaryOptionsMarketLaunchProposal[];
  binaryOptionsParamUpdateProposals: BinaryOptionsMarketParamUpdateProposal[];
  denomDecimalsUpdateProposal: UpdateDenomDecimalsProposal | undefined;
}

/** SpotMarketLaunchProposal defines a SDK message for proposing a new spot market through governance */
export interface SpotMarketLaunchProposal {
  title: string;
  description: string;
  /** Ticker for the spot market. */
  ticker: string;
  /** type of coin to use as the base currency */
  baseDenom: string;
  /** type of coin to use as the quote currency */
  quoteDenom: string;
  /** min_price_tick_size defines the minimum tick size of the order's price */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
  /** maker_fee_rate defines the fee percentage makers pay when trading */
  makerFeeRate: string;
  /** taker_fee_rate defines the fee percentage takers pay when trading */
  takerFeeRate: string;
}

/** PerpetualMarketLaunchProposal defines a SDK message for proposing a new perpetual futures market through governance */
export interface PerpetualMarketLaunchProposal {
  title: string;
  description: string;
  /** Ticker for the derivative market. */
  ticker: string;
  /** type of coin to use as the base currency */
  quoteDenom: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Oracle type */
  oracleType: OracleType;
  /** initial_margin_ratio defines the initial margin ratio for the derivative market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio for the derivative market */
  maintenanceMarginRatio: string;
  /** maker_fee_rate defines the exchange trade fee for makers for the derivative market */
  makerFeeRate: string;
  /** taker_fee_rate defines the exchange trade fee for takers for the derivative market */
  takerFeeRate: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
}

export interface BinaryOptionsMarketLaunchProposal {
  title: string;
  description: string;
  /** Ticker for the derivative contract. */
  ticker: string;
  /** Oracle symbol */
  oracleSymbol: string;
  /** Oracle Provider */
  oracleProvider: string;
  /** Oracle type */
  oracleType: OracleType;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** expiration timestamp */
  expirationTimestamp: string;
  /** expiration timestamp */
  settlementTimestamp: string;
  /** admin of the market */
  admin: string;
  /** Address of the quote currency denomination for the binary options contract */
  quoteDenom: string;
  /** maker_fee_rate defines the maker fee rate of a binary options market */
  makerFeeRate: string;
  /** taker_fee_rate defines the taker fee rate of a derivative market */
  takerFeeRate: string;
  /** min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market */
  minQuantityTickSize: string;
}

/** ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new expiry futures market through governance */
export interface ExpiryFuturesMarketLaunchProposal {
  title: string;
  description: string;
  /** Ticker for the derivative market. */
  ticker: string;
  /** type of coin to use as the quote currency */
  quoteDenom: string;
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Oracle type */
  oracleType: OracleType;
  /** Expiration time of the market */
  expiry: string;
  /** initial_margin_ratio defines the initial margin ratio for the derivative market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio for the derivative market */
  maintenanceMarginRatio: string;
  /** maker_fee_rate defines the exchange trade fee for makers for the derivative market */
  makerFeeRate: string;
  /** taker_fee_rate defines the exchange trade fee for takers for the derivative market */
  takerFeeRate: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
}

export interface DerivativeMarketParamUpdateProposal {
  title: string;
  description: string;
  marketId: string;
  /** initial_margin_ratio defines the initial margin ratio for the derivative market */
  initialMarginRatio: string;
  /** maintenance_margin_ratio defines the maintenance margin ratio for the derivative market */
  maintenanceMarginRatio: string;
  /** maker_fee_rate defines the exchange trade fee for makers for the derivative market */
  makerFeeRate: string;
  /** taker_fee_rate defines the exchange trade fee for takers for the derivative market */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the relayer fee share rate for the derivative market */
  relayerFeeShareRate: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
  /** hourly_interest_rate defines the hourly interest rate */
  HourlyInterestRate: string;
  /** hourly_funding_rate_cap defines the maximum absolute value of the hourly funding rate */
  HourlyFundingRateCap: string;
  status: MarketStatus;
  oracleParams: OracleParams | undefined;
}

export interface MarketForcedSettlementProposal {
  title: string;
  description: string;
  marketId: string;
  settlementPrice: string;
}

export interface UpdateDenomDecimalsProposal {
  title: string;
  description: string;
  denomDecimals: DenomDecimals[];
}

export interface BinaryOptionsMarketParamUpdateProposal {
  title: string;
  description: string;
  marketId: string;
  /** maker_fee_rate defines the exchange trade fee for makers for the derivative market */
  makerFeeRate: string;
  /** taker_fee_rate defines the exchange trade fee for takers for the derivative market */
  takerFeeRate: string;
  /** relayer_fee_share_rate defines the relayer fee share rate for the derivative market */
  relayerFeeShareRate: string;
  /** min_price_tick_size defines the minimum tick size of the order's price and margin */
  minPriceTickSize: string;
  /** min_quantity_tick_size defines the minimum tick size of the order's quantity */
  minQuantityTickSize: string;
  /** expiration timestamp */
  expirationTimestamp: string;
  /** expiration timestamp */
  settlementTimestamp: string;
  /** new price at which market will be settled */
  settlementPrice: string;
  /** admin of the market */
  admin: string;
  status: MarketStatus;
  oracleParams: ProviderOracleParams | undefined;
}

export interface ProviderOracleParams {
  /** Oracle base currency */
  symbol: string;
  /** Oracle quote currency */
  provider: string;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Oracle type */
  oracleType: OracleType;
}

export interface OracleParams {
  /** Oracle base currency */
  oracleBase: string;
  /** Oracle quote currency */
  oracleQuote: string;
  /** Scale factor for oracle prices. */
  oracleScaleFactor: number;
  /** Oracle type */
  oracleType: OracleType;
}

export interface TradingRewardCampaignLaunchProposal {
  title: string;
  description: string;
  campaignInfo: TradingRewardCampaignInfo | undefined;
  campaignRewardPools: CampaignRewardPool[];
}

export interface TradingRewardCampaignUpdateProposal {
  title: string;
  description: string;
  campaignInfo: TradingRewardCampaignInfo | undefined;
  campaignRewardPoolsAdditions: CampaignRewardPool[];
  campaignRewardPoolsUpdates: CampaignRewardPool[];
}

export interface RewardPointUpdate {
  accountAddress: string;
  /** new_points overwrites the current trading reward points for the account */
  newPoints: string;
}

export interface TradingRewardPendingPointsUpdateProposal {
  title: string;
  description: string;
  pendingPoolTimestamp: string;
  rewardPointUpdates: RewardPointUpdate[];
}

export interface FeeDiscountProposal {
  title: string;
  description: string;
  schedule: FeeDiscountSchedule | undefined;
}

export interface BatchCommunityPoolSpendProposal {
  title: string;
  description: string;
  proposals: CommunityPoolSpendProposal[];
}

/** A Cosmos-SDK MsgRewardsOptOut */
export interface MsgRewardsOptOut {
  sender: string;
}

/** MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type. */
export interface MsgRewardsOptOutResponse {
}

/** A Cosmos-SDK MsgReclaimLockedFunds */
export interface MsgReclaimLockedFunds {
  sender: string;
  lockedAccountPubKey: Uint8Array;
  signature: Uint8Array;
}

/** MsgReclaimLockedFundsResponse defines the Msg/ReclaimLockedFunds response type. */
export interface MsgReclaimLockedFundsResponse {
}

/** MsgSignData defines an arbitrary, general-purpose, off-chain message */
export interface MsgSignData {
  /** Signer is the sdk.AccAddress of the message signer */
  Signer: Uint8Array;
  /** Data represents the raw bytes of the content that is signed (text, json, etc) */
  Data: Uint8Array;
}

/** MsgSignDoc defines an arbitrary, general-purpose, off-chain message */
export interface MsgSignDoc {
  signType: string;
  value: MsgSignData | undefined;
}

/** MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the market */
export interface MsgAdminUpdateBinaryOptionsMarket {
  sender: string;
  marketId: string;
  /** new price at which market will be settled */
  settlementPrice: string;
  /** expiration timestamp */
  expirationTimestamp: string;
  /** expiration timestamp */
  settlementTimestamp: string;
  /** Status of the market */
  status: MarketStatus;
}

/** MsgAdminUpdateBinaryOptionsMarketResponse is the response for AdminUpdateBinaryOptionsMarket rpc method */
export interface MsgAdminUpdateBinaryOptionsMarketResponse {
}

/** AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for proposing new atomic take fee multipliers for specified markets */
export interface AtomicMarketOrderFeeMultiplierScheduleProposal {
  title: string;
  description: string;
  marketFeeMultipliers: MarketFeeMultiplier[];
}

function createBaseMsgDeposit(): MsgDeposit {
  return { sender: "", subaccountId: "", amount: undefined };
}

export const MsgDeposit = {
  encode(message: MsgDeposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeposit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgDeposit {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgDeposit): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgDeposit>): MsgDeposit {
    return MsgDeposit.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgDeposit>): MsgDeposit {
    const message = createBaseMsgDeposit();
    message.sender = object.sender ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgDepositResponse(): MsgDepositResponse {
  return {};
}

export const MsgDepositResponse = {
  encode(_: MsgDepositResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgDepositResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDepositResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgDepositResponse {
    return {};
  },

  toJSON(_: MsgDepositResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDepositResponse>): MsgDepositResponse {
    return MsgDepositResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgDepositResponse>): MsgDepositResponse {
    const message = createBaseMsgDepositResponse();
    return message;
  },
};

function createBaseMsgWithdraw(): MsgWithdraw {
  return { sender: "", subaccountId: "", amount: undefined };
}

export const MsgWithdraw = {
  encode(message: MsgWithdraw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdraw {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWithdraw {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgWithdraw): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgWithdraw>): MsgWithdraw {
    return MsgWithdraw.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgWithdraw>): MsgWithdraw {
    const message = createBaseMsgWithdraw();
    message.sender = object.sender ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgWithdrawResponse(): MsgWithdrawResponse {
  return {};
}

export const MsgWithdrawResponse = {
  encode(_: MsgWithdrawResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawResponse {
    return {};
  },

  toJSON(_: MsgWithdrawResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgWithdrawResponse>): MsgWithdrawResponse {
    return MsgWithdrawResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgWithdrawResponse>): MsgWithdrawResponse {
    const message = createBaseMsgWithdrawResponse();
    return message;
  },
};

function createBaseMsgCreateSpotLimitOrder(): MsgCreateSpotLimitOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateSpotLimitOrder = {
  encode(message: MsgCreateSpotLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      SpotOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateSpotLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSpotLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = SpotOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSpotLimitOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? SpotOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateSpotLimitOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? SpotOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateSpotLimitOrder>): MsgCreateSpotLimitOrder {
    return MsgCreateSpotLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateSpotLimitOrder>): MsgCreateSpotLimitOrder {
    const message = createBaseMsgCreateSpotLimitOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? SpotOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateSpotLimitOrderResponse(): MsgCreateSpotLimitOrderResponse {
  return { orderHash: "" };
}

export const MsgCreateSpotLimitOrderResponse = {
  encode(message: MsgCreateSpotLimitOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateSpotLimitOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSpotLimitOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSpotLimitOrderResponse {
    return { orderHash: isSet(object.orderHash) ? String(object.orderHash) : "" };
  },

  toJSON(message: MsgCreateSpotLimitOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateSpotLimitOrderResponse>): MsgCreateSpotLimitOrderResponse {
    return MsgCreateSpotLimitOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateSpotLimitOrderResponse>): MsgCreateSpotLimitOrderResponse {
    const message = createBaseMsgCreateSpotLimitOrderResponse();
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseMsgBatchCreateSpotLimitOrders(): MsgBatchCreateSpotLimitOrders {
  return { sender: "", orders: [] };
}

export const MsgBatchCreateSpotLimitOrders = {
  encode(message: MsgBatchCreateSpotLimitOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.orders) {
      SpotOrder.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCreateSpotLimitOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCreateSpotLimitOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.orders.push(SpotOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCreateSpotLimitOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => SpotOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgBatchCreateSpotLimitOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? SpotOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCreateSpotLimitOrders>): MsgBatchCreateSpotLimitOrders {
    return MsgBatchCreateSpotLimitOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCreateSpotLimitOrders>): MsgBatchCreateSpotLimitOrders {
    const message = createBaseMsgBatchCreateSpotLimitOrders();
    message.sender = object.sender ?? "";
    message.orders = object.orders?.map((e) => SpotOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchCreateSpotLimitOrdersResponse(): MsgBatchCreateSpotLimitOrdersResponse {
  return { orderHashes: [] };
}

export const MsgBatchCreateSpotLimitOrdersResponse = {
  encode(message: MsgBatchCreateSpotLimitOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderHashes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCreateSpotLimitOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCreateSpotLimitOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCreateSpotLimitOrdersResponse {
    return { orderHashes: Array.isArray(object?.orderHashes) ? object.orderHashes.map((e: any) => String(e)) : [] };
  },

  toJSON(message: MsgBatchCreateSpotLimitOrdersResponse): unknown {
    const obj: any = {};
    if (message.orderHashes) {
      obj.orderHashes = message.orderHashes.map((e) => e);
    } else {
      obj.orderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCreateSpotLimitOrdersResponse>): MsgBatchCreateSpotLimitOrdersResponse {
    return MsgBatchCreateSpotLimitOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCreateSpotLimitOrdersResponse>): MsgBatchCreateSpotLimitOrdersResponse {
    const message = createBaseMsgBatchCreateSpotLimitOrdersResponse();
    message.orderHashes = object.orderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgInstantSpotMarketLaunch(): MsgInstantSpotMarketLaunch {
  return { sender: "", ticker: "", baseDenom: "", quoteDenom: "", minPriceTickSize: "", minQuantityTickSize: "" };
}

export const MsgInstantSpotMarketLaunch = {
  encode(message: MsgInstantSpotMarketLaunch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ticker !== "") {
      writer.uint32(18).string(message.ticker);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(34).string(message.quoteDenom);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(42).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(50).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantSpotMarketLaunch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantSpotMarketLaunch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.ticker = reader.string();
          break;
        case 3:
          message.baseDenom = reader.string();
          break;
        case 4:
          message.quoteDenom = reader.string();
          break;
        case 5:
          message.minPriceTickSize = reader.string();
          break;
        case 6:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgInstantSpotMarketLaunch {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: MsgInstantSpotMarketLaunch): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<MsgInstantSpotMarketLaunch>): MsgInstantSpotMarketLaunch {
    return MsgInstantSpotMarketLaunch.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgInstantSpotMarketLaunch>): MsgInstantSpotMarketLaunch {
    const message = createBaseMsgInstantSpotMarketLaunch();
    message.sender = object.sender ?? "";
    message.ticker = object.ticker ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseMsgInstantSpotMarketLaunchResponse(): MsgInstantSpotMarketLaunchResponse {
  return {};
}

export const MsgInstantSpotMarketLaunchResponse = {
  encode(_: MsgInstantSpotMarketLaunchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantSpotMarketLaunchResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantSpotMarketLaunchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgInstantSpotMarketLaunchResponse {
    return {};
  },

  toJSON(_: MsgInstantSpotMarketLaunchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInstantSpotMarketLaunchResponse>): MsgInstantSpotMarketLaunchResponse {
    return MsgInstantSpotMarketLaunchResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgInstantSpotMarketLaunchResponse>): MsgInstantSpotMarketLaunchResponse {
    const message = createBaseMsgInstantSpotMarketLaunchResponse();
    return message;
  },
};

function createBaseMsgInstantPerpetualMarketLaunch(): MsgInstantPerpetualMarketLaunch {
  return {
    sender: "",
    ticker: "",
    quoteDenom: "",
    oracleBase: "",
    oracleQuote: "",
    oracleScaleFactor: 0,
    oracleType: 0,
    makerFeeRate: "",
    takerFeeRate: "",
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const MsgInstantPerpetualMarketLaunch = {
  encode(message: MsgInstantPerpetualMarketLaunch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ticker !== "") {
      writer.uint32(18).string(message.ticker);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(26).string(message.quoteDenom);
    }
    if (message.oracleBase !== "") {
      writer.uint32(34).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(42).string(message.oracleQuote);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(48).uint32(message.oracleScaleFactor);
    }
    if (message.oracleType !== 0) {
      writer.uint32(56).int32(message.oracleType);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(66).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(74).string(message.takerFeeRate);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(82).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(90).string(message.maintenanceMarginRatio);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(98).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(106).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantPerpetualMarketLaunch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantPerpetualMarketLaunch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.ticker = reader.string();
          break;
        case 3:
          message.quoteDenom = reader.string();
          break;
        case 4:
          message.oracleBase = reader.string();
          break;
        case 5:
          message.oracleQuote = reader.string();
          break;
        case 6:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 7:
          message.oracleType = reader.int32() as any;
          break;
        case 8:
          message.makerFeeRate = reader.string();
          break;
        case 9:
          message.takerFeeRate = reader.string();
          break;
        case 10:
          message.initialMarginRatio = reader.string();
          break;
        case 11:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 12:
          message.minPriceTickSize = reader.string();
          break;
        case 13:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgInstantPerpetualMarketLaunch {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: MsgInstantPerpetualMarketLaunch): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<MsgInstantPerpetualMarketLaunch>): MsgInstantPerpetualMarketLaunch {
    return MsgInstantPerpetualMarketLaunch.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgInstantPerpetualMarketLaunch>): MsgInstantPerpetualMarketLaunch {
    const message = createBaseMsgInstantPerpetualMarketLaunch();
    message.sender = object.sender ?? "";
    message.ticker = object.ticker ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.oracleType = object.oracleType ?? 0;
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseMsgInstantPerpetualMarketLaunchResponse(): MsgInstantPerpetualMarketLaunchResponse {
  return {};
}

export const MsgInstantPerpetualMarketLaunchResponse = {
  encode(_: MsgInstantPerpetualMarketLaunchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantPerpetualMarketLaunchResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantPerpetualMarketLaunchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgInstantPerpetualMarketLaunchResponse {
    return {};
  },

  toJSON(_: MsgInstantPerpetualMarketLaunchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInstantPerpetualMarketLaunchResponse>): MsgInstantPerpetualMarketLaunchResponse {
    return MsgInstantPerpetualMarketLaunchResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgInstantPerpetualMarketLaunchResponse>): MsgInstantPerpetualMarketLaunchResponse {
    const message = createBaseMsgInstantPerpetualMarketLaunchResponse();
    return message;
  },
};

function createBaseMsgInstantBinaryOptionsMarketLaunch(): MsgInstantBinaryOptionsMarketLaunch {
  return {
    sender: "",
    ticker: "",
    oracleSymbol: "",
    oracleProvider: "",
    oracleType: 0,
    oracleScaleFactor: 0,
    makerFeeRate: "",
    takerFeeRate: "",
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    admin: "",
    quoteDenom: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const MsgInstantBinaryOptionsMarketLaunch = {
  encode(message: MsgInstantBinaryOptionsMarketLaunch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ticker !== "") {
      writer.uint32(18).string(message.ticker);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(26).string(message.oracleSymbol);
    }
    if (message.oracleProvider !== "") {
      writer.uint32(34).string(message.oracleProvider);
    }
    if (message.oracleType !== 0) {
      writer.uint32(40).int32(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(48).uint32(message.oracleScaleFactor);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(58).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(66).string(message.takerFeeRate);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(72).int64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(80).int64(message.settlementTimestamp);
    }
    if (message.admin !== "") {
      writer.uint32(90).string(message.admin);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(98).string(message.quoteDenom);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(106).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(114).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantBinaryOptionsMarketLaunch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantBinaryOptionsMarketLaunch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.ticker = reader.string();
          break;
        case 3:
          message.oracleSymbol = reader.string();
          break;
        case 4:
          message.oracleProvider = reader.string();
          break;
        case 5:
          message.oracleType = reader.int32() as any;
          break;
        case 6:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 7:
          message.makerFeeRate = reader.string();
          break;
        case 8:
          message.takerFeeRate = reader.string();
          break;
        case 9:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 10:
          message.settlementTimestamp = longToString(reader.int64() as Long);
          break;
        case 11:
          message.admin = reader.string();
          break;
        case 12:
          message.quoteDenom = reader.string();
          break;
        case 13:
          message.minPriceTickSize = reader.string();
          break;
        case 14:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgInstantBinaryOptionsMarketLaunch {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? String(object.oracleSymbol) : "",
      oracleProvider: isSet(object.oracleProvider) ? String(object.oracleProvider) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      admin: isSet(object.admin) ? String(object.admin) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: MsgInstantBinaryOptionsMarketLaunch): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleSymbol !== undefined && (obj.oracleSymbol = message.oracleSymbol);
    message.oracleProvider !== undefined && (obj.oracleProvider = message.oracleProvider);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.admin !== undefined && (obj.admin = message.admin);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<MsgInstantBinaryOptionsMarketLaunch>): MsgInstantBinaryOptionsMarketLaunch {
    return MsgInstantBinaryOptionsMarketLaunch.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgInstantBinaryOptionsMarketLaunch>): MsgInstantBinaryOptionsMarketLaunch {
    const message = createBaseMsgInstantBinaryOptionsMarketLaunch();
    message.sender = object.sender ?? "";
    message.ticker = object.ticker ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.oracleProvider = object.oracleProvider ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.admin = object.admin ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseMsgInstantBinaryOptionsMarketLaunchResponse(): MsgInstantBinaryOptionsMarketLaunchResponse {
  return {};
}

export const MsgInstantBinaryOptionsMarketLaunchResponse = {
  encode(_: MsgInstantBinaryOptionsMarketLaunchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantBinaryOptionsMarketLaunchResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantBinaryOptionsMarketLaunchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgInstantBinaryOptionsMarketLaunchResponse {
    return {};
  },

  toJSON(_: MsgInstantBinaryOptionsMarketLaunchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInstantBinaryOptionsMarketLaunchResponse>): MsgInstantBinaryOptionsMarketLaunchResponse {
    return MsgInstantBinaryOptionsMarketLaunchResponse.fromPartial(base ?? {});
  },

  fromPartial(
    _: DeepPartial<MsgInstantBinaryOptionsMarketLaunchResponse>,
  ): MsgInstantBinaryOptionsMarketLaunchResponse {
    const message = createBaseMsgInstantBinaryOptionsMarketLaunchResponse();
    return message;
  },
};

function createBaseMsgInstantExpiryFuturesMarketLaunch(): MsgInstantExpiryFuturesMarketLaunch {
  return {
    sender: "",
    ticker: "",
    quoteDenom: "",
    oracleBase: "",
    oracleQuote: "",
    oracleType: 0,
    oracleScaleFactor: 0,
    expiry: "0",
    makerFeeRate: "",
    takerFeeRate: "",
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const MsgInstantExpiryFuturesMarketLaunch = {
  encode(message: MsgInstantExpiryFuturesMarketLaunch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ticker !== "") {
      writer.uint32(18).string(message.ticker);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(26).string(message.quoteDenom);
    }
    if (message.oracleBase !== "") {
      writer.uint32(34).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(42).string(message.oracleQuote);
    }
    if (message.oracleType !== 0) {
      writer.uint32(48).int32(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.expiry !== "0") {
      writer.uint32(64).int64(message.expiry);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(74).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(82).string(message.takerFeeRate);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(90).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(98).string(message.maintenanceMarginRatio);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(106).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(114).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantExpiryFuturesMarketLaunch {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantExpiryFuturesMarketLaunch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.ticker = reader.string();
          break;
        case 3:
          message.quoteDenom = reader.string();
          break;
        case 4:
          message.oracleBase = reader.string();
          break;
        case 5:
          message.oracleQuote = reader.string();
          break;
        case 6:
          message.oracleType = reader.int32() as any;
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.expiry = longToString(reader.int64() as Long);
          break;
        case 9:
          message.makerFeeRate = reader.string();
          break;
        case 10:
          message.takerFeeRate = reader.string();
          break;
        case 11:
          message.initialMarginRatio = reader.string();
          break;
        case 12:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 13:
          message.minPriceTickSize = reader.string();
          break;
        case 14:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgInstantExpiryFuturesMarketLaunch {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      expiry: isSet(object.expiry) ? String(object.expiry) : "0",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: MsgInstantExpiryFuturesMarketLaunch): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.expiry !== undefined && (obj.expiry = message.expiry);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<MsgInstantExpiryFuturesMarketLaunch>): MsgInstantExpiryFuturesMarketLaunch {
    return MsgInstantExpiryFuturesMarketLaunch.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgInstantExpiryFuturesMarketLaunch>): MsgInstantExpiryFuturesMarketLaunch {
    const message = createBaseMsgInstantExpiryFuturesMarketLaunch();
    message.sender = object.sender ?? "";
    message.ticker = object.ticker ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.expiry = object.expiry ?? "0";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseMsgInstantExpiryFuturesMarketLaunchResponse(): MsgInstantExpiryFuturesMarketLaunchResponse {
  return {};
}

export const MsgInstantExpiryFuturesMarketLaunchResponse = {
  encode(_: MsgInstantExpiryFuturesMarketLaunchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgInstantExpiryFuturesMarketLaunchResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInstantExpiryFuturesMarketLaunchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgInstantExpiryFuturesMarketLaunchResponse {
    return {};
  },

  toJSON(_: MsgInstantExpiryFuturesMarketLaunchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInstantExpiryFuturesMarketLaunchResponse>): MsgInstantExpiryFuturesMarketLaunchResponse {
    return MsgInstantExpiryFuturesMarketLaunchResponse.fromPartial(base ?? {});
  },

  fromPartial(
    _: DeepPartial<MsgInstantExpiryFuturesMarketLaunchResponse>,
  ): MsgInstantExpiryFuturesMarketLaunchResponse {
    const message = createBaseMsgInstantExpiryFuturesMarketLaunchResponse();
    return message;
  },
};

function createBaseMsgCreateSpotMarketOrder(): MsgCreateSpotMarketOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateSpotMarketOrder = {
  encode(message: MsgCreateSpotMarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      SpotOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateSpotMarketOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSpotMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = SpotOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSpotMarketOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? SpotOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateSpotMarketOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? SpotOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateSpotMarketOrder>): MsgCreateSpotMarketOrder {
    return MsgCreateSpotMarketOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateSpotMarketOrder>): MsgCreateSpotMarketOrder {
    const message = createBaseMsgCreateSpotMarketOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? SpotOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateSpotMarketOrderResponse(): MsgCreateSpotMarketOrderResponse {
  return { orderHash: "", results: undefined };
}

export const MsgCreateSpotMarketOrderResponse = {
  encode(message: MsgCreateSpotMarketOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.results !== undefined) {
      SpotMarketOrderResults.encode(message.results, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateSpotMarketOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSpotMarketOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.results = SpotMarketOrderResults.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSpotMarketOrderResponse {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      results: isSet(object.results) ? SpotMarketOrderResults.fromJSON(object.results) : undefined,
    };
  },

  toJSON(message: MsgCreateSpotMarketOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.results !== undefined &&
      (obj.results = message.results ? SpotMarketOrderResults.toJSON(message.results) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateSpotMarketOrderResponse>): MsgCreateSpotMarketOrderResponse {
    return MsgCreateSpotMarketOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateSpotMarketOrderResponse>): MsgCreateSpotMarketOrderResponse {
    const message = createBaseMsgCreateSpotMarketOrderResponse();
    message.orderHash = object.orderHash ?? "";
    message.results = (object.results !== undefined && object.results !== null)
      ? SpotMarketOrderResults.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseSpotMarketOrderResults(): SpotMarketOrderResults {
  return { quantity: "", price: "", fee: "" };
}

export const SpotMarketOrderResults = {
  encode(message: SpotMarketOrderResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.quantity !== "") {
      writer.uint32(10).string(message.quantity);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.fee !== "") {
      writer.uint32(26).string(message.fee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketOrderResults {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarketOrderResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quantity = reader.string();
          break;
        case 2:
          message.price = reader.string();
          break;
        case 3:
          message.fee = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarketOrderResults {
    return {
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      price: isSet(object.price) ? String(object.price) : "",
      fee: isSet(object.fee) ? String(object.fee) : "",
    };
  },

  toJSON(message: SpotMarketOrderResults): unknown {
    const obj: any = {};
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.price !== undefined && (obj.price = message.price);
    message.fee !== undefined && (obj.fee = message.fee);
    return obj;
  },

  create(base?: DeepPartial<SpotMarketOrderResults>): SpotMarketOrderResults {
    return SpotMarketOrderResults.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarketOrderResults>): SpotMarketOrderResults {
    const message = createBaseSpotMarketOrderResults();
    message.quantity = object.quantity ?? "";
    message.price = object.price ?? "";
    message.fee = object.fee ?? "";
    return message;
  },
};

function createBaseMsgCreateDerivativeLimitOrder(): MsgCreateDerivativeLimitOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateDerivativeLimitOrder = {
  encode(message: MsgCreateDerivativeLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      DerivativeOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDerivativeLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDerivativeLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = DerivativeOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDerivativeLimitOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? DerivativeOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateDerivativeLimitOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? DerivativeOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateDerivativeLimitOrder>): MsgCreateDerivativeLimitOrder {
    return MsgCreateDerivativeLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateDerivativeLimitOrder>): MsgCreateDerivativeLimitOrder {
    const message = createBaseMsgCreateDerivativeLimitOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateDerivativeLimitOrderResponse(): MsgCreateDerivativeLimitOrderResponse {
  return { orderHash: "" };
}

export const MsgCreateDerivativeLimitOrderResponse = {
  encode(message: MsgCreateDerivativeLimitOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDerivativeLimitOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDerivativeLimitOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDerivativeLimitOrderResponse {
    return { orderHash: isSet(object.orderHash) ? String(object.orderHash) : "" };
  },

  toJSON(message: MsgCreateDerivativeLimitOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateDerivativeLimitOrderResponse>): MsgCreateDerivativeLimitOrderResponse {
    return MsgCreateDerivativeLimitOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateDerivativeLimitOrderResponse>): MsgCreateDerivativeLimitOrderResponse {
    const message = createBaseMsgCreateDerivativeLimitOrderResponse();
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseMsgCreateBinaryOptionsLimitOrder(): MsgCreateBinaryOptionsLimitOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateBinaryOptionsLimitOrder = {
  encode(message: MsgCreateBinaryOptionsLimitOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      DerivativeOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBinaryOptionsLimitOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBinaryOptionsLimitOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = DerivativeOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBinaryOptionsLimitOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? DerivativeOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateBinaryOptionsLimitOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? DerivativeOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateBinaryOptionsLimitOrder>): MsgCreateBinaryOptionsLimitOrder {
    return MsgCreateBinaryOptionsLimitOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateBinaryOptionsLimitOrder>): MsgCreateBinaryOptionsLimitOrder {
    const message = createBaseMsgCreateBinaryOptionsLimitOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateBinaryOptionsLimitOrderResponse(): MsgCreateBinaryOptionsLimitOrderResponse {
  return { orderHash: "" };
}

export const MsgCreateBinaryOptionsLimitOrderResponse = {
  encode(message: MsgCreateBinaryOptionsLimitOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBinaryOptionsLimitOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBinaryOptionsLimitOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBinaryOptionsLimitOrderResponse {
    return { orderHash: isSet(object.orderHash) ? String(object.orderHash) : "" };
  },

  toJSON(message: MsgCreateBinaryOptionsLimitOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateBinaryOptionsLimitOrderResponse>): MsgCreateBinaryOptionsLimitOrderResponse {
    return MsgCreateBinaryOptionsLimitOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateBinaryOptionsLimitOrderResponse>): MsgCreateBinaryOptionsLimitOrderResponse {
    const message = createBaseMsgCreateBinaryOptionsLimitOrderResponse();
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseMsgBatchCreateDerivativeLimitOrders(): MsgBatchCreateDerivativeLimitOrders {
  return { sender: "", orders: [] };
}

export const MsgBatchCreateDerivativeLimitOrders = {
  encode(message: MsgBatchCreateDerivativeLimitOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.orders) {
      DerivativeOrder.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCreateDerivativeLimitOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCreateDerivativeLimitOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.orders.push(DerivativeOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCreateDerivativeLimitOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      orders: Array.isArray(object?.orders) ? object.orders.map((e: any) => DerivativeOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgBatchCreateDerivativeLimitOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    if (message.orders) {
      obj.orders = message.orders.map((e) => e ? DerivativeOrder.toJSON(e) : undefined);
    } else {
      obj.orders = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCreateDerivativeLimitOrders>): MsgBatchCreateDerivativeLimitOrders {
    return MsgBatchCreateDerivativeLimitOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCreateDerivativeLimitOrders>): MsgBatchCreateDerivativeLimitOrders {
    const message = createBaseMsgBatchCreateDerivativeLimitOrders();
    message.sender = object.sender ?? "";
    message.orders = object.orders?.map((e) => DerivativeOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchCreateDerivativeLimitOrdersResponse(): MsgBatchCreateDerivativeLimitOrdersResponse {
  return { orderHashes: [] };
}

export const MsgBatchCreateDerivativeLimitOrdersResponse = {
  encode(message: MsgBatchCreateDerivativeLimitOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderHashes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCreateDerivativeLimitOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCreateDerivativeLimitOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCreateDerivativeLimitOrdersResponse {
    return { orderHashes: Array.isArray(object?.orderHashes) ? object.orderHashes.map((e: any) => String(e)) : [] };
  },

  toJSON(message: MsgBatchCreateDerivativeLimitOrdersResponse): unknown {
    const obj: any = {};
    if (message.orderHashes) {
      obj.orderHashes = message.orderHashes.map((e) => e);
    } else {
      obj.orderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCreateDerivativeLimitOrdersResponse>): MsgBatchCreateDerivativeLimitOrdersResponse {
    return MsgBatchCreateDerivativeLimitOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<MsgBatchCreateDerivativeLimitOrdersResponse>,
  ): MsgBatchCreateDerivativeLimitOrdersResponse {
    const message = createBaseMsgBatchCreateDerivativeLimitOrdersResponse();
    message.orderHashes = object.orderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgCancelSpotOrder(): MsgCancelSpotOrder {
  return { sender: "", marketId: "", subaccountId: "", orderHash: "" };
}

export const MsgCancelSpotOrder = {
  encode(message: MsgCancelSpotOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.orderHash !== "") {
      writer.uint32(34).string(message.orderHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelSpotOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelSpotOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.orderHash = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCancelSpotOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
    };
  },

  toJSON(message: MsgCancelSpotOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    return obj;
  },

  create(base?: DeepPartial<MsgCancelSpotOrder>): MsgCancelSpotOrder {
    return MsgCancelSpotOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCancelSpotOrder>): MsgCancelSpotOrder {
    const message = createBaseMsgCancelSpotOrder();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHash = object.orderHash ?? "";
    return message;
  },
};

function createBaseMsgCancelSpotOrderResponse(): MsgCancelSpotOrderResponse {
  return {};
}

export const MsgCancelSpotOrderResponse = {
  encode(_: MsgCancelSpotOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelSpotOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelSpotOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCancelSpotOrderResponse {
    return {};
  },

  toJSON(_: MsgCancelSpotOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelSpotOrderResponse>): MsgCancelSpotOrderResponse {
    return MsgCancelSpotOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgCancelSpotOrderResponse>): MsgCancelSpotOrderResponse {
    const message = createBaseMsgCancelSpotOrderResponse();
    return message;
  },
};

function createBaseMsgBatchCancelSpotOrders(): MsgBatchCancelSpotOrders {
  return { sender: "", data: [] };
}

export const MsgBatchCancelSpotOrders = {
  encode(message: MsgBatchCancelSpotOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.data) {
      OrderData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelSpotOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelSpotOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.data.push(OrderData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelSpotOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      data: Array.isArray(object?.data) ? object.data.map((e: any) => OrderData.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgBatchCancelSpotOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    if (message.data) {
      obj.data = message.data.map((e) => e ? OrderData.toJSON(e) : undefined);
    } else {
      obj.data = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelSpotOrders>): MsgBatchCancelSpotOrders {
    return MsgBatchCancelSpotOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCancelSpotOrders>): MsgBatchCancelSpotOrders {
    const message = createBaseMsgBatchCancelSpotOrders();
    message.sender = object.sender ?? "";
    message.data = object.data?.map((e) => OrderData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchCancelSpotOrdersResponse(): MsgBatchCancelSpotOrdersResponse {
  return { success: [] };
}

export const MsgBatchCancelSpotOrdersResponse = {
  encode(message: MsgBatchCancelSpotOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.success) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelSpotOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelSpotOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.success.push(reader.bool());
            }
          } else {
            message.success.push(reader.bool());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelSpotOrdersResponse {
    return { success: Array.isArray(object?.success) ? object.success.map((e: any) => Boolean(e)) : [] };
  },

  toJSON(message: MsgBatchCancelSpotOrdersResponse): unknown {
    const obj: any = {};
    if (message.success) {
      obj.success = message.success.map((e) => e);
    } else {
      obj.success = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelSpotOrdersResponse>): MsgBatchCancelSpotOrdersResponse {
    return MsgBatchCancelSpotOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCancelSpotOrdersResponse>): MsgBatchCancelSpotOrdersResponse {
    const message = createBaseMsgBatchCancelSpotOrdersResponse();
    message.success = object.success?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBatchCancelBinaryOptionsOrders(): MsgBatchCancelBinaryOptionsOrders {
  return { sender: "", data: [] };
}

export const MsgBatchCancelBinaryOptionsOrders = {
  encode(message: MsgBatchCancelBinaryOptionsOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.data) {
      OrderData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelBinaryOptionsOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelBinaryOptionsOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.data.push(OrderData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelBinaryOptionsOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      data: Array.isArray(object?.data) ? object.data.map((e: any) => OrderData.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgBatchCancelBinaryOptionsOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    if (message.data) {
      obj.data = message.data.map((e) => e ? OrderData.toJSON(e) : undefined);
    } else {
      obj.data = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelBinaryOptionsOrders>): MsgBatchCancelBinaryOptionsOrders {
    return MsgBatchCancelBinaryOptionsOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCancelBinaryOptionsOrders>): MsgBatchCancelBinaryOptionsOrders {
    const message = createBaseMsgBatchCancelBinaryOptionsOrders();
    message.sender = object.sender ?? "";
    message.data = object.data?.map((e) => OrderData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchCancelBinaryOptionsOrdersResponse(): MsgBatchCancelBinaryOptionsOrdersResponse {
  return { success: [] };
}

export const MsgBatchCancelBinaryOptionsOrdersResponse = {
  encode(message: MsgBatchCancelBinaryOptionsOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.success) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelBinaryOptionsOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelBinaryOptionsOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.success.push(reader.bool());
            }
          } else {
            message.success.push(reader.bool());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelBinaryOptionsOrdersResponse {
    return { success: Array.isArray(object?.success) ? object.success.map((e: any) => Boolean(e)) : [] };
  },

  toJSON(message: MsgBatchCancelBinaryOptionsOrdersResponse): unknown {
    const obj: any = {};
    if (message.success) {
      obj.success = message.success.map((e) => e);
    } else {
      obj.success = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelBinaryOptionsOrdersResponse>): MsgBatchCancelBinaryOptionsOrdersResponse {
    return MsgBatchCancelBinaryOptionsOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<MsgBatchCancelBinaryOptionsOrdersResponse>,
  ): MsgBatchCancelBinaryOptionsOrdersResponse {
    const message = createBaseMsgBatchCancelBinaryOptionsOrdersResponse();
    message.success = object.success?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBatchUpdateOrders(): MsgBatchUpdateOrders {
  return {
    sender: "",
    subaccountId: "",
    spotMarketIdsToCancelAll: [],
    derivativeMarketIdsToCancelAll: [],
    spotOrdersToCancel: [],
    derivativeOrdersToCancel: [],
    spotOrdersToCreate: [],
    derivativeOrdersToCreate: [],
    binaryOptionsOrdersToCancel: [],
    binaryOptionsMarketIdsToCancelAll: [],
    binaryOptionsOrdersToCreate: [],
  };
}

export const MsgBatchUpdateOrders = {
  encode(message: MsgBatchUpdateOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    for (const v of message.spotMarketIdsToCancelAll) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.derivativeMarketIdsToCancelAll) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.spotOrdersToCancel) {
      OrderData.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.derivativeOrdersToCancel) {
      OrderData.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.spotOrdersToCreate) {
      SpotOrder.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.derivativeOrdersToCreate) {
      DerivativeOrder.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.binaryOptionsOrdersToCancel) {
      OrderData.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.binaryOptionsMarketIdsToCancelAll) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.binaryOptionsOrdersToCreate) {
      DerivativeOrder.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchUpdateOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchUpdateOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.spotMarketIdsToCancelAll.push(reader.string());
          break;
        case 4:
          message.derivativeMarketIdsToCancelAll.push(reader.string());
          break;
        case 5:
          message.spotOrdersToCancel.push(OrderData.decode(reader, reader.uint32()));
          break;
        case 6:
          message.derivativeOrdersToCancel.push(OrderData.decode(reader, reader.uint32()));
          break;
        case 7:
          message.spotOrdersToCreate.push(SpotOrder.decode(reader, reader.uint32()));
          break;
        case 8:
          message.derivativeOrdersToCreate.push(DerivativeOrder.decode(reader, reader.uint32()));
          break;
        case 9:
          message.binaryOptionsOrdersToCancel.push(OrderData.decode(reader, reader.uint32()));
          break;
        case 10:
          message.binaryOptionsMarketIdsToCancelAll.push(reader.string());
          break;
        case 11:
          message.binaryOptionsOrdersToCreate.push(DerivativeOrder.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchUpdateOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      spotMarketIdsToCancelAll: Array.isArray(object?.spotMarketIdsToCancelAll)
        ? object.spotMarketIdsToCancelAll.map((e: any) => String(e))
        : [],
      derivativeMarketIdsToCancelAll: Array.isArray(object?.derivativeMarketIdsToCancelAll)
        ? object.derivativeMarketIdsToCancelAll.map((e: any) => String(e))
        : [],
      spotOrdersToCancel: Array.isArray(object?.spotOrdersToCancel)
        ? object.spotOrdersToCancel.map((e: any) => OrderData.fromJSON(e))
        : [],
      derivativeOrdersToCancel: Array.isArray(object?.derivativeOrdersToCancel)
        ? object.derivativeOrdersToCancel.map((e: any) => OrderData.fromJSON(e))
        : [],
      spotOrdersToCreate: Array.isArray(object?.spotOrdersToCreate)
        ? object.spotOrdersToCreate.map((e: any) => SpotOrder.fromJSON(e))
        : [],
      derivativeOrdersToCreate: Array.isArray(object?.derivativeOrdersToCreate)
        ? object.derivativeOrdersToCreate.map((e: any) => DerivativeOrder.fromJSON(e))
        : [],
      binaryOptionsOrdersToCancel: Array.isArray(object?.binaryOptionsOrdersToCancel)
        ? object.binaryOptionsOrdersToCancel.map((e: any) => OrderData.fromJSON(e))
        : [],
      binaryOptionsMarketIdsToCancelAll: Array.isArray(object?.binaryOptionsMarketIdsToCancelAll)
        ? object.binaryOptionsMarketIdsToCancelAll.map((e: any) => String(e))
        : [],
      binaryOptionsOrdersToCreate: Array.isArray(object?.binaryOptionsOrdersToCreate)
        ? object.binaryOptionsOrdersToCreate.map((e: any) => DerivativeOrder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgBatchUpdateOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    if (message.spotMarketIdsToCancelAll) {
      obj.spotMarketIdsToCancelAll = message.spotMarketIdsToCancelAll.map((e) => e);
    } else {
      obj.spotMarketIdsToCancelAll = [];
    }
    if (message.derivativeMarketIdsToCancelAll) {
      obj.derivativeMarketIdsToCancelAll = message.derivativeMarketIdsToCancelAll.map((e) => e);
    } else {
      obj.derivativeMarketIdsToCancelAll = [];
    }
    if (message.spotOrdersToCancel) {
      obj.spotOrdersToCancel = message.spotOrdersToCancel.map((e) => e ? OrderData.toJSON(e) : undefined);
    } else {
      obj.spotOrdersToCancel = [];
    }
    if (message.derivativeOrdersToCancel) {
      obj.derivativeOrdersToCancel = message.derivativeOrdersToCancel.map((e) => e ? OrderData.toJSON(e) : undefined);
    } else {
      obj.derivativeOrdersToCancel = [];
    }
    if (message.spotOrdersToCreate) {
      obj.spotOrdersToCreate = message.spotOrdersToCreate.map((e) => e ? SpotOrder.toJSON(e) : undefined);
    } else {
      obj.spotOrdersToCreate = [];
    }
    if (message.derivativeOrdersToCreate) {
      obj.derivativeOrdersToCreate = message.derivativeOrdersToCreate.map((e) =>
        e ? DerivativeOrder.toJSON(e) : undefined
      );
    } else {
      obj.derivativeOrdersToCreate = [];
    }
    if (message.binaryOptionsOrdersToCancel) {
      obj.binaryOptionsOrdersToCancel = message.binaryOptionsOrdersToCancel.map((e) =>
        e ? OrderData.toJSON(e) : undefined
      );
    } else {
      obj.binaryOptionsOrdersToCancel = [];
    }
    if (message.binaryOptionsMarketIdsToCancelAll) {
      obj.binaryOptionsMarketIdsToCancelAll = message.binaryOptionsMarketIdsToCancelAll.map((e) => e);
    } else {
      obj.binaryOptionsMarketIdsToCancelAll = [];
    }
    if (message.binaryOptionsOrdersToCreate) {
      obj.binaryOptionsOrdersToCreate = message.binaryOptionsOrdersToCreate.map((e) =>
        e ? DerivativeOrder.toJSON(e) : undefined
      );
    } else {
      obj.binaryOptionsOrdersToCreate = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchUpdateOrders>): MsgBatchUpdateOrders {
    return MsgBatchUpdateOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchUpdateOrders>): MsgBatchUpdateOrders {
    const message = createBaseMsgBatchUpdateOrders();
    message.sender = object.sender ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.spotMarketIdsToCancelAll = object.spotMarketIdsToCancelAll?.map((e) => e) || [];
    message.derivativeMarketIdsToCancelAll = object.derivativeMarketIdsToCancelAll?.map((e) => e) || [];
    message.spotOrdersToCancel = object.spotOrdersToCancel?.map((e) => OrderData.fromPartial(e)) || [];
    message.derivativeOrdersToCancel = object.derivativeOrdersToCancel?.map((e) => OrderData.fromPartial(e)) || [];
    message.spotOrdersToCreate = object.spotOrdersToCreate?.map((e) => SpotOrder.fromPartial(e)) || [];
    message.derivativeOrdersToCreate = object.derivativeOrdersToCreate?.map((e) => DerivativeOrder.fromPartial(e)) ||
      [];
    message.binaryOptionsOrdersToCancel = object.binaryOptionsOrdersToCancel?.map((e) => OrderData.fromPartial(e)) ||
      [];
    message.binaryOptionsMarketIdsToCancelAll = object.binaryOptionsMarketIdsToCancelAll?.map((e) => e) || [];
    message.binaryOptionsOrdersToCreate =
      object.binaryOptionsOrdersToCreate?.map((e) => DerivativeOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchUpdateOrdersResponse(): MsgBatchUpdateOrdersResponse {
  return {
    spotCancelSuccess: [],
    derivativeCancelSuccess: [],
    spotOrderHashes: [],
    derivativeOrderHashes: [],
    binaryOptionsCancelSuccess: [],
    binaryOptionsOrderHashes: [],
  };
}

export const MsgBatchUpdateOrdersResponse = {
  encode(message: MsgBatchUpdateOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.spotCancelSuccess) {
      writer.bool(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.derivativeCancelSuccess) {
      writer.bool(v);
    }
    writer.ldelim();
    for (const v of message.spotOrderHashes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.derivativeOrderHashes) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.binaryOptionsCancelSuccess) {
      writer.bool(v);
    }
    writer.ldelim();
    for (const v of message.binaryOptionsOrderHashes) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchUpdateOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchUpdateOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.spotCancelSuccess.push(reader.bool());
            }
          } else {
            message.spotCancelSuccess.push(reader.bool());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.derivativeCancelSuccess.push(reader.bool());
            }
          } else {
            message.derivativeCancelSuccess.push(reader.bool());
          }
          break;
        case 3:
          message.spotOrderHashes.push(reader.string());
          break;
        case 4:
          message.derivativeOrderHashes.push(reader.string());
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.binaryOptionsCancelSuccess.push(reader.bool());
            }
          } else {
            message.binaryOptionsCancelSuccess.push(reader.bool());
          }
          break;
        case 6:
          message.binaryOptionsOrderHashes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchUpdateOrdersResponse {
    return {
      spotCancelSuccess: Array.isArray(object?.spotCancelSuccess)
        ? object.spotCancelSuccess.map((e: any) => Boolean(e))
        : [],
      derivativeCancelSuccess: Array.isArray(object?.derivativeCancelSuccess)
        ? object.derivativeCancelSuccess.map((e: any) => Boolean(e))
        : [],
      spotOrderHashes: Array.isArray(object?.spotOrderHashes) ? object.spotOrderHashes.map((e: any) => String(e)) : [],
      derivativeOrderHashes: Array.isArray(object?.derivativeOrderHashes)
        ? object.derivativeOrderHashes.map((e: any) => String(e))
        : [],
      binaryOptionsCancelSuccess: Array.isArray(object?.binaryOptionsCancelSuccess)
        ? object.binaryOptionsCancelSuccess.map((e: any) => Boolean(e))
        : [],
      binaryOptionsOrderHashes: Array.isArray(object?.binaryOptionsOrderHashes)
        ? object.binaryOptionsOrderHashes.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgBatchUpdateOrdersResponse): unknown {
    const obj: any = {};
    if (message.spotCancelSuccess) {
      obj.spotCancelSuccess = message.spotCancelSuccess.map((e) => e);
    } else {
      obj.spotCancelSuccess = [];
    }
    if (message.derivativeCancelSuccess) {
      obj.derivativeCancelSuccess = message.derivativeCancelSuccess.map((e) => e);
    } else {
      obj.derivativeCancelSuccess = [];
    }
    if (message.spotOrderHashes) {
      obj.spotOrderHashes = message.spotOrderHashes.map((e) => e);
    } else {
      obj.spotOrderHashes = [];
    }
    if (message.derivativeOrderHashes) {
      obj.derivativeOrderHashes = message.derivativeOrderHashes.map((e) => e);
    } else {
      obj.derivativeOrderHashes = [];
    }
    if (message.binaryOptionsCancelSuccess) {
      obj.binaryOptionsCancelSuccess = message.binaryOptionsCancelSuccess.map((e) => e);
    } else {
      obj.binaryOptionsCancelSuccess = [];
    }
    if (message.binaryOptionsOrderHashes) {
      obj.binaryOptionsOrderHashes = message.binaryOptionsOrderHashes.map((e) => e);
    } else {
      obj.binaryOptionsOrderHashes = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchUpdateOrdersResponse>): MsgBatchUpdateOrdersResponse {
    return MsgBatchUpdateOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchUpdateOrdersResponse>): MsgBatchUpdateOrdersResponse {
    const message = createBaseMsgBatchUpdateOrdersResponse();
    message.spotCancelSuccess = object.spotCancelSuccess?.map((e) => e) || [];
    message.derivativeCancelSuccess = object.derivativeCancelSuccess?.map((e) => e) || [];
    message.spotOrderHashes = object.spotOrderHashes?.map((e) => e) || [];
    message.derivativeOrderHashes = object.derivativeOrderHashes?.map((e) => e) || [];
    message.binaryOptionsCancelSuccess = object.binaryOptionsCancelSuccess?.map((e) => e) || [];
    message.binaryOptionsOrderHashes = object.binaryOptionsOrderHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgCreateDerivativeMarketOrder(): MsgCreateDerivativeMarketOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateDerivativeMarketOrder = {
  encode(message: MsgCreateDerivativeMarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      DerivativeOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDerivativeMarketOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDerivativeMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = DerivativeOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDerivativeMarketOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? DerivativeOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateDerivativeMarketOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? DerivativeOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateDerivativeMarketOrder>): MsgCreateDerivativeMarketOrder {
    return MsgCreateDerivativeMarketOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateDerivativeMarketOrder>): MsgCreateDerivativeMarketOrder {
    const message = createBaseMsgCreateDerivativeMarketOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateDerivativeMarketOrderResponse(): MsgCreateDerivativeMarketOrderResponse {
  return { orderHash: "", results: undefined };
}

export const MsgCreateDerivativeMarketOrderResponse = {
  encode(message: MsgCreateDerivativeMarketOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.results !== undefined) {
      DerivativeMarketOrderResults.encode(message.results, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDerivativeMarketOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDerivativeMarketOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.results = DerivativeMarketOrderResults.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDerivativeMarketOrderResponse {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      results: isSet(object.results) ? DerivativeMarketOrderResults.fromJSON(object.results) : undefined,
    };
  },

  toJSON(message: MsgCreateDerivativeMarketOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.results !== undefined &&
      (obj.results = message.results ? DerivativeMarketOrderResults.toJSON(message.results) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateDerivativeMarketOrderResponse>): MsgCreateDerivativeMarketOrderResponse {
    return MsgCreateDerivativeMarketOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateDerivativeMarketOrderResponse>): MsgCreateDerivativeMarketOrderResponse {
    const message = createBaseMsgCreateDerivativeMarketOrderResponse();
    message.orderHash = object.orderHash ?? "";
    message.results = (object.results !== undefined && object.results !== null)
      ? DerivativeMarketOrderResults.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseDerivativeMarketOrderResults(): DerivativeMarketOrderResults {
  return { quantity: "", price: "", fee: "", positionDelta: undefined, payout: "" };
}

export const DerivativeMarketOrderResults = {
  encode(message: DerivativeMarketOrderResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.quantity !== "") {
      writer.uint32(10).string(message.quantity);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.fee !== "") {
      writer.uint32(26).string(message.fee);
    }
    if (message.positionDelta !== undefined) {
      PositionDelta.encode(message.positionDelta, writer.uint32(34).fork()).ldelim();
    }
    if (message.payout !== "") {
      writer.uint32(42).string(message.payout);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketOrderResults {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarketOrderResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quantity = reader.string();
          break;
        case 2:
          message.price = reader.string();
          break;
        case 3:
          message.fee = reader.string();
          break;
        case 4:
          message.positionDelta = PositionDelta.decode(reader, reader.uint32());
          break;
        case 5:
          message.payout = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarketOrderResults {
    return {
      quantity: isSet(object.quantity) ? String(object.quantity) : "",
      price: isSet(object.price) ? String(object.price) : "",
      fee: isSet(object.fee) ? String(object.fee) : "",
      positionDelta: isSet(object.positionDelta) ? PositionDelta.fromJSON(object.positionDelta) : undefined,
      payout: isSet(object.payout) ? String(object.payout) : "",
    };
  },

  toJSON(message: DerivativeMarketOrderResults): unknown {
    const obj: any = {};
    message.quantity !== undefined && (obj.quantity = message.quantity);
    message.price !== undefined && (obj.price = message.price);
    message.fee !== undefined && (obj.fee = message.fee);
    message.positionDelta !== undefined &&
      (obj.positionDelta = message.positionDelta ? PositionDelta.toJSON(message.positionDelta) : undefined);
    message.payout !== undefined && (obj.payout = message.payout);
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarketOrderResults>): DerivativeMarketOrderResults {
    return DerivativeMarketOrderResults.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarketOrderResults>): DerivativeMarketOrderResults {
    const message = createBaseDerivativeMarketOrderResults();
    message.quantity = object.quantity ?? "";
    message.price = object.price ?? "";
    message.fee = object.fee ?? "";
    message.positionDelta = (object.positionDelta !== undefined && object.positionDelta !== null)
      ? PositionDelta.fromPartial(object.positionDelta)
      : undefined;
    message.payout = object.payout ?? "";
    return message;
  },
};

function createBaseMsgCreateBinaryOptionsMarketOrder(): MsgCreateBinaryOptionsMarketOrder {
  return { sender: "", order: undefined };
}

export const MsgCreateBinaryOptionsMarketOrder = {
  encode(message: MsgCreateBinaryOptionsMarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.order !== undefined) {
      DerivativeOrder.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBinaryOptionsMarketOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBinaryOptionsMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.order = DerivativeOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBinaryOptionsMarketOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      order: isSet(object.order) ? DerivativeOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgCreateBinaryOptionsMarketOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.order !== undefined && (obj.order = message.order ? DerivativeOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateBinaryOptionsMarketOrder>): MsgCreateBinaryOptionsMarketOrder {
    return MsgCreateBinaryOptionsMarketOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCreateBinaryOptionsMarketOrder>): MsgCreateBinaryOptionsMarketOrder {
    const message = createBaseMsgCreateBinaryOptionsMarketOrder();
    message.sender = object.sender ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateBinaryOptionsMarketOrderResponse(): MsgCreateBinaryOptionsMarketOrderResponse {
  return { orderHash: "", results: undefined };
}

export const MsgCreateBinaryOptionsMarketOrderResponse = {
  encode(message: MsgCreateBinaryOptionsMarketOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderHash !== "") {
      writer.uint32(10).string(message.orderHash);
    }
    if (message.results !== undefined) {
      DerivativeMarketOrderResults.encode(message.results, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBinaryOptionsMarketOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBinaryOptionsMarketOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.orderHash = reader.string();
          break;
        case 2:
          message.results = DerivativeMarketOrderResults.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBinaryOptionsMarketOrderResponse {
    return {
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      results: isSet(object.results) ? DerivativeMarketOrderResults.fromJSON(object.results) : undefined,
    };
  },

  toJSON(message: MsgCreateBinaryOptionsMarketOrderResponse): unknown {
    const obj: any = {};
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.results !== undefined &&
      (obj.results = message.results ? DerivativeMarketOrderResults.toJSON(message.results) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgCreateBinaryOptionsMarketOrderResponse>): MsgCreateBinaryOptionsMarketOrderResponse {
    return MsgCreateBinaryOptionsMarketOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<MsgCreateBinaryOptionsMarketOrderResponse>,
  ): MsgCreateBinaryOptionsMarketOrderResponse {
    const message = createBaseMsgCreateBinaryOptionsMarketOrderResponse();
    message.orderHash = object.orderHash ?? "";
    message.results = (object.results !== undefined && object.results !== null)
      ? DerivativeMarketOrderResults.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseMsgCancelDerivativeOrder(): MsgCancelDerivativeOrder {
  return { sender: "", marketId: "", subaccountId: "", orderHash: "", orderMask: 0 };
}

export const MsgCancelDerivativeOrder = {
  encode(message: MsgCancelDerivativeOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.orderHash !== "") {
      writer.uint32(34).string(message.orderHash);
    }
    if (message.orderMask !== 0) {
      writer.uint32(40).int32(message.orderMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelDerivativeOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelDerivativeOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.orderHash = reader.string();
          break;
        case 5:
          message.orderMask = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCancelDerivativeOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      orderMask: isSet(object.orderMask) ? Number(object.orderMask) : 0,
    };
  },

  toJSON(message: MsgCancelDerivativeOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.orderMask !== undefined && (obj.orderMask = Math.round(message.orderMask));
    return obj;
  },

  create(base?: DeepPartial<MsgCancelDerivativeOrder>): MsgCancelDerivativeOrder {
    return MsgCancelDerivativeOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCancelDerivativeOrder>): MsgCancelDerivativeOrder {
    const message = createBaseMsgCancelDerivativeOrder();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHash = object.orderHash ?? "";
    message.orderMask = object.orderMask ?? 0;
    return message;
  },
};

function createBaseMsgCancelDerivativeOrderResponse(): MsgCancelDerivativeOrderResponse {
  return {};
}

export const MsgCancelDerivativeOrderResponse = {
  encode(_: MsgCancelDerivativeOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelDerivativeOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelDerivativeOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCancelDerivativeOrderResponse {
    return {};
  },

  toJSON(_: MsgCancelDerivativeOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelDerivativeOrderResponse>): MsgCancelDerivativeOrderResponse {
    return MsgCancelDerivativeOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgCancelDerivativeOrderResponse>): MsgCancelDerivativeOrderResponse {
    const message = createBaseMsgCancelDerivativeOrderResponse();
    return message;
  },
};

function createBaseMsgCancelBinaryOptionsOrder(): MsgCancelBinaryOptionsOrder {
  return { sender: "", marketId: "", subaccountId: "", orderHash: "", orderMask: 0 };
}

export const MsgCancelBinaryOptionsOrder = {
  encode(message: MsgCancelBinaryOptionsOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(26).string(message.subaccountId);
    }
    if (message.orderHash !== "") {
      writer.uint32(34).string(message.orderHash);
    }
    if (message.orderMask !== 0) {
      writer.uint32(40).int32(message.orderMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelBinaryOptionsOrder {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelBinaryOptionsOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.subaccountId = reader.string();
          break;
        case 4:
          message.orderHash = reader.string();
          break;
        case 5:
          message.orderMask = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCancelBinaryOptionsOrder {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      orderMask: isSet(object.orderMask) ? Number(object.orderMask) : 0,
    };
  },

  toJSON(message: MsgCancelBinaryOptionsOrder): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.orderMask !== undefined && (obj.orderMask = Math.round(message.orderMask));
    return obj;
  },

  create(base?: DeepPartial<MsgCancelBinaryOptionsOrder>): MsgCancelBinaryOptionsOrder {
    return MsgCancelBinaryOptionsOrder.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgCancelBinaryOptionsOrder>): MsgCancelBinaryOptionsOrder {
    const message = createBaseMsgCancelBinaryOptionsOrder();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHash = object.orderHash ?? "";
    message.orderMask = object.orderMask ?? 0;
    return message;
  },
};

function createBaseMsgCancelBinaryOptionsOrderResponse(): MsgCancelBinaryOptionsOrderResponse {
  return {};
}

export const MsgCancelBinaryOptionsOrderResponse = {
  encode(_: MsgCancelBinaryOptionsOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelBinaryOptionsOrderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelBinaryOptionsOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCancelBinaryOptionsOrderResponse {
    return {};
  },

  toJSON(_: MsgCancelBinaryOptionsOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelBinaryOptionsOrderResponse>): MsgCancelBinaryOptionsOrderResponse {
    return MsgCancelBinaryOptionsOrderResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgCancelBinaryOptionsOrderResponse>): MsgCancelBinaryOptionsOrderResponse {
    const message = createBaseMsgCancelBinaryOptionsOrderResponse();
    return message;
  },
};

function createBaseOrderData(): OrderData {
  return { marketId: "", subaccountId: "", orderHash: "", orderMask: 0 };
}

export const OrderData = {
  encode(message: OrderData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.orderHash !== "") {
      writer.uint32(26).string(message.orderHash);
    }
    if (message.orderMask !== 0) {
      writer.uint32(32).int32(message.orderMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.marketId = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.orderHash = reader.string();
          break;
        case 4:
          message.orderMask = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OrderData {
    return {
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      orderHash: isSet(object.orderHash) ? String(object.orderHash) : "",
      orderMask: isSet(object.orderMask) ? Number(object.orderMask) : 0,
    };
  },

  toJSON(message: OrderData): unknown {
    const obj: any = {};
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.orderHash !== undefined && (obj.orderHash = message.orderHash);
    message.orderMask !== undefined && (obj.orderMask = Math.round(message.orderMask));
    return obj;
  },

  create(base?: DeepPartial<OrderData>): OrderData {
    return OrderData.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OrderData>): OrderData {
    const message = createBaseOrderData();
    message.marketId = object.marketId ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.orderHash = object.orderHash ?? "";
    message.orderMask = object.orderMask ?? 0;
    return message;
  },
};

function createBaseMsgBatchCancelDerivativeOrders(): MsgBatchCancelDerivativeOrders {
  return { sender: "", data: [] };
}

export const MsgBatchCancelDerivativeOrders = {
  encode(message: MsgBatchCancelDerivativeOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.data) {
      OrderData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelDerivativeOrders {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelDerivativeOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.data.push(OrderData.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelDerivativeOrders {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      data: Array.isArray(object?.data) ? object.data.map((e: any) => OrderData.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgBatchCancelDerivativeOrders): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    if (message.data) {
      obj.data = message.data.map((e) => e ? OrderData.toJSON(e) : undefined);
    } else {
      obj.data = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelDerivativeOrders>): MsgBatchCancelDerivativeOrders {
    return MsgBatchCancelDerivativeOrders.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCancelDerivativeOrders>): MsgBatchCancelDerivativeOrders {
    const message = createBaseMsgBatchCancelDerivativeOrders();
    message.sender = object.sender ?? "";
    message.data = object.data?.map((e) => OrderData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgBatchCancelDerivativeOrdersResponse(): MsgBatchCancelDerivativeOrdersResponse {
  return { success: [] };
}

export const MsgBatchCancelDerivativeOrdersResponse = {
  encode(message: MsgBatchCancelDerivativeOrdersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.success) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBatchCancelDerivativeOrdersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBatchCancelDerivativeOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.success.push(reader.bool());
            }
          } else {
            message.success.push(reader.bool());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBatchCancelDerivativeOrdersResponse {
    return { success: Array.isArray(object?.success) ? object.success.map((e: any) => Boolean(e)) : [] };
  },

  toJSON(message: MsgBatchCancelDerivativeOrdersResponse): unknown {
    const obj: any = {};
    if (message.success) {
      obj.success = message.success.map((e) => e);
    } else {
      obj.success = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgBatchCancelDerivativeOrdersResponse>): MsgBatchCancelDerivativeOrdersResponse {
    return MsgBatchCancelDerivativeOrdersResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgBatchCancelDerivativeOrdersResponse>): MsgBatchCancelDerivativeOrdersResponse {
    const message = createBaseMsgBatchCancelDerivativeOrdersResponse();
    message.success = object.success?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSubaccountTransfer(): MsgSubaccountTransfer {
  return { sender: "", sourceSubaccountId: "", destinationSubaccountId: "", amount: undefined };
}

export const MsgSubaccountTransfer = {
  encode(message: MsgSubaccountTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.sourceSubaccountId !== "") {
      writer.uint32(18).string(message.sourceSubaccountId);
    }
    if (message.destinationSubaccountId !== "") {
      writer.uint32(26).string(message.destinationSubaccountId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubaccountTransfer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubaccountTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.sourceSubaccountId = reader.string();
          break;
        case 3:
          message.destinationSubaccountId = reader.string();
          break;
        case 4:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSubaccountTransfer {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      sourceSubaccountId: isSet(object.sourceSubaccountId) ? String(object.sourceSubaccountId) : "",
      destinationSubaccountId: isSet(object.destinationSubaccountId) ? String(object.destinationSubaccountId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgSubaccountTransfer): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.sourceSubaccountId !== undefined && (obj.sourceSubaccountId = message.sourceSubaccountId);
    message.destinationSubaccountId !== undefined && (obj.destinationSubaccountId = message.destinationSubaccountId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgSubaccountTransfer>): MsgSubaccountTransfer {
    return MsgSubaccountTransfer.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgSubaccountTransfer>): MsgSubaccountTransfer {
    const message = createBaseMsgSubaccountTransfer();
    message.sender = object.sender ?? "";
    message.sourceSubaccountId = object.sourceSubaccountId ?? "";
    message.destinationSubaccountId = object.destinationSubaccountId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgSubaccountTransferResponse(): MsgSubaccountTransferResponse {
  return {};
}

export const MsgSubaccountTransferResponse = {
  encode(_: MsgSubaccountTransferResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSubaccountTransferResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubaccountTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgSubaccountTransferResponse {
    return {};
  },

  toJSON(_: MsgSubaccountTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgSubaccountTransferResponse>): MsgSubaccountTransferResponse {
    return MsgSubaccountTransferResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgSubaccountTransferResponse>): MsgSubaccountTransferResponse {
    const message = createBaseMsgSubaccountTransferResponse();
    return message;
  },
};

function createBaseMsgExternalTransfer(): MsgExternalTransfer {
  return { sender: "", sourceSubaccountId: "", destinationSubaccountId: "", amount: undefined };
}

export const MsgExternalTransfer = {
  encode(message: MsgExternalTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.sourceSubaccountId !== "") {
      writer.uint32(18).string(message.sourceSubaccountId);
    }
    if (message.destinationSubaccountId !== "") {
      writer.uint32(26).string(message.destinationSubaccountId);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExternalTransfer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExternalTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.sourceSubaccountId = reader.string();
          break;
        case 3:
          message.destinationSubaccountId = reader.string();
          break;
        case 4:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgExternalTransfer {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      sourceSubaccountId: isSet(object.sourceSubaccountId) ? String(object.sourceSubaccountId) : "",
      destinationSubaccountId: isSet(object.destinationSubaccountId) ? String(object.destinationSubaccountId) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgExternalTransfer): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.sourceSubaccountId !== undefined && (obj.sourceSubaccountId = message.sourceSubaccountId);
    message.destinationSubaccountId !== undefined && (obj.destinationSubaccountId = message.destinationSubaccountId);
    message.amount !== undefined && (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgExternalTransfer>): MsgExternalTransfer {
    return MsgExternalTransfer.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgExternalTransfer>): MsgExternalTransfer {
    const message = createBaseMsgExternalTransfer();
    message.sender = object.sender ?? "";
    message.sourceSubaccountId = object.sourceSubaccountId ?? "";
    message.destinationSubaccountId = object.destinationSubaccountId ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgExternalTransferResponse(): MsgExternalTransferResponse {
  return {};
}

export const MsgExternalTransferResponse = {
  encode(_: MsgExternalTransferResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgExternalTransferResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExternalTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgExternalTransferResponse {
    return {};
  },

  toJSON(_: MsgExternalTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgExternalTransferResponse>): MsgExternalTransferResponse {
    return MsgExternalTransferResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgExternalTransferResponse>): MsgExternalTransferResponse {
    const message = createBaseMsgExternalTransferResponse();
    return message;
  },
};

function createBaseMsgLiquidatePosition(): MsgLiquidatePosition {
  return { sender: "", subaccountId: "", marketId: "", order: undefined };
}

export const MsgLiquidatePosition = {
  encode(message: MsgLiquidatePosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.subaccountId !== "") {
      writer.uint32(18).string(message.subaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.order !== undefined) {
      DerivativeOrder.encode(message.order, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgLiquidatePosition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgLiquidatePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.subaccountId = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.order = DerivativeOrder.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgLiquidatePosition {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      subaccountId: isSet(object.subaccountId) ? String(object.subaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      order: isSet(object.order) ? DerivativeOrder.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: MsgLiquidatePosition): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.subaccountId !== undefined && (obj.subaccountId = message.subaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.order !== undefined && (obj.order = message.order ? DerivativeOrder.toJSON(message.order) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgLiquidatePosition>): MsgLiquidatePosition {
    return MsgLiquidatePosition.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgLiquidatePosition>): MsgLiquidatePosition {
    const message = createBaseMsgLiquidatePosition();
    message.sender = object.sender ?? "";
    message.subaccountId = object.subaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? DerivativeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMsgLiquidatePositionResponse(): MsgLiquidatePositionResponse {
  return {};
}

export const MsgLiquidatePositionResponse = {
  encode(_: MsgLiquidatePositionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgLiquidatePositionResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgLiquidatePositionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgLiquidatePositionResponse {
    return {};
  },

  toJSON(_: MsgLiquidatePositionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgLiquidatePositionResponse>): MsgLiquidatePositionResponse {
    return MsgLiquidatePositionResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgLiquidatePositionResponse>): MsgLiquidatePositionResponse {
    const message = createBaseMsgLiquidatePositionResponse();
    return message;
  },
};

function createBaseMsgIncreasePositionMargin(): MsgIncreasePositionMargin {
  return { sender: "", sourceSubaccountId: "", destinationSubaccountId: "", marketId: "", amount: "" };
}

export const MsgIncreasePositionMargin = {
  encode(message: MsgIncreasePositionMargin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.sourceSubaccountId !== "") {
      writer.uint32(18).string(message.sourceSubaccountId);
    }
    if (message.destinationSubaccountId !== "") {
      writer.uint32(26).string(message.destinationSubaccountId);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgIncreasePositionMargin {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIncreasePositionMargin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.sourceSubaccountId = reader.string();
          break;
        case 3:
          message.destinationSubaccountId = reader.string();
          break;
        case 4:
          message.marketId = reader.string();
          break;
        case 5:
          message.amount = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgIncreasePositionMargin {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      sourceSubaccountId: isSet(object.sourceSubaccountId) ? String(object.sourceSubaccountId) : "",
      destinationSubaccountId: isSet(object.destinationSubaccountId) ? String(object.destinationSubaccountId) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      amount: isSet(object.amount) ? String(object.amount) : "",
    };
  },

  toJSON(message: MsgIncreasePositionMargin): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.sourceSubaccountId !== undefined && (obj.sourceSubaccountId = message.sourceSubaccountId);
    message.destinationSubaccountId !== undefined && (obj.destinationSubaccountId = message.destinationSubaccountId);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.amount !== undefined && (obj.amount = message.amount);
    return obj;
  },

  create(base?: DeepPartial<MsgIncreasePositionMargin>): MsgIncreasePositionMargin {
    return MsgIncreasePositionMargin.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgIncreasePositionMargin>): MsgIncreasePositionMargin {
    const message = createBaseMsgIncreasePositionMargin();
    message.sender = object.sender ?? "";
    message.sourceSubaccountId = object.sourceSubaccountId ?? "";
    message.destinationSubaccountId = object.destinationSubaccountId ?? "";
    message.marketId = object.marketId ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgIncreasePositionMarginResponse(): MsgIncreasePositionMarginResponse {
  return {};
}

export const MsgIncreasePositionMarginResponse = {
  encode(_: MsgIncreasePositionMarginResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgIncreasePositionMarginResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIncreasePositionMarginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgIncreasePositionMarginResponse {
    return {};
  },

  toJSON(_: MsgIncreasePositionMarginResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgIncreasePositionMarginResponse>): MsgIncreasePositionMarginResponse {
    return MsgIncreasePositionMarginResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgIncreasePositionMarginResponse>): MsgIncreasePositionMarginResponse {
    const message = createBaseMsgIncreasePositionMarginResponse();
    return message;
  },
};

function createBaseMsgPrivilegedExecuteContract(): MsgPrivilegedExecuteContract {
  return { sender: "", funds: "", contractAddress: "", data: "" };
}

export const MsgPrivilegedExecuteContract = {
  encode(message: MsgPrivilegedExecuteContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.funds !== "") {
      writer.uint32(18).string(message.funds);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.data !== "") {
      writer.uint32(34).string(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgPrivilegedExecuteContract {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPrivilegedExecuteContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.funds = reader.string();
          break;
        case 3:
          message.contractAddress = reader.string();
          break;
        case 4:
          message.data = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPrivilegedExecuteContract {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      funds: isSet(object.funds) ? String(object.funds) : "",
      contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
      data: isSet(object.data) ? String(object.data) : "",
    };
  },

  toJSON(message: MsgPrivilegedExecuteContract): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.funds !== undefined && (obj.funds = message.funds);
    message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
    message.data !== undefined && (obj.data = message.data);
    return obj;
  },

  create(base?: DeepPartial<MsgPrivilegedExecuteContract>): MsgPrivilegedExecuteContract {
    return MsgPrivilegedExecuteContract.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgPrivilegedExecuteContract>): MsgPrivilegedExecuteContract {
    const message = createBaseMsgPrivilegedExecuteContract();
    message.sender = object.sender ?? "";
    message.funds = object.funds ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseMsgPrivilegedExecuteContractResponse(): MsgPrivilegedExecuteContractResponse {
  return { fundsDiff: [] };
}

export const MsgPrivilegedExecuteContractResponse = {
  encode(message: MsgPrivilegedExecuteContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fundsDiff) {
      Coin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgPrivilegedExecuteContractResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPrivilegedExecuteContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fundsDiff.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPrivilegedExecuteContractResponse {
    return { fundsDiff: Array.isArray(object?.fundsDiff) ? object.fundsDiff.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: MsgPrivilegedExecuteContractResponse): unknown {
    const obj: any = {};
    if (message.fundsDiff) {
      obj.fundsDiff = message.fundsDiff.map((e) => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.fundsDiff = [];
    }
    return obj;
  },

  create(base?: DeepPartial<MsgPrivilegedExecuteContractResponse>): MsgPrivilegedExecuteContractResponse {
    return MsgPrivilegedExecuteContractResponse.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgPrivilegedExecuteContractResponse>): MsgPrivilegedExecuteContractResponse {
    const message = createBaseMsgPrivilegedExecuteContractResponse();
    message.fundsDiff = object.fundsDiff?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpotMarketParamUpdateProposal(): SpotMarketParamUpdateProposal {
  return {
    title: "",
    description: "",
    marketId: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
    status: 0,
  };
}

export const SpotMarketParamUpdateProposal = {
  encode(message: SpotMarketParamUpdateProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(34).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(42).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(50).string(message.relayerFeeShareRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(58).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(66).string(message.minQuantityTickSize);
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketParamUpdateProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarketParamUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.makerFeeRate = reader.string();
          break;
        case 5:
          message.takerFeeRate = reader.string();
          break;
        case 6:
          message.relayerFeeShareRate = reader.string();
          break;
        case 7:
          message.minPriceTickSize = reader.string();
          break;
        case 8:
          message.minQuantityTickSize = reader.string();
          break;
        case 9:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarketParamUpdateProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: SpotMarketParamUpdateProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    return obj;
  },

  create(base?: DeepPartial<SpotMarketParamUpdateProposal>): SpotMarketParamUpdateProposal {
    return SpotMarketParamUpdateProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarketParamUpdateProposal>): SpotMarketParamUpdateProposal {
    const message = createBaseSpotMarketParamUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.marketId = object.marketId ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseExchangeEnableProposal(): ExchangeEnableProposal {
  return { title: "", description: "", exchangeType: 0 };
}

export const ExchangeEnableProposal = {
  encode(message: ExchangeEnableProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.exchangeType !== 0) {
      writer.uint32(24).int32(message.exchangeType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExchangeEnableProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeEnableProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.exchangeType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExchangeEnableProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      exchangeType: isSet(object.exchangeType) ? exchangeTypeFromJSON(object.exchangeType) : 0,
    };
  },

  toJSON(message: ExchangeEnableProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.exchangeType !== undefined && (obj.exchangeType = exchangeTypeToJSON(message.exchangeType));
    return obj;
  },

  create(base?: DeepPartial<ExchangeEnableProposal>): ExchangeEnableProposal {
    return ExchangeEnableProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ExchangeEnableProposal>): ExchangeEnableProposal {
    const message = createBaseExchangeEnableProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.exchangeType = object.exchangeType ?? 0;
    return message;
  },
};

function createBaseBatchExchangeModificationProposal(): BatchExchangeModificationProposal {
  return {
    title: "",
    description: "",
    spotMarketParamUpdateProposals: [],
    derivativeMarketParamUpdateProposals: [],
    spotMarketLaunchProposals: [],
    perpetualMarketLaunchProposals: [],
    expiryFuturesMarketLaunchProposals: [],
    tradingRewardCampaignUpdateProposal: undefined,
    binaryOptionsMarketLaunchProposals: [],
    binaryOptionsParamUpdateProposals: [],
    denomDecimalsUpdateProposal: undefined,
  };
}

export const BatchExchangeModificationProposal = {
  encode(message: BatchExchangeModificationProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.spotMarketParamUpdateProposals) {
      SpotMarketParamUpdateProposal.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.derivativeMarketParamUpdateProposals) {
      DerivativeMarketParamUpdateProposal.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.spotMarketLaunchProposals) {
      SpotMarketLaunchProposal.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.perpetualMarketLaunchProposals) {
      PerpetualMarketLaunchProposal.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.expiryFuturesMarketLaunchProposals) {
      ExpiryFuturesMarketLaunchProposal.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.tradingRewardCampaignUpdateProposal !== undefined) {
      TradingRewardCampaignUpdateProposal.encode(message.tradingRewardCampaignUpdateProposal, writer.uint32(66).fork())
        .ldelim();
    }
    for (const v of message.binaryOptionsMarketLaunchProposals) {
      BinaryOptionsMarketLaunchProposal.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.binaryOptionsParamUpdateProposals) {
      BinaryOptionsMarketParamUpdateProposal.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.denomDecimalsUpdateProposal !== undefined) {
      UpdateDenomDecimalsProposal.encode(message.denomDecimalsUpdateProposal, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchExchangeModificationProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchExchangeModificationProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.spotMarketParamUpdateProposals.push(SpotMarketParamUpdateProposal.decode(reader, reader.uint32()));
          break;
        case 4:
          message.derivativeMarketParamUpdateProposals.push(
            DerivativeMarketParamUpdateProposal.decode(reader, reader.uint32()),
          );
          break;
        case 5:
          message.spotMarketLaunchProposals.push(SpotMarketLaunchProposal.decode(reader, reader.uint32()));
          break;
        case 6:
          message.perpetualMarketLaunchProposals.push(PerpetualMarketLaunchProposal.decode(reader, reader.uint32()));
          break;
        case 7:
          message.expiryFuturesMarketLaunchProposals.push(
            ExpiryFuturesMarketLaunchProposal.decode(reader, reader.uint32()),
          );
          break;
        case 8:
          message.tradingRewardCampaignUpdateProposal = TradingRewardCampaignUpdateProposal.decode(
            reader,
            reader.uint32(),
          );
          break;
        case 9:
          message.binaryOptionsMarketLaunchProposals.push(
            BinaryOptionsMarketLaunchProposal.decode(reader, reader.uint32()),
          );
          break;
        case 10:
          message.binaryOptionsParamUpdateProposals.push(
            BinaryOptionsMarketParamUpdateProposal.decode(reader, reader.uint32()),
          );
          break;
        case 11:
          message.denomDecimalsUpdateProposal = UpdateDenomDecimalsProposal.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BatchExchangeModificationProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      spotMarketParamUpdateProposals: Array.isArray(object?.spotMarketParamUpdateProposals)
        ? object.spotMarketParamUpdateProposals.map((e: any) => SpotMarketParamUpdateProposal.fromJSON(e))
        : [],
      derivativeMarketParamUpdateProposals: Array.isArray(object?.derivativeMarketParamUpdateProposals)
        ? object.derivativeMarketParamUpdateProposals.map((e: any) => DerivativeMarketParamUpdateProposal.fromJSON(e))
        : [],
      spotMarketLaunchProposals: Array.isArray(object?.spotMarketLaunchProposals)
        ? object.spotMarketLaunchProposals.map((e: any) => SpotMarketLaunchProposal.fromJSON(e))
        : [],
      perpetualMarketLaunchProposals: Array.isArray(object?.perpetualMarketLaunchProposals)
        ? object.perpetualMarketLaunchProposals.map((e: any) => PerpetualMarketLaunchProposal.fromJSON(e))
        : [],
      expiryFuturesMarketLaunchProposals: Array.isArray(object?.expiryFuturesMarketLaunchProposals)
        ? object.expiryFuturesMarketLaunchProposals.map((e: any) => ExpiryFuturesMarketLaunchProposal.fromJSON(e))
        : [],
      tradingRewardCampaignUpdateProposal: isSet(object.tradingRewardCampaignUpdateProposal)
        ? TradingRewardCampaignUpdateProposal.fromJSON(object.tradingRewardCampaignUpdateProposal)
        : undefined,
      binaryOptionsMarketLaunchProposals: Array.isArray(object?.binaryOptionsMarketLaunchProposals)
        ? object.binaryOptionsMarketLaunchProposals.map((e: any) => BinaryOptionsMarketLaunchProposal.fromJSON(e))
        : [],
      binaryOptionsParamUpdateProposals: Array.isArray(object?.binaryOptionsParamUpdateProposals)
        ? object.binaryOptionsParamUpdateProposals.map((e: any) => BinaryOptionsMarketParamUpdateProposal.fromJSON(e))
        : [],
      denomDecimalsUpdateProposal: isSet(object.denomDecimalsUpdateProposal)
        ? UpdateDenomDecimalsProposal.fromJSON(object.denomDecimalsUpdateProposal)
        : undefined,
    };
  },

  toJSON(message: BatchExchangeModificationProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.spotMarketParamUpdateProposals) {
      obj.spotMarketParamUpdateProposals = message.spotMarketParamUpdateProposals.map((e) =>
        e ? SpotMarketParamUpdateProposal.toJSON(e) : undefined
      );
    } else {
      obj.spotMarketParamUpdateProposals = [];
    }
    if (message.derivativeMarketParamUpdateProposals) {
      obj.derivativeMarketParamUpdateProposals = message.derivativeMarketParamUpdateProposals.map((e) =>
        e ? DerivativeMarketParamUpdateProposal.toJSON(e) : undefined
      );
    } else {
      obj.derivativeMarketParamUpdateProposals = [];
    }
    if (message.spotMarketLaunchProposals) {
      obj.spotMarketLaunchProposals = message.spotMarketLaunchProposals.map((e) =>
        e ? SpotMarketLaunchProposal.toJSON(e) : undefined
      );
    } else {
      obj.spotMarketLaunchProposals = [];
    }
    if (message.perpetualMarketLaunchProposals) {
      obj.perpetualMarketLaunchProposals = message.perpetualMarketLaunchProposals.map((e) =>
        e ? PerpetualMarketLaunchProposal.toJSON(e) : undefined
      );
    } else {
      obj.perpetualMarketLaunchProposals = [];
    }
    if (message.expiryFuturesMarketLaunchProposals) {
      obj.expiryFuturesMarketLaunchProposals = message.expiryFuturesMarketLaunchProposals.map((e) =>
        e ? ExpiryFuturesMarketLaunchProposal.toJSON(e) : undefined
      );
    } else {
      obj.expiryFuturesMarketLaunchProposals = [];
    }
    message.tradingRewardCampaignUpdateProposal !== undefined &&
      (obj.tradingRewardCampaignUpdateProposal = message.tradingRewardCampaignUpdateProposal
        ? TradingRewardCampaignUpdateProposal.toJSON(message.tradingRewardCampaignUpdateProposal)
        : undefined);
    if (message.binaryOptionsMarketLaunchProposals) {
      obj.binaryOptionsMarketLaunchProposals = message.binaryOptionsMarketLaunchProposals.map((e) =>
        e ? BinaryOptionsMarketLaunchProposal.toJSON(e) : undefined
      );
    } else {
      obj.binaryOptionsMarketLaunchProposals = [];
    }
    if (message.binaryOptionsParamUpdateProposals) {
      obj.binaryOptionsParamUpdateProposals = message.binaryOptionsParamUpdateProposals.map((e) =>
        e ? BinaryOptionsMarketParamUpdateProposal.toJSON(e) : undefined
      );
    } else {
      obj.binaryOptionsParamUpdateProposals = [];
    }
    message.denomDecimalsUpdateProposal !== undefined &&
      (obj.denomDecimalsUpdateProposal = message.denomDecimalsUpdateProposal
        ? UpdateDenomDecimalsProposal.toJSON(message.denomDecimalsUpdateProposal)
        : undefined);
    return obj;
  },

  create(base?: DeepPartial<BatchExchangeModificationProposal>): BatchExchangeModificationProposal {
    return BatchExchangeModificationProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BatchExchangeModificationProposal>): BatchExchangeModificationProposal {
    const message = createBaseBatchExchangeModificationProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.spotMarketParamUpdateProposals =
      object.spotMarketParamUpdateProposals?.map((e) => SpotMarketParamUpdateProposal.fromPartial(e)) || [];
    message.derivativeMarketParamUpdateProposals =
      object.derivativeMarketParamUpdateProposals?.map((e) => DerivativeMarketParamUpdateProposal.fromPartial(e)) || [];
    message.spotMarketLaunchProposals =
      object.spotMarketLaunchProposals?.map((e) => SpotMarketLaunchProposal.fromPartial(e)) || [];
    message.perpetualMarketLaunchProposals =
      object.perpetualMarketLaunchProposals?.map((e) => PerpetualMarketLaunchProposal.fromPartial(e)) || [];
    message.expiryFuturesMarketLaunchProposals =
      object.expiryFuturesMarketLaunchProposals?.map((e) => ExpiryFuturesMarketLaunchProposal.fromPartial(e)) || [];
    message.tradingRewardCampaignUpdateProposal =
      (object.tradingRewardCampaignUpdateProposal !== undefined && object.tradingRewardCampaignUpdateProposal !== null)
        ? TradingRewardCampaignUpdateProposal.fromPartial(object.tradingRewardCampaignUpdateProposal)
        : undefined;
    message.binaryOptionsMarketLaunchProposals =
      object.binaryOptionsMarketLaunchProposals?.map((e) => BinaryOptionsMarketLaunchProposal.fromPartial(e)) || [];
    message.binaryOptionsParamUpdateProposals =
      object.binaryOptionsParamUpdateProposals?.map((e) => BinaryOptionsMarketParamUpdateProposal.fromPartial(e)) || [];
    message.denomDecimalsUpdateProposal =
      (object.denomDecimalsUpdateProposal !== undefined && object.denomDecimalsUpdateProposal !== null)
        ? UpdateDenomDecimalsProposal.fromPartial(object.denomDecimalsUpdateProposal)
        : undefined;
    return message;
  },
};

function createBaseSpotMarketLaunchProposal(): SpotMarketLaunchProposal {
  return {
    title: "",
    description: "",
    ticker: "",
    baseDenom: "",
    quoteDenom: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
    makerFeeRate: "",
    takerFeeRate: "",
  };
}

export const SpotMarketLaunchProposal = {
  encode(message: SpotMarketLaunchProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.baseDenom !== "") {
      writer.uint32(34).string(message.baseDenom);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(42).string(message.quoteDenom);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(50).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(58).string(message.minQuantityTickSize);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(66).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(74).string(message.takerFeeRate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpotMarketLaunchProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotMarketLaunchProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.baseDenom = reader.string();
          break;
        case 5:
          message.quoteDenom = reader.string();
          break;
        case 6:
          message.minPriceTickSize = reader.string();
          break;
        case 7:
          message.minQuantityTickSize = reader.string();
          break;
        case 8:
          message.makerFeeRate = reader.string();
          break;
        case 9:
          message.takerFeeRate = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpotMarketLaunchProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      baseDenom: isSet(object.baseDenom) ? String(object.baseDenom) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
    };
  },

  toJSON(message: SpotMarketLaunchProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.baseDenom !== undefined && (obj.baseDenom = message.baseDenom);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    return obj;
  },

  create(base?: DeepPartial<SpotMarketLaunchProposal>): SpotMarketLaunchProposal {
    return SpotMarketLaunchProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<SpotMarketLaunchProposal>): SpotMarketLaunchProposal {
    const message = createBaseSpotMarketLaunchProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.ticker = object.ticker ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    return message;
  },
};

function createBasePerpetualMarketLaunchProposal(): PerpetualMarketLaunchProposal {
  return {
    title: "",
    description: "",
    ticker: "",
    quoteDenom: "",
    oracleBase: "",
    oracleQuote: "",
    oracleScaleFactor: 0,
    oracleType: 0,
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    makerFeeRate: "",
    takerFeeRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const PerpetualMarketLaunchProposal = {
  encode(message: PerpetualMarketLaunchProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(34).string(message.quoteDenom);
    }
    if (message.oracleBase !== "") {
      writer.uint32(42).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(50).string(message.oracleQuote);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.oracleType !== 0) {
      writer.uint32(64).int32(message.oracleType);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(74).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(82).string(message.maintenanceMarginRatio);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(90).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(98).string(message.takerFeeRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(106).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(114).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PerpetualMarketLaunchProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerpetualMarketLaunchProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.quoteDenom = reader.string();
          break;
        case 5:
          message.oracleBase = reader.string();
          break;
        case 6:
          message.oracleQuote = reader.string();
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.oracleType = reader.int32() as any;
          break;
        case 9:
          message.initialMarginRatio = reader.string();
          break;
        case 10:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 11:
          message.makerFeeRate = reader.string();
          break;
        case 12:
          message.takerFeeRate = reader.string();
          break;
        case 13:
          message.minPriceTickSize = reader.string();
          break;
        case 14:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PerpetualMarketLaunchProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: PerpetualMarketLaunchProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<PerpetualMarketLaunchProposal>): PerpetualMarketLaunchProposal {
    return PerpetualMarketLaunchProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<PerpetualMarketLaunchProposal>): PerpetualMarketLaunchProposal {
    const message = createBasePerpetualMarketLaunchProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.ticker = object.ticker ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.oracleType = object.oracleType ?? 0;
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseBinaryOptionsMarketLaunchProposal(): BinaryOptionsMarketLaunchProposal {
  return {
    title: "",
    description: "",
    ticker: "",
    oracleSymbol: "",
    oracleProvider: "",
    oracleType: 0,
    oracleScaleFactor: 0,
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    admin: "",
    quoteDenom: "",
    makerFeeRate: "",
    takerFeeRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const BinaryOptionsMarketLaunchProposal = {
  encode(message: BinaryOptionsMarketLaunchProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(34).string(message.oracleSymbol);
    }
    if (message.oracleProvider !== "") {
      writer.uint32(42).string(message.oracleProvider);
    }
    if (message.oracleType !== 0) {
      writer.uint32(48).int32(message.oracleType);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(64).int64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(72).int64(message.settlementTimestamp);
    }
    if (message.admin !== "") {
      writer.uint32(82).string(message.admin);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(90).string(message.quoteDenom);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(98).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(106).string(message.takerFeeRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(114).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(122).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketLaunchProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketLaunchProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.oracleSymbol = reader.string();
          break;
        case 5:
          message.oracleProvider = reader.string();
          break;
        case 6:
          message.oracleType = reader.int32() as any;
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 9:
          message.settlementTimestamp = longToString(reader.int64() as Long);
          break;
        case 10:
          message.admin = reader.string();
          break;
        case 11:
          message.quoteDenom = reader.string();
          break;
        case 12:
          message.makerFeeRate = reader.string();
          break;
        case 13:
          message.takerFeeRate = reader.string();
          break;
        case 14:
          message.minPriceTickSize = reader.string();
          break;
        case 15:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketLaunchProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? String(object.oracleSymbol) : "",
      oracleProvider: isSet(object.oracleProvider) ? String(object.oracleProvider) : "",
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      admin: isSet(object.admin) ? String(object.admin) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: BinaryOptionsMarketLaunchProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.oracleSymbol !== undefined && (obj.oracleSymbol = message.oracleSymbol);
    message.oracleProvider !== undefined && (obj.oracleProvider = message.oracleProvider);
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.admin !== undefined && (obj.admin = message.admin);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketLaunchProposal>): BinaryOptionsMarketLaunchProposal {
    return BinaryOptionsMarketLaunchProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketLaunchProposal>): BinaryOptionsMarketLaunchProposal {
    const message = createBaseBinaryOptionsMarketLaunchProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.ticker = object.ticker ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.oracleProvider = object.oracleProvider ?? "";
    message.oracleType = object.oracleType ?? 0;
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.admin = object.admin ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseExpiryFuturesMarketLaunchProposal(): ExpiryFuturesMarketLaunchProposal {
  return {
    title: "",
    description: "",
    ticker: "",
    quoteDenom: "",
    oracleBase: "",
    oracleQuote: "",
    oracleScaleFactor: 0,
    oracleType: 0,
    expiry: "0",
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    makerFeeRate: "",
    takerFeeRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
  };
}

export const ExpiryFuturesMarketLaunchProposal = {
  encode(message: ExpiryFuturesMarketLaunchProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.ticker !== "") {
      writer.uint32(26).string(message.ticker);
    }
    if (message.quoteDenom !== "") {
      writer.uint32(34).string(message.quoteDenom);
    }
    if (message.oracleBase !== "") {
      writer.uint32(42).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(50).string(message.oracleQuote);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(56).uint32(message.oracleScaleFactor);
    }
    if (message.oracleType !== 0) {
      writer.uint32(64).int32(message.oracleType);
    }
    if (message.expiry !== "0") {
      writer.uint32(72).int64(message.expiry);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(82).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(90).string(message.maintenanceMarginRatio);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(98).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(106).string(message.takerFeeRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(114).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(122).string(message.minQuantityTickSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpiryFuturesMarketLaunchProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpiryFuturesMarketLaunchProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.ticker = reader.string();
          break;
        case 4:
          message.quoteDenom = reader.string();
          break;
        case 5:
          message.oracleBase = reader.string();
          break;
        case 6:
          message.oracleQuote = reader.string();
          break;
        case 7:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 8:
          message.oracleType = reader.int32() as any;
          break;
        case 9:
          message.expiry = longToString(reader.int64() as Long);
          break;
        case 10:
          message.initialMarginRatio = reader.string();
          break;
        case 11:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 12:
          message.makerFeeRate = reader.string();
          break;
        case 13:
          message.takerFeeRate = reader.string();
          break;
        case 14:
          message.minPriceTickSize = reader.string();
          break;
        case 15:
          message.minQuantityTickSize = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpiryFuturesMarketLaunchProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      ticker: isSet(object.ticker) ? String(object.ticker) : "",
      quoteDenom: isSet(object.quoteDenom) ? String(object.quoteDenom) : "",
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
      expiry: isSet(object.expiry) ? String(object.expiry) : "0",
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
    };
  },

  toJSON(message: ExpiryFuturesMarketLaunchProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.ticker !== undefined && (obj.ticker = message.ticker);
    message.quoteDenom !== undefined && (obj.quoteDenom = message.quoteDenom);
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    message.expiry !== undefined && (obj.expiry = message.expiry);
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    return obj;
  },

  create(base?: DeepPartial<ExpiryFuturesMarketLaunchProposal>): ExpiryFuturesMarketLaunchProposal {
    return ExpiryFuturesMarketLaunchProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ExpiryFuturesMarketLaunchProposal>): ExpiryFuturesMarketLaunchProposal {
    const message = createBaseExpiryFuturesMarketLaunchProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.ticker = object.ticker ?? "";
    message.quoteDenom = object.quoteDenom ?? "";
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.oracleType = object.oracleType ?? 0;
    message.expiry = object.expiry ?? "0";
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    return message;
  },
};

function createBaseDerivativeMarketParamUpdateProposal(): DerivativeMarketParamUpdateProposal {
  return {
    title: "",
    description: "",
    marketId: "",
    initialMarginRatio: "",
    maintenanceMarginRatio: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
    HourlyInterestRate: "",
    HourlyFundingRateCap: "",
    status: 0,
    oracleParams: undefined,
  };
}

export const DerivativeMarketParamUpdateProposal = {
  encode(message: DerivativeMarketParamUpdateProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.initialMarginRatio !== "") {
      writer.uint32(34).string(message.initialMarginRatio);
    }
    if (message.maintenanceMarginRatio !== "") {
      writer.uint32(42).string(message.maintenanceMarginRatio);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(50).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(58).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(66).string(message.relayerFeeShareRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(74).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(82).string(message.minQuantityTickSize);
    }
    if (message.HourlyInterestRate !== "") {
      writer.uint32(90).string(message.HourlyInterestRate);
    }
    if (message.HourlyFundingRateCap !== "") {
      writer.uint32(98).string(message.HourlyFundingRateCap);
    }
    if (message.status !== 0) {
      writer.uint32(104).int32(message.status);
    }
    if (message.oracleParams !== undefined) {
      OracleParams.encode(message.oracleParams, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DerivativeMarketParamUpdateProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivativeMarketParamUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.initialMarginRatio = reader.string();
          break;
        case 5:
          message.maintenanceMarginRatio = reader.string();
          break;
        case 6:
          message.makerFeeRate = reader.string();
          break;
        case 7:
          message.takerFeeRate = reader.string();
          break;
        case 8:
          message.relayerFeeShareRate = reader.string();
          break;
        case 9:
          message.minPriceTickSize = reader.string();
          break;
        case 10:
          message.minQuantityTickSize = reader.string();
          break;
        case 11:
          message.HourlyInterestRate = reader.string();
          break;
        case 12:
          message.HourlyFundingRateCap = reader.string();
          break;
        case 13:
          message.status = reader.int32() as any;
          break;
        case 14:
          message.oracleParams = OracleParams.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DerivativeMarketParamUpdateProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      initialMarginRatio: isSet(object.initialMarginRatio) ? String(object.initialMarginRatio) : "",
      maintenanceMarginRatio: isSet(object.maintenanceMarginRatio) ? String(object.maintenanceMarginRatio) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      HourlyInterestRate: isSet(object.HourlyInterestRate) ? String(object.HourlyInterestRate) : "",
      HourlyFundingRateCap: isSet(object.HourlyFundingRateCap) ? String(object.HourlyFundingRateCap) : "",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
      oracleParams: isSet(object.oracleParams) ? OracleParams.fromJSON(object.oracleParams) : undefined,
    };
  },

  toJSON(message: DerivativeMarketParamUpdateProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.initialMarginRatio !== undefined && (obj.initialMarginRatio = message.initialMarginRatio);
    message.maintenanceMarginRatio !== undefined && (obj.maintenanceMarginRatio = message.maintenanceMarginRatio);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.HourlyInterestRate !== undefined && (obj.HourlyInterestRate = message.HourlyInterestRate);
    message.HourlyFundingRateCap !== undefined && (obj.HourlyFundingRateCap = message.HourlyFundingRateCap);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    message.oracleParams !== undefined &&
      (obj.oracleParams = message.oracleParams ? OracleParams.toJSON(message.oracleParams) : undefined);
    return obj;
  },

  create(base?: DeepPartial<DerivativeMarketParamUpdateProposal>): DerivativeMarketParamUpdateProposal {
    return DerivativeMarketParamUpdateProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<DerivativeMarketParamUpdateProposal>): DerivativeMarketParamUpdateProposal {
    const message = createBaseDerivativeMarketParamUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.marketId = object.marketId ?? "";
    message.initialMarginRatio = object.initialMarginRatio ?? "";
    message.maintenanceMarginRatio = object.maintenanceMarginRatio ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.HourlyInterestRate = object.HourlyInterestRate ?? "";
    message.HourlyFundingRateCap = object.HourlyFundingRateCap ?? "";
    message.status = object.status ?? 0;
    message.oracleParams = (object.oracleParams !== undefined && object.oracleParams !== null)
      ? OracleParams.fromPartial(object.oracleParams)
      : undefined;
    return message;
  },
};

function createBaseMarketForcedSettlementProposal(): MarketForcedSettlementProposal {
  return { title: "", description: "", marketId: "", settlementPrice: "" };
}

export const MarketForcedSettlementProposal = {
  encode(message: MarketForcedSettlementProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(34).string(message.settlementPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketForcedSettlementProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketForcedSettlementProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.settlementPrice = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarketForcedSettlementProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
    };
  },

  toJSON(message: MarketForcedSettlementProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    return obj;
  },

  create(base?: DeepPartial<MarketForcedSettlementProposal>): MarketForcedSettlementProposal {
    return MarketForcedSettlementProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MarketForcedSettlementProposal>): MarketForcedSettlementProposal {
    const message = createBaseMarketForcedSettlementProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.marketId = object.marketId ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    return message;
  },
};

function createBaseUpdateDenomDecimalsProposal(): UpdateDenomDecimalsProposal {
  return { title: "", description: "", denomDecimals: [] };
}

export const UpdateDenomDecimalsProposal = {
  encode(message: UpdateDenomDecimalsProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.denomDecimals) {
      DenomDecimals.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateDenomDecimalsProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDenomDecimalsProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.denomDecimals.push(DenomDecimals.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateDenomDecimalsProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      denomDecimals: Array.isArray(object?.denomDecimals)
        ? object.denomDecimals.map((e: any) => DenomDecimals.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateDenomDecimalsProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.denomDecimals) {
      obj.denomDecimals = message.denomDecimals.map((e) => e ? DenomDecimals.toJSON(e) : undefined);
    } else {
      obj.denomDecimals = [];
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDenomDecimalsProposal>): UpdateDenomDecimalsProposal {
    return UpdateDenomDecimalsProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<UpdateDenomDecimalsProposal>): UpdateDenomDecimalsProposal {
    const message = createBaseUpdateDenomDecimalsProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.denomDecimals = object.denomDecimals?.map((e) => DenomDecimals.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBinaryOptionsMarketParamUpdateProposal(): BinaryOptionsMarketParamUpdateProposal {
  return {
    title: "",
    description: "",
    marketId: "",
    makerFeeRate: "",
    takerFeeRate: "",
    relayerFeeShareRate: "",
    minPriceTickSize: "",
    minQuantityTickSize: "",
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    settlementPrice: "",
    admin: "",
    status: 0,
    oracleParams: undefined,
  };
}

export const BinaryOptionsMarketParamUpdateProposal = {
  encode(message: BinaryOptionsMarketParamUpdateProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.marketId !== "") {
      writer.uint32(26).string(message.marketId);
    }
    if (message.makerFeeRate !== "") {
      writer.uint32(34).string(message.makerFeeRate);
    }
    if (message.takerFeeRate !== "") {
      writer.uint32(42).string(message.takerFeeRate);
    }
    if (message.relayerFeeShareRate !== "") {
      writer.uint32(50).string(message.relayerFeeShareRate);
    }
    if (message.minPriceTickSize !== "") {
      writer.uint32(58).string(message.minPriceTickSize);
    }
    if (message.minQuantityTickSize !== "") {
      writer.uint32(66).string(message.minQuantityTickSize);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(72).int64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(80).int64(message.settlementTimestamp);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(90).string(message.settlementPrice);
    }
    if (message.admin !== "") {
      writer.uint32(98).string(message.admin);
    }
    if (message.status !== 0) {
      writer.uint32(104).int32(message.status);
    }
    if (message.oracleParams !== undefined) {
      ProviderOracleParams.encode(message.oracleParams, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BinaryOptionsMarketParamUpdateProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOptionsMarketParamUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.marketId = reader.string();
          break;
        case 4:
          message.makerFeeRate = reader.string();
          break;
        case 5:
          message.takerFeeRate = reader.string();
          break;
        case 6:
          message.relayerFeeShareRate = reader.string();
          break;
        case 7:
          message.minPriceTickSize = reader.string();
          break;
        case 8:
          message.minQuantityTickSize = reader.string();
          break;
        case 9:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 10:
          message.settlementTimestamp = longToString(reader.int64() as Long);
          break;
        case 11:
          message.settlementPrice = reader.string();
          break;
        case 12:
          message.admin = reader.string();
          break;
        case 13:
          message.status = reader.int32() as any;
          break;
        case 14:
          message.oracleParams = ProviderOracleParams.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BinaryOptionsMarketParamUpdateProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      makerFeeRate: isSet(object.makerFeeRate) ? String(object.makerFeeRate) : "",
      takerFeeRate: isSet(object.takerFeeRate) ? String(object.takerFeeRate) : "",
      relayerFeeShareRate: isSet(object.relayerFeeShareRate) ? String(object.relayerFeeShareRate) : "",
      minPriceTickSize: isSet(object.minPriceTickSize) ? String(object.minPriceTickSize) : "",
      minQuantityTickSize: isSet(object.minQuantityTickSize) ? String(object.minQuantityTickSize) : "",
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
      admin: isSet(object.admin) ? String(object.admin) : "",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
      oracleParams: isSet(object.oracleParams) ? ProviderOracleParams.fromJSON(object.oracleParams) : undefined,
    };
  },

  toJSON(message: BinaryOptionsMarketParamUpdateProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.makerFeeRate !== undefined && (obj.makerFeeRate = message.makerFeeRate);
    message.takerFeeRate !== undefined && (obj.takerFeeRate = message.takerFeeRate);
    message.relayerFeeShareRate !== undefined && (obj.relayerFeeShareRate = message.relayerFeeShareRate);
    message.minPriceTickSize !== undefined && (obj.minPriceTickSize = message.minPriceTickSize);
    message.minQuantityTickSize !== undefined && (obj.minQuantityTickSize = message.minQuantityTickSize);
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    message.admin !== undefined && (obj.admin = message.admin);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    message.oracleParams !== undefined &&
      (obj.oracleParams = message.oracleParams ? ProviderOracleParams.toJSON(message.oracleParams) : undefined);
    return obj;
  },

  create(base?: DeepPartial<BinaryOptionsMarketParamUpdateProposal>): BinaryOptionsMarketParamUpdateProposal {
    return BinaryOptionsMarketParamUpdateProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BinaryOptionsMarketParamUpdateProposal>): BinaryOptionsMarketParamUpdateProposal {
    const message = createBaseBinaryOptionsMarketParamUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.marketId = object.marketId ?? "";
    message.makerFeeRate = object.makerFeeRate ?? "";
    message.takerFeeRate = object.takerFeeRate ?? "";
    message.relayerFeeShareRate = object.relayerFeeShareRate ?? "";
    message.minPriceTickSize = object.minPriceTickSize ?? "";
    message.minQuantityTickSize = object.minQuantityTickSize ?? "";
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.settlementPrice = object.settlementPrice ?? "";
    message.admin = object.admin ?? "";
    message.status = object.status ?? 0;
    message.oracleParams = (object.oracleParams !== undefined && object.oracleParams !== null)
      ? ProviderOracleParams.fromPartial(object.oracleParams)
      : undefined;
    return message;
  },
};

function createBaseProviderOracleParams(): ProviderOracleParams {
  return { symbol: "", provider: "", oracleScaleFactor: 0, oracleType: 0 };
}

export const ProviderOracleParams = {
  encode(message: ProviderOracleParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(24).uint32(message.oracleScaleFactor);
    }
    if (message.oracleType !== 0) {
      writer.uint32(32).int32(message.oracleType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderOracleParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderOracleParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.symbol = reader.string();
          break;
        case 2:
          message.provider = reader.string();
          break;
        case 3:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 4:
          message.oracleType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProviderOracleParams {
    return {
      symbol: isSet(object.symbol) ? String(object.symbol) : "",
      provider: isSet(object.provider) ? String(object.provider) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
    };
  },

  toJSON(message: ProviderOracleParams): unknown {
    const obj: any = {};
    message.symbol !== undefined && (obj.symbol = message.symbol);
    message.provider !== undefined && (obj.provider = message.provider);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    return obj;
  },

  create(base?: DeepPartial<ProviderOracleParams>): ProviderOracleParams {
    return ProviderOracleParams.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ProviderOracleParams>): ProviderOracleParams {
    const message = createBaseProviderOracleParams();
    message.symbol = object.symbol ?? "";
    message.provider = object.provider ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.oracleType = object.oracleType ?? 0;
    return message;
  },
};

function createBaseOracleParams(): OracleParams {
  return { oracleBase: "", oracleQuote: "", oracleScaleFactor: 0, oracleType: 0 };
}

export const OracleParams = {
  encode(message: OracleParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oracleBase !== "") {
      writer.uint32(10).string(message.oracleBase);
    }
    if (message.oracleQuote !== "") {
      writer.uint32(18).string(message.oracleQuote);
    }
    if (message.oracleScaleFactor !== 0) {
      writer.uint32(24).uint32(message.oracleScaleFactor);
    }
    if (message.oracleType !== 0) {
      writer.uint32(32).int32(message.oracleType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OracleParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oracleBase = reader.string();
          break;
        case 2:
          message.oracleQuote = reader.string();
          break;
        case 3:
          message.oracleScaleFactor = reader.uint32();
          break;
        case 4:
          message.oracleType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OracleParams {
    return {
      oracleBase: isSet(object.oracleBase) ? String(object.oracleBase) : "",
      oracleQuote: isSet(object.oracleQuote) ? String(object.oracleQuote) : "",
      oracleScaleFactor: isSet(object.oracleScaleFactor) ? Number(object.oracleScaleFactor) : 0,
      oracleType: isSet(object.oracleType) ? oracleTypeFromJSON(object.oracleType) : 0,
    };
  },

  toJSON(message: OracleParams): unknown {
    const obj: any = {};
    message.oracleBase !== undefined && (obj.oracleBase = message.oracleBase);
    message.oracleQuote !== undefined && (obj.oracleQuote = message.oracleQuote);
    message.oracleScaleFactor !== undefined && (obj.oracleScaleFactor = Math.round(message.oracleScaleFactor));
    message.oracleType !== undefined && (obj.oracleType = oracleTypeToJSON(message.oracleType));
    return obj;
  },

  create(base?: DeepPartial<OracleParams>): OracleParams {
    return OracleParams.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<OracleParams>): OracleParams {
    const message = createBaseOracleParams();
    message.oracleBase = object.oracleBase ?? "";
    message.oracleQuote = object.oracleQuote ?? "";
    message.oracleScaleFactor = object.oracleScaleFactor ?? 0;
    message.oracleType = object.oracleType ?? 0;
    return message;
  },
};

function createBaseTradingRewardCampaignLaunchProposal(): TradingRewardCampaignLaunchProposal {
  return { title: "", description: "", campaignInfo: undefined, campaignRewardPools: [] };
}

export const TradingRewardCampaignLaunchProposal = {
  encode(message: TradingRewardCampaignLaunchProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.campaignInfo !== undefined) {
      TradingRewardCampaignInfo.encode(message.campaignInfo, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.campaignRewardPools) {
      CampaignRewardPool.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignLaunchProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingRewardCampaignLaunchProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.campaignInfo = TradingRewardCampaignInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.campaignRewardPools.push(CampaignRewardPool.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradingRewardCampaignLaunchProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      campaignInfo: isSet(object.campaignInfo) ? TradingRewardCampaignInfo.fromJSON(object.campaignInfo) : undefined,
      campaignRewardPools: Array.isArray(object?.campaignRewardPools)
        ? object.campaignRewardPools.map((e: any) => CampaignRewardPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradingRewardCampaignLaunchProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.campaignInfo !== undefined &&
      (obj.campaignInfo = message.campaignInfo ? TradingRewardCampaignInfo.toJSON(message.campaignInfo) : undefined);
    if (message.campaignRewardPools) {
      obj.campaignRewardPools = message.campaignRewardPools.map((e) => e ? CampaignRewardPool.toJSON(e) : undefined);
    } else {
      obj.campaignRewardPools = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradingRewardCampaignLaunchProposal>): TradingRewardCampaignLaunchProposal {
    return TradingRewardCampaignLaunchProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradingRewardCampaignLaunchProposal>): TradingRewardCampaignLaunchProposal {
    const message = createBaseTradingRewardCampaignLaunchProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.campaignInfo = (object.campaignInfo !== undefined && object.campaignInfo !== null)
      ? TradingRewardCampaignInfo.fromPartial(object.campaignInfo)
      : undefined;
    message.campaignRewardPools = object.campaignRewardPools?.map((e) => CampaignRewardPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradingRewardCampaignUpdateProposal(): TradingRewardCampaignUpdateProposal {
  return {
    title: "",
    description: "",
    campaignInfo: undefined,
    campaignRewardPoolsAdditions: [],
    campaignRewardPoolsUpdates: [],
  };
}

export const TradingRewardCampaignUpdateProposal = {
  encode(message: TradingRewardCampaignUpdateProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.campaignInfo !== undefined) {
      TradingRewardCampaignInfo.encode(message.campaignInfo, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.campaignRewardPoolsAdditions) {
      CampaignRewardPool.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.campaignRewardPoolsUpdates) {
      CampaignRewardPool.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardCampaignUpdateProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingRewardCampaignUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.campaignInfo = TradingRewardCampaignInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.campaignRewardPoolsAdditions.push(CampaignRewardPool.decode(reader, reader.uint32()));
          break;
        case 5:
          message.campaignRewardPoolsUpdates.push(CampaignRewardPool.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradingRewardCampaignUpdateProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      campaignInfo: isSet(object.campaignInfo) ? TradingRewardCampaignInfo.fromJSON(object.campaignInfo) : undefined,
      campaignRewardPoolsAdditions: Array.isArray(object?.campaignRewardPoolsAdditions)
        ? object.campaignRewardPoolsAdditions.map((e: any) => CampaignRewardPool.fromJSON(e))
        : [],
      campaignRewardPoolsUpdates: Array.isArray(object?.campaignRewardPoolsUpdates)
        ? object.campaignRewardPoolsUpdates.map((e: any) => CampaignRewardPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradingRewardCampaignUpdateProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.campaignInfo !== undefined &&
      (obj.campaignInfo = message.campaignInfo ? TradingRewardCampaignInfo.toJSON(message.campaignInfo) : undefined);
    if (message.campaignRewardPoolsAdditions) {
      obj.campaignRewardPoolsAdditions = message.campaignRewardPoolsAdditions.map((e) =>
        e ? CampaignRewardPool.toJSON(e) : undefined
      );
    } else {
      obj.campaignRewardPoolsAdditions = [];
    }
    if (message.campaignRewardPoolsUpdates) {
      obj.campaignRewardPoolsUpdates = message.campaignRewardPoolsUpdates.map((e) =>
        e ? CampaignRewardPool.toJSON(e) : undefined
      );
    } else {
      obj.campaignRewardPoolsUpdates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradingRewardCampaignUpdateProposal>): TradingRewardCampaignUpdateProposal {
    return TradingRewardCampaignUpdateProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradingRewardCampaignUpdateProposal>): TradingRewardCampaignUpdateProposal {
    const message = createBaseTradingRewardCampaignUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.campaignInfo = (object.campaignInfo !== undefined && object.campaignInfo !== null)
      ? TradingRewardCampaignInfo.fromPartial(object.campaignInfo)
      : undefined;
    message.campaignRewardPoolsAdditions =
      object.campaignRewardPoolsAdditions?.map((e) => CampaignRewardPool.fromPartial(e)) || [];
    message.campaignRewardPoolsUpdates =
      object.campaignRewardPoolsUpdates?.map((e) => CampaignRewardPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRewardPointUpdate(): RewardPointUpdate {
  return { accountAddress: "", newPoints: "" };
}

export const RewardPointUpdate = {
  encode(message: RewardPointUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.newPoints !== "") {
      writer.uint32(98).string(message.newPoints);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardPointUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardPointUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountAddress = reader.string();
          break;
        case 12:
          message.newPoints = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RewardPointUpdate {
    return {
      accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
      newPoints: isSet(object.newPoints) ? String(object.newPoints) : "",
    };
  },

  toJSON(message: RewardPointUpdate): unknown {
    const obj: any = {};
    message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
    message.newPoints !== undefined && (obj.newPoints = message.newPoints);
    return obj;
  },

  create(base?: DeepPartial<RewardPointUpdate>): RewardPointUpdate {
    return RewardPointUpdate.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<RewardPointUpdate>): RewardPointUpdate {
    const message = createBaseRewardPointUpdate();
    message.accountAddress = object.accountAddress ?? "";
    message.newPoints = object.newPoints ?? "";
    return message;
  },
};

function createBaseTradingRewardPendingPointsUpdateProposal(): TradingRewardPendingPointsUpdateProposal {
  return { title: "", description: "", pendingPoolTimestamp: "0", rewardPointUpdates: [] };
}

export const TradingRewardPendingPointsUpdateProposal = {
  encode(message: TradingRewardPendingPointsUpdateProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.pendingPoolTimestamp !== "0") {
      writer.uint32(24).int64(message.pendingPoolTimestamp);
    }
    for (const v of message.rewardPointUpdates) {
      RewardPointUpdate.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradingRewardPendingPointsUpdateProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingRewardPendingPointsUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.pendingPoolTimestamp = longToString(reader.int64() as Long);
          break;
        case 4:
          message.rewardPointUpdates.push(RewardPointUpdate.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TradingRewardPendingPointsUpdateProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      pendingPoolTimestamp: isSet(object.pendingPoolTimestamp) ? String(object.pendingPoolTimestamp) : "0",
      rewardPointUpdates: Array.isArray(object?.rewardPointUpdates)
        ? object.rewardPointUpdates.map((e: any) => RewardPointUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradingRewardPendingPointsUpdateProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.pendingPoolTimestamp !== undefined && (obj.pendingPoolTimestamp = message.pendingPoolTimestamp);
    if (message.rewardPointUpdates) {
      obj.rewardPointUpdates = message.rewardPointUpdates.map((e) => e ? RewardPointUpdate.toJSON(e) : undefined);
    } else {
      obj.rewardPointUpdates = [];
    }
    return obj;
  },

  create(base?: DeepPartial<TradingRewardPendingPointsUpdateProposal>): TradingRewardPendingPointsUpdateProposal {
    return TradingRewardPendingPointsUpdateProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<TradingRewardPendingPointsUpdateProposal>): TradingRewardPendingPointsUpdateProposal {
    const message = createBaseTradingRewardPendingPointsUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.pendingPoolTimestamp = object.pendingPoolTimestamp ?? "0";
    message.rewardPointUpdates = object.rewardPointUpdates?.map((e) => RewardPointUpdate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFeeDiscountProposal(): FeeDiscountProposal {
  return { title: "", description: "", schedule: undefined };
}

export const FeeDiscountProposal = {
  encode(message: FeeDiscountProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.schedule !== undefined) {
      FeeDiscountSchedule.encode(message.schedule, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeeDiscountProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeDiscountProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.schedule = FeeDiscountSchedule.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeeDiscountProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      schedule: isSet(object.schedule) ? FeeDiscountSchedule.fromJSON(object.schedule) : undefined,
    };
  },

  toJSON(message: FeeDiscountProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.schedule !== undefined &&
      (obj.schedule = message.schedule ? FeeDiscountSchedule.toJSON(message.schedule) : undefined);
    return obj;
  },

  create(base?: DeepPartial<FeeDiscountProposal>): FeeDiscountProposal {
    return FeeDiscountProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<FeeDiscountProposal>): FeeDiscountProposal {
    const message = createBaseFeeDiscountProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.schedule = (object.schedule !== undefined && object.schedule !== null)
      ? FeeDiscountSchedule.fromPartial(object.schedule)
      : undefined;
    return message;
  },
};

function createBaseBatchCommunityPoolSpendProposal(): BatchCommunityPoolSpendProposal {
  return { title: "", description: "", proposals: [] };
}

export const BatchCommunityPoolSpendProposal = {
  encode(message: BatchCommunityPoolSpendProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.proposals) {
      CommunityPoolSpendProposal.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchCommunityPoolSpendProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCommunityPoolSpendProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.proposals.push(CommunityPoolSpendProposal.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BatchCommunityPoolSpendProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      proposals: Array.isArray(object?.proposals)
        ? object.proposals.map((e: any) => CommunityPoolSpendProposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCommunityPoolSpendProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.proposals) {
      obj.proposals = message.proposals.map((e) => e ? CommunityPoolSpendProposal.toJSON(e) : undefined);
    } else {
      obj.proposals = [];
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCommunityPoolSpendProposal>): BatchCommunityPoolSpendProposal {
    return BatchCommunityPoolSpendProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BatchCommunityPoolSpendProposal>): BatchCommunityPoolSpendProposal {
    const message = createBaseBatchCommunityPoolSpendProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.proposals = object.proposals?.map((e) => CommunityPoolSpendProposal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgRewardsOptOut(): MsgRewardsOptOut {
  return { sender: "" };
}

export const MsgRewardsOptOut = {
  encode(message: MsgRewardsOptOut, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRewardsOptOut {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRewardsOptOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgRewardsOptOut {
    return { sender: isSet(object.sender) ? String(object.sender) : "" };
  },

  toJSON(message: MsgRewardsOptOut): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    return obj;
  },

  create(base?: DeepPartial<MsgRewardsOptOut>): MsgRewardsOptOut {
    return MsgRewardsOptOut.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgRewardsOptOut>): MsgRewardsOptOut {
    const message = createBaseMsgRewardsOptOut();
    message.sender = object.sender ?? "";
    return message;
  },
};

function createBaseMsgRewardsOptOutResponse(): MsgRewardsOptOutResponse {
  return {};
}

export const MsgRewardsOptOutResponse = {
  encode(_: MsgRewardsOptOutResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRewardsOptOutResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRewardsOptOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgRewardsOptOutResponse {
    return {};
  },

  toJSON(_: MsgRewardsOptOutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRewardsOptOutResponse>): MsgRewardsOptOutResponse {
    return MsgRewardsOptOutResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgRewardsOptOutResponse>): MsgRewardsOptOutResponse {
    const message = createBaseMsgRewardsOptOutResponse();
    return message;
  },
};

function createBaseMsgReclaimLockedFunds(): MsgReclaimLockedFunds {
  return { sender: "", lockedAccountPubKey: new Uint8Array(), signature: new Uint8Array() };
}

export const MsgReclaimLockedFunds = {
  encode(message: MsgReclaimLockedFunds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.lockedAccountPubKey.length !== 0) {
      writer.uint32(18).bytes(message.lockedAccountPubKey);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReclaimLockedFunds {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReclaimLockedFunds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.lockedAccountPubKey = reader.bytes();
          break;
        case 3:
          message.signature = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgReclaimLockedFunds {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      lockedAccountPubKey: isSet(object.lockedAccountPubKey)
        ? bytesFromBase64(object.lockedAccountPubKey)
        : new Uint8Array(),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
    };
  },

  toJSON(message: MsgReclaimLockedFunds): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.lockedAccountPubKey !== undefined &&
      (obj.lockedAccountPubKey = base64FromBytes(
        message.lockedAccountPubKey !== undefined ? message.lockedAccountPubKey : new Uint8Array(),
      ));
    message.signature !== undefined &&
      (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<MsgReclaimLockedFunds>): MsgReclaimLockedFunds {
    return MsgReclaimLockedFunds.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgReclaimLockedFunds>): MsgReclaimLockedFunds {
    const message = createBaseMsgReclaimLockedFunds();
    message.sender = object.sender ?? "";
    message.lockedAccountPubKey = object.lockedAccountPubKey ?? new Uint8Array();
    message.signature = object.signature ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgReclaimLockedFundsResponse(): MsgReclaimLockedFundsResponse {
  return {};
}

export const MsgReclaimLockedFundsResponse = {
  encode(_: MsgReclaimLockedFundsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgReclaimLockedFundsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReclaimLockedFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgReclaimLockedFundsResponse {
    return {};
  },

  toJSON(_: MsgReclaimLockedFundsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgReclaimLockedFundsResponse>): MsgReclaimLockedFundsResponse {
    return MsgReclaimLockedFundsResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgReclaimLockedFundsResponse>): MsgReclaimLockedFundsResponse {
    const message = createBaseMsgReclaimLockedFundsResponse();
    return message;
  },
};

function createBaseMsgSignData(): MsgSignData {
  return { Signer: new Uint8Array(), Data: new Uint8Array() };
}

export const MsgSignData = {
  encode(message: MsgSignData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Signer.length !== 0) {
      writer.uint32(10).bytes(message.Signer);
    }
    if (message.Data.length !== 0) {
      writer.uint32(18).bytes(message.Data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Signer = reader.bytes();
          break;
        case 2:
          message.Data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSignData {
    return {
      Signer: isSet(object.Signer) ? bytesFromBase64(object.Signer) : new Uint8Array(),
      Data: isSet(object.Data) ? bytesFromBase64(object.Data) : new Uint8Array(),
    };
  },

  toJSON(message: MsgSignData): unknown {
    const obj: any = {};
    message.Signer !== undefined &&
      (obj.Signer = base64FromBytes(message.Signer !== undefined ? message.Signer : new Uint8Array()));
    message.Data !== undefined &&
      (obj.Data = base64FromBytes(message.Data !== undefined ? message.Data : new Uint8Array()));
    return obj;
  },

  create(base?: DeepPartial<MsgSignData>): MsgSignData {
    return MsgSignData.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgSignData>): MsgSignData {
    const message = createBaseMsgSignData();
    message.Signer = object.Signer ?? new Uint8Array();
    message.Data = object.Data ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgSignDoc(): MsgSignDoc {
  return { signType: "", value: undefined };
}

export const MsgSignDoc = {
  encode(message: MsgSignDoc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signType !== "") {
      writer.uint32(10).string(message.signType);
    }
    if (message.value !== undefined) {
      MsgSignData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignDoc {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignDoc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signType = reader.string();
          break;
        case 2:
          message.value = MsgSignData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSignDoc {
    return {
      signType: isSet(object.signType) ? String(object.signType) : "",
      value: isSet(object.value) ? MsgSignData.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MsgSignDoc): unknown {
    const obj: any = {};
    message.signType !== undefined && (obj.signType = message.signType);
    message.value !== undefined && (obj.value = message.value ? MsgSignData.toJSON(message.value) : undefined);
    return obj;
  },

  create(base?: DeepPartial<MsgSignDoc>): MsgSignDoc {
    return MsgSignDoc.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgSignDoc>): MsgSignDoc {
    const message = createBaseMsgSignDoc();
    message.signType = object.signType ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MsgSignData.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMsgAdminUpdateBinaryOptionsMarket(): MsgAdminUpdateBinaryOptionsMarket {
  return {
    sender: "",
    marketId: "",
    settlementPrice: "",
    expirationTimestamp: "0",
    settlementTimestamp: "0",
    status: 0,
  };
}

export const MsgAdminUpdateBinaryOptionsMarket = {
  encode(message: MsgAdminUpdateBinaryOptionsMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.settlementPrice !== "") {
      writer.uint32(26).string(message.settlementPrice);
    }
    if (message.expirationTimestamp !== "0") {
      writer.uint32(32).int64(message.expirationTimestamp);
    }
    if (message.settlementTimestamp !== "0") {
      writer.uint32(40).int64(message.settlementTimestamp);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAdminUpdateBinaryOptionsMarket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAdminUpdateBinaryOptionsMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;
        case 2:
          message.marketId = reader.string();
          break;
        case 3:
          message.settlementPrice = reader.string();
          break;
        case 4:
          message.expirationTimestamp = longToString(reader.int64() as Long);
          break;
        case 5:
          message.settlementTimestamp = longToString(reader.int64() as Long);
          break;
        case 6:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAdminUpdateBinaryOptionsMarket {
    return {
      sender: isSet(object.sender) ? String(object.sender) : "",
      marketId: isSet(object.marketId) ? String(object.marketId) : "",
      settlementPrice: isSet(object.settlementPrice) ? String(object.settlementPrice) : "",
      expirationTimestamp: isSet(object.expirationTimestamp) ? String(object.expirationTimestamp) : "0",
      settlementTimestamp: isSet(object.settlementTimestamp) ? String(object.settlementTimestamp) : "0",
      status: isSet(object.status) ? marketStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgAdminUpdateBinaryOptionsMarket): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.marketId !== undefined && (obj.marketId = message.marketId);
    message.settlementPrice !== undefined && (obj.settlementPrice = message.settlementPrice);
    message.expirationTimestamp !== undefined && (obj.expirationTimestamp = message.expirationTimestamp);
    message.settlementTimestamp !== undefined && (obj.settlementTimestamp = message.settlementTimestamp);
    message.status !== undefined && (obj.status = marketStatusToJSON(message.status));
    return obj;
  },

  create(base?: DeepPartial<MsgAdminUpdateBinaryOptionsMarket>): MsgAdminUpdateBinaryOptionsMarket {
    return MsgAdminUpdateBinaryOptionsMarket.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<MsgAdminUpdateBinaryOptionsMarket>): MsgAdminUpdateBinaryOptionsMarket {
    const message = createBaseMsgAdminUpdateBinaryOptionsMarket();
    message.sender = object.sender ?? "";
    message.marketId = object.marketId ?? "";
    message.settlementPrice = object.settlementPrice ?? "";
    message.expirationTimestamp = object.expirationTimestamp ?? "0";
    message.settlementTimestamp = object.settlementTimestamp ?? "0";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgAdminUpdateBinaryOptionsMarketResponse(): MsgAdminUpdateBinaryOptionsMarketResponse {
  return {};
}

export const MsgAdminUpdateBinaryOptionsMarketResponse = {
  encode(_: MsgAdminUpdateBinaryOptionsMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAdminUpdateBinaryOptionsMarketResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAdminUpdateBinaryOptionsMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAdminUpdateBinaryOptionsMarketResponse {
    return {};
  },

  toJSON(_: MsgAdminUpdateBinaryOptionsMarketResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAdminUpdateBinaryOptionsMarketResponse>): MsgAdminUpdateBinaryOptionsMarketResponse {
    return MsgAdminUpdateBinaryOptionsMarketResponse.fromPartial(base ?? {});
  },

  fromPartial(_: DeepPartial<MsgAdminUpdateBinaryOptionsMarketResponse>): MsgAdminUpdateBinaryOptionsMarketResponse {
    const message = createBaseMsgAdminUpdateBinaryOptionsMarketResponse();
    return message;
  },
};

function createBaseAtomicMarketOrderFeeMultiplierScheduleProposal(): AtomicMarketOrderFeeMultiplierScheduleProposal {
  return { title: "", description: "", marketFeeMultipliers: [] };
}

export const AtomicMarketOrderFeeMultiplierScheduleProposal = {
  encode(
    message: AtomicMarketOrderFeeMultiplierScheduleProposal,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.marketFeeMultipliers) {
      MarketFeeMultiplier.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AtomicMarketOrderFeeMultiplierScheduleProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAtomicMarketOrderFeeMultiplierScheduleProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.marketFeeMultipliers.push(MarketFeeMultiplier.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AtomicMarketOrderFeeMultiplierScheduleProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      marketFeeMultipliers: Array.isArray(object?.marketFeeMultipliers)
        ? object.marketFeeMultipliers.map((e: any) => MarketFeeMultiplier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AtomicMarketOrderFeeMultiplierScheduleProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.marketFeeMultipliers) {
      obj.marketFeeMultipliers = message.marketFeeMultipliers.map((e) => e ? MarketFeeMultiplier.toJSON(e) : undefined);
    } else {
      obj.marketFeeMultipliers = [];
    }
    return obj;
  },

  create(
    base?: DeepPartial<AtomicMarketOrderFeeMultiplierScheduleProposal>,
  ): AtomicMarketOrderFeeMultiplierScheduleProposal {
    return AtomicMarketOrderFeeMultiplierScheduleProposal.fromPartial(base ?? {});
  },

  fromPartial(
    object: DeepPartial<AtomicMarketOrderFeeMultiplierScheduleProposal>,
  ): AtomicMarketOrderFeeMultiplierScheduleProposal {
    const message = createBaseAtomicMarketOrderFeeMultiplierScheduleProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.marketFeeMultipliers = object.marketFeeMultipliers?.map((e) => MarketFeeMultiplier.fromPartial(e)) || [];
    return message;
  },
};

/** Msg defines the exchange Msg service. */
export interface Msg {
  /** Deposit defines a method for transferring coins from the sender's bank balance into the subaccount's exchange deposits */
  Deposit(request: DeepPartial<MsgDeposit>, metadata?: grpc.Metadata): Promise<MsgDepositResponse>;
  /** Withdraw defines a method for withdrawing coins from a subaccount's deposits to the user's bank balance */
  Withdraw(request: DeepPartial<MsgWithdraw>, metadata?: grpc.Metadata): Promise<MsgWithdrawResponse>;
  /** InstantSpotMarketLaunch defines method for creating a spot market by paying listing fee without governance */
  InstantSpotMarketLaunch(
    request: DeepPartial<MsgInstantSpotMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantSpotMarketLaunchResponse>;
  /** InstantPerpetualMarketLaunch defines a method for creating a new perpetual futures market by paying listing fee without governance */
  InstantPerpetualMarketLaunch(
    request: DeepPartial<MsgInstantPerpetualMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantPerpetualMarketLaunchResponse>;
  /** InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry futures market by paying listing fee without governance */
  InstantExpiryFuturesMarketLaunch(
    request: DeepPartial<MsgInstantExpiryFuturesMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantExpiryFuturesMarketLaunchResponse>;
  /** CreateSpotLimitOrder defines a method for creating a new spot limit order. */
  CreateSpotLimitOrder(
    request: DeepPartial<MsgCreateSpotLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateSpotLimitOrderResponse>;
  /** BatchCreateSpotLimitOrder defines a method for creating a new batch of spot limit orders. */
  BatchCreateSpotLimitOrders(
    request: DeepPartial<MsgBatchCreateSpotLimitOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCreateSpotLimitOrdersResponse>;
  /** CreateSpotMarketOrder defines a method for creating a new spot market order. */
  CreateSpotMarketOrder(
    request: DeepPartial<MsgCreateSpotMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateSpotMarketOrderResponse>;
  /** MsgCancelSpotOrder defines a method for cancelling a spot order. */
  CancelSpotOrder(
    request: DeepPartial<MsgCancelSpotOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelSpotOrderResponse>;
  /** BatchCancelSpotOrders defines a method for cancelling a batch of spot orders in a given market. */
  BatchCancelSpotOrders(
    request: DeepPartial<MsgBatchCancelSpotOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelSpotOrdersResponse>;
  /** BatchUpdateOrders defines a method for updating a batch of orders. */
  BatchUpdateOrders(
    request: DeepPartial<MsgBatchUpdateOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchUpdateOrdersResponse>;
  /** PrivilegedExecuteContract defines a method for executing a Cosmwasm contract from the exchange module with privileged capabilities. */
  PrivilegedExecuteContract(
    request: DeepPartial<MsgPrivilegedExecuteContract>,
    metadata?: grpc.Metadata,
  ): Promise<MsgPrivilegedExecuteContractResponse>;
  /** CreateDerivativeLimitOrder defines a method for creating a new derivative limit order. */
  CreateDerivativeLimitOrder(
    request: DeepPartial<MsgCreateDerivativeLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateDerivativeLimitOrderResponse>;
  /** BatchCreateDerivativeLimitOrders defines a method for creating a new batch of derivative limit orders. */
  BatchCreateDerivativeLimitOrders(
    request: DeepPartial<MsgBatchCreateDerivativeLimitOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCreateDerivativeLimitOrdersResponse>;
  /** MsgCreateDerivativeLimitOrder defines a method for creating a new derivative market order. */
  CreateDerivativeMarketOrder(
    request: DeepPartial<MsgCreateDerivativeMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateDerivativeMarketOrderResponse>;
  /** MsgCancelDerivativeOrder defines a method for cancelling a derivative order. */
  CancelDerivativeOrder(
    request: DeepPartial<MsgCancelDerivativeOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelDerivativeOrderResponse>;
  /** MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of derivative limit orders. */
  BatchCancelDerivativeOrders(
    request: DeepPartial<MsgBatchCancelDerivativeOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelDerivativeOrdersResponse>;
  /** InstantBinaryOptionsMarketLaunch defines method for creating a binary options market by paying listing fee without governance */
  InstantBinaryOptionsMarketLaunch(
    request: DeepPartial<MsgInstantBinaryOptionsMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantBinaryOptionsMarketLaunchResponse>;
  /** CreateBinaryOptionsLimitOrder defines a method for creating a new binary options limit order. */
  CreateBinaryOptionsLimitOrder(
    request: DeepPartial<MsgCreateBinaryOptionsLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateBinaryOptionsLimitOrderResponse>;
  /** CreateBinaryOptionsMarketOrder defines a method for creating a new binary options market order. */
  CreateBinaryOptionsMarketOrder(
    request: DeepPartial<MsgCreateBinaryOptionsMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateBinaryOptionsMarketOrderResponse>;
  /** MsgCancelBinaryOptionsOrder defines a method for cancelling a binary options order. */
  CancelBinaryOptionsOrder(
    request: DeepPartial<MsgCancelBinaryOptionsOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelBinaryOptionsOrderResponse>;
  /** BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of binary options limit orders. */
  BatchCancelBinaryOptionsOrders(
    request: DeepPartial<MsgBatchCancelBinaryOptionsOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelBinaryOptionsOrdersResponse>;
  /** SubaccountTransfer defines a method for transfer between subaccounts */
  SubaccountTransfer(
    request: DeepPartial<MsgSubaccountTransfer>,
    metadata?: grpc.Metadata,
  ): Promise<MsgSubaccountTransferResponse>;
  /** ExternalTransfer defines a method for transfer between external accounts */
  ExternalTransfer(
    request: DeepPartial<MsgExternalTransfer>,
    metadata?: grpc.Metadata,
  ): Promise<MsgExternalTransferResponse>;
  /** LiquidatePosition defines a method for liquidating a position */
  LiquidatePosition(
    request: DeepPartial<MsgLiquidatePosition>,
    metadata?: grpc.Metadata,
  ): Promise<MsgLiquidatePositionResponse>;
  /** IncreasePositionMargin defines a method for increasing margin of a position */
  IncreasePositionMargin(
    request: DeepPartial<MsgIncreasePositionMargin>,
    metadata?: grpc.Metadata,
  ): Promise<MsgIncreasePositionMarginResponse>;
  /** RewardsOptOut defines a method for opting out of rewards */
  RewardsOptOut(request: DeepPartial<MsgRewardsOptOut>, metadata?: grpc.Metadata): Promise<MsgRewardsOptOutResponse>;
  /** AdminUpdateBinaryOptionsMarket defines method for updating a binary options market by admin */
  AdminUpdateBinaryOptionsMarket(
    request: DeepPartial<MsgAdminUpdateBinaryOptionsMarket>,
    metadata?: grpc.Metadata,
  ): Promise<MsgAdminUpdateBinaryOptionsMarketResponse>;
  /**  */
  ReclaimLockedFunds(
    request: DeepPartial<MsgReclaimLockedFunds>,
    metadata?: grpc.Metadata,
  ): Promise<MsgReclaimLockedFundsResponse>;
}

export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Deposit = this.Deposit.bind(this);
    this.Withdraw = this.Withdraw.bind(this);
    this.InstantSpotMarketLaunch = this.InstantSpotMarketLaunch.bind(this);
    this.InstantPerpetualMarketLaunch = this.InstantPerpetualMarketLaunch.bind(this);
    this.InstantExpiryFuturesMarketLaunch = this.InstantExpiryFuturesMarketLaunch.bind(this);
    this.CreateSpotLimitOrder = this.CreateSpotLimitOrder.bind(this);
    this.BatchCreateSpotLimitOrders = this.BatchCreateSpotLimitOrders.bind(this);
    this.CreateSpotMarketOrder = this.CreateSpotMarketOrder.bind(this);
    this.CancelSpotOrder = this.CancelSpotOrder.bind(this);
    this.BatchCancelSpotOrders = this.BatchCancelSpotOrders.bind(this);
    this.BatchUpdateOrders = this.BatchUpdateOrders.bind(this);
    this.PrivilegedExecuteContract = this.PrivilegedExecuteContract.bind(this);
    this.CreateDerivativeLimitOrder = this.CreateDerivativeLimitOrder.bind(this);
    this.BatchCreateDerivativeLimitOrders = this.BatchCreateDerivativeLimitOrders.bind(this);
    this.CreateDerivativeMarketOrder = this.CreateDerivativeMarketOrder.bind(this);
    this.CancelDerivativeOrder = this.CancelDerivativeOrder.bind(this);
    this.BatchCancelDerivativeOrders = this.BatchCancelDerivativeOrders.bind(this);
    this.InstantBinaryOptionsMarketLaunch = this.InstantBinaryOptionsMarketLaunch.bind(this);
    this.CreateBinaryOptionsLimitOrder = this.CreateBinaryOptionsLimitOrder.bind(this);
    this.CreateBinaryOptionsMarketOrder = this.CreateBinaryOptionsMarketOrder.bind(this);
    this.CancelBinaryOptionsOrder = this.CancelBinaryOptionsOrder.bind(this);
    this.BatchCancelBinaryOptionsOrders = this.BatchCancelBinaryOptionsOrders.bind(this);
    this.SubaccountTransfer = this.SubaccountTransfer.bind(this);
    this.ExternalTransfer = this.ExternalTransfer.bind(this);
    this.LiquidatePosition = this.LiquidatePosition.bind(this);
    this.IncreasePositionMargin = this.IncreasePositionMargin.bind(this);
    this.RewardsOptOut = this.RewardsOptOut.bind(this);
    this.AdminUpdateBinaryOptionsMarket = this.AdminUpdateBinaryOptionsMarket.bind(this);
    this.ReclaimLockedFunds = this.ReclaimLockedFunds.bind(this);
  }

  Deposit(request: DeepPartial<MsgDeposit>, metadata?: grpc.Metadata): Promise<MsgDepositResponse> {
    return this.rpc.unary(MsgDepositDesc, MsgDeposit.fromPartial(request), metadata);
  }

  Withdraw(request: DeepPartial<MsgWithdraw>, metadata?: grpc.Metadata): Promise<MsgWithdrawResponse> {
    return this.rpc.unary(MsgWithdrawDesc, MsgWithdraw.fromPartial(request), metadata);
  }

  InstantSpotMarketLaunch(
    request: DeepPartial<MsgInstantSpotMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantSpotMarketLaunchResponse> {
    return this.rpc.unary(MsgInstantSpotMarketLaunchDesc, MsgInstantSpotMarketLaunch.fromPartial(request), metadata);
  }

  InstantPerpetualMarketLaunch(
    request: DeepPartial<MsgInstantPerpetualMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantPerpetualMarketLaunchResponse> {
    return this.rpc.unary(
      MsgInstantPerpetualMarketLaunchDesc,
      MsgInstantPerpetualMarketLaunch.fromPartial(request),
      metadata,
    );
  }

  InstantExpiryFuturesMarketLaunch(
    request: DeepPartial<MsgInstantExpiryFuturesMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantExpiryFuturesMarketLaunchResponse> {
    return this.rpc.unary(
      MsgInstantExpiryFuturesMarketLaunchDesc,
      MsgInstantExpiryFuturesMarketLaunch.fromPartial(request),
      metadata,
    );
  }

  CreateSpotLimitOrder(
    request: DeepPartial<MsgCreateSpotLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateSpotLimitOrderResponse> {
    return this.rpc.unary(MsgCreateSpotLimitOrderDesc, MsgCreateSpotLimitOrder.fromPartial(request), metadata);
  }

  BatchCreateSpotLimitOrders(
    request: DeepPartial<MsgBatchCreateSpotLimitOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCreateSpotLimitOrdersResponse> {
    return this.rpc.unary(
      MsgBatchCreateSpotLimitOrdersDesc,
      MsgBatchCreateSpotLimitOrders.fromPartial(request),
      metadata,
    );
  }

  CreateSpotMarketOrder(
    request: DeepPartial<MsgCreateSpotMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateSpotMarketOrderResponse> {
    return this.rpc.unary(MsgCreateSpotMarketOrderDesc, MsgCreateSpotMarketOrder.fromPartial(request), metadata);
  }

  CancelSpotOrder(
    request: DeepPartial<MsgCancelSpotOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelSpotOrderResponse> {
    return this.rpc.unary(MsgCancelSpotOrderDesc, MsgCancelSpotOrder.fromPartial(request), metadata);
  }

  BatchCancelSpotOrders(
    request: DeepPartial<MsgBatchCancelSpotOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelSpotOrdersResponse> {
    return this.rpc.unary(MsgBatchCancelSpotOrdersDesc, MsgBatchCancelSpotOrders.fromPartial(request), metadata);
  }

  BatchUpdateOrders(
    request: DeepPartial<MsgBatchUpdateOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchUpdateOrdersResponse> {
    return this.rpc.unary(MsgBatchUpdateOrdersDesc, MsgBatchUpdateOrders.fromPartial(request), metadata);
  }

  PrivilegedExecuteContract(
    request: DeepPartial<MsgPrivilegedExecuteContract>,
    metadata?: grpc.Metadata,
  ): Promise<MsgPrivilegedExecuteContractResponse> {
    return this.rpc.unary(
      MsgPrivilegedExecuteContractDesc,
      MsgPrivilegedExecuteContract.fromPartial(request),
      metadata,
    );
  }

  CreateDerivativeLimitOrder(
    request: DeepPartial<MsgCreateDerivativeLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateDerivativeLimitOrderResponse> {
    return this.rpc.unary(
      MsgCreateDerivativeLimitOrderDesc,
      MsgCreateDerivativeLimitOrder.fromPartial(request),
      metadata,
    );
  }

  BatchCreateDerivativeLimitOrders(
    request: DeepPartial<MsgBatchCreateDerivativeLimitOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCreateDerivativeLimitOrdersResponse> {
    return this.rpc.unary(
      MsgBatchCreateDerivativeLimitOrdersDesc,
      MsgBatchCreateDerivativeLimitOrders.fromPartial(request),
      metadata,
    );
  }

  CreateDerivativeMarketOrder(
    request: DeepPartial<MsgCreateDerivativeMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateDerivativeMarketOrderResponse> {
    return this.rpc.unary(
      MsgCreateDerivativeMarketOrderDesc,
      MsgCreateDerivativeMarketOrder.fromPartial(request),
      metadata,
    );
  }

  CancelDerivativeOrder(
    request: DeepPartial<MsgCancelDerivativeOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelDerivativeOrderResponse> {
    return this.rpc.unary(MsgCancelDerivativeOrderDesc, MsgCancelDerivativeOrder.fromPartial(request), metadata);
  }

  BatchCancelDerivativeOrders(
    request: DeepPartial<MsgBatchCancelDerivativeOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelDerivativeOrdersResponse> {
    return this.rpc.unary(
      MsgBatchCancelDerivativeOrdersDesc,
      MsgBatchCancelDerivativeOrders.fromPartial(request),
      metadata,
    );
  }

  InstantBinaryOptionsMarketLaunch(
    request: DeepPartial<MsgInstantBinaryOptionsMarketLaunch>,
    metadata?: grpc.Metadata,
  ): Promise<MsgInstantBinaryOptionsMarketLaunchResponse> {
    return this.rpc.unary(
      MsgInstantBinaryOptionsMarketLaunchDesc,
      MsgInstantBinaryOptionsMarketLaunch.fromPartial(request),
      metadata,
    );
  }

  CreateBinaryOptionsLimitOrder(
    request: DeepPartial<MsgCreateBinaryOptionsLimitOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateBinaryOptionsLimitOrderResponse> {
    return this.rpc.unary(
      MsgCreateBinaryOptionsLimitOrderDesc,
      MsgCreateBinaryOptionsLimitOrder.fromPartial(request),
      metadata,
    );
  }

  CreateBinaryOptionsMarketOrder(
    request: DeepPartial<MsgCreateBinaryOptionsMarketOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCreateBinaryOptionsMarketOrderResponse> {
    return this.rpc.unary(
      MsgCreateBinaryOptionsMarketOrderDesc,
      MsgCreateBinaryOptionsMarketOrder.fromPartial(request),
      metadata,
    );
  }

  CancelBinaryOptionsOrder(
    request: DeepPartial<MsgCancelBinaryOptionsOrder>,
    metadata?: grpc.Metadata,
  ): Promise<MsgCancelBinaryOptionsOrderResponse> {
    return this.rpc.unary(MsgCancelBinaryOptionsOrderDesc, MsgCancelBinaryOptionsOrder.fromPartial(request), metadata);
  }

  BatchCancelBinaryOptionsOrders(
    request: DeepPartial<MsgBatchCancelBinaryOptionsOrders>,
    metadata?: grpc.Metadata,
  ): Promise<MsgBatchCancelBinaryOptionsOrdersResponse> {
    return this.rpc.unary(
      MsgBatchCancelBinaryOptionsOrdersDesc,
      MsgBatchCancelBinaryOptionsOrders.fromPartial(request),
      metadata,
    );
  }

  SubaccountTransfer(
    request: DeepPartial<MsgSubaccountTransfer>,
    metadata?: grpc.Metadata,
  ): Promise<MsgSubaccountTransferResponse> {
    return this.rpc.unary(MsgSubaccountTransferDesc, MsgSubaccountTransfer.fromPartial(request), metadata);
  }

  ExternalTransfer(
    request: DeepPartial<MsgExternalTransfer>,
    metadata?: grpc.Metadata,
  ): Promise<MsgExternalTransferResponse> {
    return this.rpc.unary(MsgExternalTransferDesc, MsgExternalTransfer.fromPartial(request), metadata);
  }

  LiquidatePosition(
    request: DeepPartial<MsgLiquidatePosition>,
    metadata?: grpc.Metadata,
  ): Promise<MsgLiquidatePositionResponse> {
    return this.rpc.unary(MsgLiquidatePositionDesc, MsgLiquidatePosition.fromPartial(request), metadata);
  }

  IncreasePositionMargin(
    request: DeepPartial<MsgIncreasePositionMargin>,
    metadata?: grpc.Metadata,
  ): Promise<MsgIncreasePositionMarginResponse> {
    return this.rpc.unary(MsgIncreasePositionMarginDesc, MsgIncreasePositionMargin.fromPartial(request), metadata);
  }

  RewardsOptOut(request: DeepPartial<MsgRewardsOptOut>, metadata?: grpc.Metadata): Promise<MsgRewardsOptOutResponse> {
    return this.rpc.unary(MsgRewardsOptOutDesc, MsgRewardsOptOut.fromPartial(request), metadata);
  }

  AdminUpdateBinaryOptionsMarket(
    request: DeepPartial<MsgAdminUpdateBinaryOptionsMarket>,
    metadata?: grpc.Metadata,
  ): Promise<MsgAdminUpdateBinaryOptionsMarketResponse> {
    return this.rpc.unary(
      MsgAdminUpdateBinaryOptionsMarketDesc,
      MsgAdminUpdateBinaryOptionsMarket.fromPartial(request),
      metadata,
    );
  }

  ReclaimLockedFunds(
    request: DeepPartial<MsgReclaimLockedFunds>,
    metadata?: grpc.Metadata,
  ): Promise<MsgReclaimLockedFundsResponse> {
    return this.rpc.unary(MsgReclaimLockedFundsDesc, MsgReclaimLockedFunds.fromPartial(request), metadata);
  }
}

export const MsgDesc = { serviceName: "injective.exchange.v1beta1.Msg" };

export const MsgDepositDesc: UnaryMethodDefinitionish = {
  methodName: "Deposit",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgDeposit.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgDepositResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgWithdrawDesc: UnaryMethodDefinitionish = {
  methodName: "Withdraw",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgWithdraw.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgWithdrawResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgInstantSpotMarketLaunchDesc: UnaryMethodDefinitionish = {
  methodName: "InstantSpotMarketLaunch",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgInstantSpotMarketLaunch.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgInstantSpotMarketLaunchResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgInstantPerpetualMarketLaunchDesc: UnaryMethodDefinitionish = {
  methodName: "InstantPerpetualMarketLaunch",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgInstantPerpetualMarketLaunch.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgInstantPerpetualMarketLaunchResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgInstantExpiryFuturesMarketLaunchDesc: UnaryMethodDefinitionish = {
  methodName: "InstantExpiryFuturesMarketLaunch",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgInstantExpiryFuturesMarketLaunch.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgInstantExpiryFuturesMarketLaunchResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateSpotLimitOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateSpotLimitOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateSpotLimitOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateSpotLimitOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchCreateSpotLimitOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchCreateSpotLimitOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchCreateSpotLimitOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchCreateSpotLimitOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateSpotMarketOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateSpotMarketOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateSpotMarketOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateSpotMarketOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCancelSpotOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CancelSpotOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCancelSpotOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCancelSpotOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchCancelSpotOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchCancelSpotOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchCancelSpotOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchCancelSpotOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchUpdateOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchUpdateOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchUpdateOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchUpdateOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgPrivilegedExecuteContractDesc: UnaryMethodDefinitionish = {
  methodName: "PrivilegedExecuteContract",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgPrivilegedExecuteContract.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgPrivilegedExecuteContractResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateDerivativeLimitOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateDerivativeLimitOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateDerivativeLimitOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateDerivativeLimitOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchCreateDerivativeLimitOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchCreateDerivativeLimitOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchCreateDerivativeLimitOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchCreateDerivativeLimitOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateDerivativeMarketOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateDerivativeMarketOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateDerivativeMarketOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateDerivativeMarketOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCancelDerivativeOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CancelDerivativeOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCancelDerivativeOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCancelDerivativeOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchCancelDerivativeOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchCancelDerivativeOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchCancelDerivativeOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchCancelDerivativeOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgInstantBinaryOptionsMarketLaunchDesc: UnaryMethodDefinitionish = {
  methodName: "InstantBinaryOptionsMarketLaunch",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgInstantBinaryOptionsMarketLaunch.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgInstantBinaryOptionsMarketLaunchResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateBinaryOptionsLimitOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateBinaryOptionsLimitOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateBinaryOptionsLimitOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateBinaryOptionsLimitOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCreateBinaryOptionsMarketOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CreateBinaryOptionsMarketOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCreateBinaryOptionsMarketOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCreateBinaryOptionsMarketOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgCancelBinaryOptionsOrderDesc: UnaryMethodDefinitionish = {
  methodName: "CancelBinaryOptionsOrder",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgCancelBinaryOptionsOrder.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgCancelBinaryOptionsOrderResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgBatchCancelBinaryOptionsOrdersDesc: UnaryMethodDefinitionish = {
  methodName: "BatchCancelBinaryOptionsOrders",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgBatchCancelBinaryOptionsOrders.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgBatchCancelBinaryOptionsOrdersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgSubaccountTransferDesc: UnaryMethodDefinitionish = {
  methodName: "SubaccountTransfer",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgSubaccountTransfer.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgSubaccountTransferResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgExternalTransferDesc: UnaryMethodDefinitionish = {
  methodName: "ExternalTransfer",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgExternalTransfer.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgExternalTransferResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgLiquidatePositionDesc: UnaryMethodDefinitionish = {
  methodName: "LiquidatePosition",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgLiquidatePosition.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgLiquidatePositionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgIncreasePositionMarginDesc: UnaryMethodDefinitionish = {
  methodName: "IncreasePositionMargin",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgIncreasePositionMargin.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgIncreasePositionMarginResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgRewardsOptOutDesc: UnaryMethodDefinitionish = {
  methodName: "RewardsOptOut",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgRewardsOptOut.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgRewardsOptOutResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgAdminUpdateBinaryOptionsMarketDesc: UnaryMethodDefinitionish = {
  methodName: "AdminUpdateBinaryOptionsMarket",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgAdminUpdateBinaryOptionsMarket.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgAdminUpdateBinaryOptionsMarketResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgReclaimLockedFundsDesc: UnaryMethodDefinitionish = {
  methodName: "ReclaimLockedFunds",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgReclaimLockedFunds.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgReclaimLockedFundsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends tsProtoGlobalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
