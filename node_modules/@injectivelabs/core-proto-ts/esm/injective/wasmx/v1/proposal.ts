/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { StoreCodeProposal } from "../../../cosmwasm/wasm/v1/proposal";

export interface ContractRegistrationRequestProposal {
  title: string;
  description: string;
  contractRegistrationRequest: ContractRegistrationRequest | undefined;
}

export interface BatchContractRegistrationRequestProposal {
  title: string;
  description: string;
  contractRegistrationRequests: ContractRegistrationRequest[];
}

export interface BatchContractDeregistrationProposal {
  title: string;
  description: string;
  contracts: string[];
}

export interface ContractRegistrationRequest {
  /** Unique Identifier for contract instance to be registered. */
  contractAddress: string;
  /** Maximum gas to be used for the smart contract execution. */
  gasLimit: string;
  /** gas price to be used for the smart contract execution. */
  gasPrice: string;
  shouldPinContract: boolean;
  /** if true contract owner can update it, if false only current code_id will be allowed to be executed */
  isMigrationAllowed: boolean;
  /** code_id of the contract being registered - will be verified upon every execution but only if is_migration_allowed is false */
  codeId: string;
  /** Optional address of admin account (that will be allowed to pause or update contract params) */
  adminAddress: string;
}

export interface BatchStoreCodeProposal {
  title: string;
  description: string;
  proposals: StoreCodeProposal[];
}

function createBaseContractRegistrationRequestProposal(): ContractRegistrationRequestProposal {
  return { title: "", description: "", contractRegistrationRequest: undefined };
}

export const ContractRegistrationRequestProposal = {
  encode(message: ContractRegistrationRequestProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.contractRegistrationRequest !== undefined) {
      ContractRegistrationRequest.encode(message.contractRegistrationRequest, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractRegistrationRequestProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractRegistrationRequestProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.contractRegistrationRequest = ContractRegistrationRequest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ContractRegistrationRequestProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contractRegistrationRequest: isSet(object.contractRegistrationRequest)
        ? ContractRegistrationRequest.fromJSON(object.contractRegistrationRequest)
        : undefined,
    };
  },

  toJSON(message: ContractRegistrationRequestProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.contractRegistrationRequest !== undefined &&
      (obj.contractRegistrationRequest = message.contractRegistrationRequest
        ? ContractRegistrationRequest.toJSON(message.contractRegistrationRequest)
        : undefined);
    return obj;
  },

  create(base?: DeepPartial<ContractRegistrationRequestProposal>): ContractRegistrationRequestProposal {
    return ContractRegistrationRequestProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ContractRegistrationRequestProposal>): ContractRegistrationRequestProposal {
    const message = createBaseContractRegistrationRequestProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.contractRegistrationRequest =
      (object.contractRegistrationRequest !== undefined && object.contractRegistrationRequest !== null)
        ? ContractRegistrationRequest.fromPartial(object.contractRegistrationRequest)
        : undefined;
    return message;
  },
};

function createBaseBatchContractRegistrationRequestProposal(): BatchContractRegistrationRequestProposal {
  return { title: "", description: "", contractRegistrationRequests: [] };
}

export const BatchContractRegistrationRequestProposal = {
  encode(message: BatchContractRegistrationRequestProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.contractRegistrationRequests) {
      ContractRegistrationRequest.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchContractRegistrationRequestProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchContractRegistrationRequestProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.contractRegistrationRequests.push(ContractRegistrationRequest.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BatchContractRegistrationRequestProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contractRegistrationRequests: Array.isArray(object?.contractRegistrationRequests)
        ? object.contractRegistrationRequests.map((e: any) => ContractRegistrationRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchContractRegistrationRequestProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.contractRegistrationRequests) {
      obj.contractRegistrationRequests = message.contractRegistrationRequests.map((e) =>
        e ? ContractRegistrationRequest.toJSON(e) : undefined
      );
    } else {
      obj.contractRegistrationRequests = [];
    }
    return obj;
  },

  create(base?: DeepPartial<BatchContractRegistrationRequestProposal>): BatchContractRegistrationRequestProposal {
    return BatchContractRegistrationRequestProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BatchContractRegistrationRequestProposal>): BatchContractRegistrationRequestProposal {
    const message = createBaseBatchContractRegistrationRequestProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.contractRegistrationRequests =
      object.contractRegistrationRequests?.map((e) => ContractRegistrationRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchContractDeregistrationProposal(): BatchContractDeregistrationProposal {
  return { title: "", description: "", contracts: [] };
}

export const BatchContractDeregistrationProposal = {
  encode(message: BatchContractDeregistrationProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.contracts) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchContractDeregistrationProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchContractDeregistrationProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.contracts.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BatchContractDeregistrationProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      contracts: Array.isArray(object?.contracts) ? object.contracts.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: BatchContractDeregistrationProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.contracts) {
      obj.contracts = message.contracts.map((e) => e);
    } else {
      obj.contracts = [];
    }
    return obj;
  },

  create(base?: DeepPartial<BatchContractDeregistrationProposal>): BatchContractDeregistrationProposal {
    return BatchContractDeregistrationProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BatchContractDeregistrationProposal>): BatchContractDeregistrationProposal {
    const message = createBaseBatchContractDeregistrationProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.contracts = object.contracts?.map((e) => e) || [];
    return message;
  },
};

function createBaseContractRegistrationRequest(): ContractRegistrationRequest {
  return {
    contractAddress: "",
    gasLimit: "0",
    gasPrice: "0",
    shouldPinContract: false,
    isMigrationAllowed: false,
    codeId: "0",
    adminAddress: "",
  };
}

export const ContractRegistrationRequest = {
  encode(message: ContractRegistrationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.gasLimit !== "0") {
      writer.uint32(16).uint64(message.gasLimit);
    }
    if (message.gasPrice !== "0") {
      writer.uint32(24).uint64(message.gasPrice);
    }
    if (message.shouldPinContract === true) {
      writer.uint32(32).bool(message.shouldPinContract);
    }
    if (message.isMigrationAllowed === true) {
      writer.uint32(40).bool(message.isMigrationAllowed);
    }
    if (message.codeId !== "0") {
      writer.uint32(48).uint64(message.codeId);
    }
    if (message.adminAddress !== "") {
      writer.uint32(58).string(message.adminAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractRegistrationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.contractAddress = reader.string();
          break;
        case 2:
          message.gasLimit = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.gasPrice = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.shouldPinContract = reader.bool();
          break;
        case 5:
          message.isMigrationAllowed = reader.bool();
          break;
        case 6:
          message.codeId = longToString(reader.uint64() as Long);
          break;
        case 7:
          message.adminAddress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ContractRegistrationRequest {
    return {
      contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
      gasLimit: isSet(object.gasLimit) ? String(object.gasLimit) : "0",
      gasPrice: isSet(object.gasPrice) ? String(object.gasPrice) : "0",
      shouldPinContract: isSet(object.shouldPinContract) ? Boolean(object.shouldPinContract) : false,
      isMigrationAllowed: isSet(object.isMigrationAllowed) ? Boolean(object.isMigrationAllowed) : false,
      codeId: isSet(object.codeId) ? String(object.codeId) : "0",
      adminAddress: isSet(object.adminAddress) ? String(object.adminAddress) : "",
    };
  },

  toJSON(message: ContractRegistrationRequest): unknown {
    const obj: any = {};
    message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
    message.gasLimit !== undefined && (obj.gasLimit = message.gasLimit);
    message.gasPrice !== undefined && (obj.gasPrice = message.gasPrice);
    message.shouldPinContract !== undefined && (obj.shouldPinContract = message.shouldPinContract);
    message.isMigrationAllowed !== undefined && (obj.isMigrationAllowed = message.isMigrationAllowed);
    message.codeId !== undefined && (obj.codeId = message.codeId);
    message.adminAddress !== undefined && (obj.adminAddress = message.adminAddress);
    return obj;
  },

  create(base?: DeepPartial<ContractRegistrationRequest>): ContractRegistrationRequest {
    return ContractRegistrationRequest.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<ContractRegistrationRequest>): ContractRegistrationRequest {
    const message = createBaseContractRegistrationRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.gasLimit = object.gasLimit ?? "0";
    message.gasPrice = object.gasPrice ?? "0";
    message.shouldPinContract = object.shouldPinContract ?? false;
    message.isMigrationAllowed = object.isMigrationAllowed ?? false;
    message.codeId = object.codeId ?? "0";
    message.adminAddress = object.adminAddress ?? "";
    return message;
  },
};

function createBaseBatchStoreCodeProposal(): BatchStoreCodeProposal {
  return { title: "", description: "", proposals: [] };
}

export const BatchStoreCodeProposal = {
  encode(message: BatchStoreCodeProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.proposals) {
      StoreCodeProposal.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchStoreCodeProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchStoreCodeProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.proposals.push(StoreCodeProposal.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BatchStoreCodeProposal {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      proposals: Array.isArray(object?.proposals)
        ? object.proposals.map((e: any) => StoreCodeProposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchStoreCodeProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    if (message.proposals) {
      obj.proposals = message.proposals.map((e) => e ? StoreCodeProposal.toJSON(e) : undefined);
    } else {
      obj.proposals = [];
    }
    return obj;
  },

  create(base?: DeepPartial<BatchStoreCodeProposal>): BatchStoreCodeProposal {
    return BatchStoreCodeProposal.fromPartial(base ?? {});
  },

  fromPartial(object: DeepPartial<BatchStoreCodeProposal>): BatchStoreCodeProposal {
    const message = createBaseBatchStoreCodeProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.proposals = object.proposals?.map((e) => StoreCodeProposal.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
