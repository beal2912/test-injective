// package: ninja_api
// file: goadesign_goagen_ninja_api.proto

import * as jspb from "google-protobuf";

export class GetVaultsRequest extends jspb.Message {
  hasPageSize(): boolean;
  clearPageSize(): void;
  getPageSize(): number;
  setPageSize(value: number): void;

  hasPageIndex(): boolean;
  clearPageIndex(): void;
  getPageIndex(): number;
  setPageIndex(value: number): void;

  hasCodeId(): boolean;
  clearCodeId(): void;
  getCodeId(): number;
  setCodeId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVaultsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetVaultsRequest): GetVaultsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVaultsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVaultsRequest;
  static deserializeBinaryFromReader(message: GetVaultsRequest, reader: jspb.BinaryReader): GetVaultsRequest;
}

export namespace GetVaultsRequest {
  export type AsObject = {
    pageSize: number,
    pageIndex: number,
    codeId: number,
  }
}

export class GetVaultsResponse extends jspb.Message {
  clearVaultsList(): void;
  getVaultsList(): Array<Vault>;
  setVaultsList(value: Array<Vault>): void;
  addVaults(value?: Vault, index?: number): Vault;

  hasPagination(): boolean;
  clearPagination(): void;
  getPagination(): Pagination | undefined;
  setPagination(value?: Pagination): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVaultsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetVaultsResponse): GetVaultsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVaultsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVaultsResponse;
  static deserializeBinaryFromReader(message: GetVaultsResponse, reader: jspb.BinaryReader): GetVaultsResponse;
}

export namespace GetVaultsResponse {
  export type AsObject = {
    vaultsList: Array<Vault.AsObject>,
    pagination?: Pagination.AsObject,
  }
}

export class Vault extends jspb.Message {
  getContractAddress(): string;
  setContractAddress(value: string): void;

  getCodeId(): number;
  setCodeId(value: number): void;

  getVaultName(): string;
  setVaultName(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getCurrentTvl(): number;
  setCurrentTvl(value: number): void;

  hasProfits(): boolean;
  clearProfits(): void;
  getProfits(): Profits | undefined;
  setProfits(value?: Profits): void;

  getUpdatedAt(): number;
  setUpdatedAt(value: number): void;

  getVaultType(): string;
  setVaultType(value: string): void;

  getLpTokenPrice(): number;
  setLpTokenPrice(value: number): void;

  hasSubaccountInfo(): boolean;
  clearSubaccountInfo(): void;
  getSubaccountInfo(): SubaccountBalance | undefined;
  setSubaccountInfo(value?: SubaccountBalance): void;

  getMasterContractAddress(): string;
  setMasterContractAddress(value: string): void;

  getTotalLpAmount(): string;
  setTotalLpAmount(value: string): void;

  getSlug(): string;
  setSlug(value: string): void;

  getRedemptionLockTimeDuration(): number;
  setRedemptionLockTimeDuration(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Vault.AsObject;
  static toObject(includeInstance: boolean, msg: Vault): Vault.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Vault, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Vault;
  static deserializeBinaryFromReader(message: Vault, reader: jspb.BinaryReader): Vault;
}

export namespace Vault {
  export type AsObject = {
    contractAddress: string,
    codeId: number,
    vaultName: string,
    marketId: string,
    currentTvl: number,
    profits?: Profits.AsObject,
    updatedAt: number,
    vaultType: string,
    lpTokenPrice: number,
    subaccountInfo?: SubaccountBalance.AsObject,
    masterContractAddress: string,
    totalLpAmount: string,
    slug: string,
    redemptionLockTimeDuration: number,
  }
}

export class Profits extends jspb.Message {
  getAllTimeChange(): number;
  setAllTimeChange(value: number): void;

  getThreeMonthsChange(): number;
  setThreeMonthsChange(value: number): void;

  getOneMonthChange(): number;
  setOneMonthChange(value: number): void;

  getOneDayChange(): number;
  setOneDayChange(value: number): void;

  getOneWeekChange(): number;
  setOneWeekChange(value: number): void;

  getOneYearChange(): number;
  setOneYearChange(value: number): void;

  getThreeYearsChange(): number;
  setThreeYearsChange(value: number): void;

  getSixMonthsChange(): number;
  setSixMonthsChange(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Profits.AsObject;
  static toObject(includeInstance: boolean, msg: Profits): Profits.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Profits, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Profits;
  static deserializeBinaryFromReader(message: Profits, reader: jspb.BinaryReader): Profits;
}

export namespace Profits {
  export type AsObject = {
    allTimeChange: number,
    threeMonthsChange: number,
    oneMonthChange: number,
    oneDayChange: number,
    oneWeekChange: number,
    oneYearChange: number,
    threeYearsChange: number,
    sixMonthsChange: number,
  }
}

export class SubaccountBalance extends jspb.Message {
  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  clearBalancesList(): void;
  getBalancesList(): Array<DenomBalance>;
  setBalancesList(value: Array<DenomBalance>): void;
  addBalances(value?: DenomBalance, index?: number): DenomBalance;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountBalance.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountBalance): SubaccountBalance.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountBalance, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountBalance;
  static deserializeBinaryFromReader(message: SubaccountBalance, reader: jspb.BinaryReader): SubaccountBalance;
}

export namespace SubaccountBalance {
  export type AsObject = {
    subaccountId: string,
    balancesList: Array<DenomBalance.AsObject>,
  }
}

export class DenomBalance extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  getTotalBalance(): string;
  setTotalBalance(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DenomBalance.AsObject;
  static toObject(includeInstance: boolean, msg: DenomBalance): DenomBalance.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DenomBalance, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DenomBalance;
  static deserializeBinaryFromReader(message: DenomBalance, reader: jspb.BinaryReader): DenomBalance;
}

export namespace DenomBalance {
  export type AsObject = {
    denom: string,
    totalBalance: string,
  }
}

export class Pagination extends jspb.Message {
  getTotal(): number;
  setTotal(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Pagination.AsObject;
  static toObject(includeInstance: boolean, msg: Pagination): Pagination.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Pagination, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Pagination;
  static deserializeBinaryFromReader(message: Pagination, reader: jspb.BinaryReader): Pagination;
}

export namespace Pagination {
  export type AsObject = {
    total: number,
  }
}

export class GetVaultRequest extends jspb.Message {
  hasContractAddress(): boolean;
  clearContractAddress(): void;
  getContractAddress(): string;
  setContractAddress(value: string): void;

  hasSlug(): boolean;
  clearSlug(): void;
  getSlug(): string;
  setSlug(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVaultRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetVaultRequest): GetVaultRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVaultRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVaultRequest;
  static deserializeBinaryFromReader(message: GetVaultRequest, reader: jspb.BinaryReader): GetVaultRequest;
}

export namespace GetVaultRequest {
  export type AsObject = {
    contractAddress: string,
    slug: string,
  }
}

export class GetVaultResponse extends jspb.Message {
  clearVaultList(): void;
  getVaultList(): Array<Vault>;
  setVaultList(value: Array<Vault>): void;
  addVault(value?: Vault, index?: number): Vault;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVaultResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetVaultResponse): GetVaultResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVaultResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVaultResponse;
  static deserializeBinaryFromReader(message: GetVaultResponse, reader: jspb.BinaryReader): GetVaultResponse;
}

export namespace GetVaultResponse {
  export type AsObject = {
    vaultList: Array<Vault.AsObject>,
  }
}

export class LPTokenPriceChartRequest extends jspb.Message {
  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  hasFromTime(): boolean;
  clearFromTime(): void;
  getFromTime(): number;
  setFromTime(value: number): void;

  hasToTime(): boolean;
  clearToTime(): void;
  getToTime(): number;
  setToTime(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LPTokenPriceChartRequest.AsObject;
  static toObject(includeInstance: boolean, msg: LPTokenPriceChartRequest): LPTokenPriceChartRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LPTokenPriceChartRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LPTokenPriceChartRequest;
  static deserializeBinaryFromReader(message: LPTokenPriceChartRequest, reader: jspb.BinaryReader): LPTokenPriceChartRequest;
}

export namespace LPTokenPriceChartRequest {
  export type AsObject = {
    vaultAddress: string,
    fromTime: number,
    toTime: number,
  }
}

export class LPTokenPriceChartResponse extends jspb.Message {
  clearPricesList(): void;
  getPricesList(): Array<PriceSnapshot>;
  setPricesList(value: Array<PriceSnapshot>): void;
  addPrices(value?: PriceSnapshot, index?: number): PriceSnapshot;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LPTokenPriceChartResponse.AsObject;
  static toObject(includeInstance: boolean, msg: LPTokenPriceChartResponse): LPTokenPriceChartResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LPTokenPriceChartResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LPTokenPriceChartResponse;
  static deserializeBinaryFromReader(message: LPTokenPriceChartResponse, reader: jspb.BinaryReader): LPTokenPriceChartResponse;
}

export namespace LPTokenPriceChartResponse {
  export type AsObject = {
    pricesList: Array<PriceSnapshot.AsObject>,
  }
}

export class PriceSnapshot extends jspb.Message {
  getPrice(): number;
  setPrice(value: number): void;

  getUpdatedAt(): number;
  setUpdatedAt(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PriceSnapshot.AsObject;
  static toObject(includeInstance: boolean, msg: PriceSnapshot): PriceSnapshot.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PriceSnapshot, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PriceSnapshot;
  static deserializeBinaryFromReader(message: PriceSnapshot, reader: jspb.BinaryReader): PriceSnapshot;
}

export namespace PriceSnapshot {
  export type AsObject = {
    price: number,
    updatedAt: number,
  }
}

export class TVLChartRequest extends jspb.Message {
  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  hasFromTime(): boolean;
  clearFromTime(): void;
  getFromTime(): number;
  setFromTime(value: number): void;

  hasToTime(): boolean;
  clearToTime(): void;
  getToTime(): number;
  setToTime(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TVLChartRequest.AsObject;
  static toObject(includeInstance: boolean, msg: TVLChartRequest): TVLChartRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TVLChartRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TVLChartRequest;
  static deserializeBinaryFromReader(message: TVLChartRequest, reader: jspb.BinaryReader): TVLChartRequest;
}

export namespace TVLChartRequest {
  export type AsObject = {
    vaultAddress: string,
    fromTime: number,
    toTime: number,
  }
}

export class TVLChartResponse extends jspb.Message {
  clearPricesList(): void;
  getPricesList(): Array<PriceSnapshot>;
  setPricesList(value: Array<PriceSnapshot>): void;
  addPrices(value?: PriceSnapshot, index?: number): PriceSnapshot;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TVLChartResponse.AsObject;
  static toObject(includeInstance: boolean, msg: TVLChartResponse): TVLChartResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TVLChartResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TVLChartResponse;
  static deserializeBinaryFromReader(message: TVLChartResponse, reader: jspb.BinaryReader): TVLChartResponse;
}

export namespace TVLChartResponse {
  export type AsObject = {
    pricesList: Array<PriceSnapshot.AsObject>,
  }
}

export class VaultsByHolderAddressRequest extends jspb.Message {
  hasPageSize(): boolean;
  clearPageSize(): void;
  getPageSize(): number;
  setPageSize(value: number): void;

  hasPageIndex(): boolean;
  clearPageIndex(): void;
  getPageIndex(): number;
  setPageIndex(value: number): void;

  getHolderAddress(): string;
  setHolderAddress(value: string): void;

  hasVaultAddress(): boolean;
  clearVaultAddress(): void;
  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): VaultsByHolderAddressRequest.AsObject;
  static toObject(includeInstance: boolean, msg: VaultsByHolderAddressRequest): VaultsByHolderAddressRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VaultsByHolderAddressRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VaultsByHolderAddressRequest;
  static deserializeBinaryFromReader(message: VaultsByHolderAddressRequest, reader: jspb.BinaryReader): VaultsByHolderAddressRequest;
}

export namespace VaultsByHolderAddressRequest {
  export type AsObject = {
    pageSize: number,
    pageIndex: number,
    holderAddress: string,
    vaultAddress: string,
  }
}

export class VaultsByHolderAddressResponse extends jspb.Message {
  clearSubscriptionsList(): void;
  getSubscriptionsList(): Array<Subscription>;
  setSubscriptionsList(value: Array<Subscription>): void;
  addSubscriptions(value?: Subscription, index?: number): Subscription;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): VaultsByHolderAddressResponse.AsObject;
  static toObject(includeInstance: boolean, msg: VaultsByHolderAddressResponse): VaultsByHolderAddressResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: VaultsByHolderAddressResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): VaultsByHolderAddressResponse;
  static deserializeBinaryFromReader(message: VaultsByHolderAddressResponse, reader: jspb.BinaryReader): VaultsByHolderAddressResponse;
}

export namespace VaultsByHolderAddressResponse {
  export type AsObject = {
    subscriptionsList: Array<Subscription.AsObject>,
  }
}

export class Subscription extends jspb.Message {
  hasVaultInfo(): boolean;
  clearVaultInfo(): void;
  getVaultInfo(): Vault | undefined;
  setVaultInfo(value?: Vault): void;

  getLpAmount(): string;
  setLpAmount(value: string): void;

  getHolderAddress(): string;
  setHolderAddress(value: string): void;

  getLpAmountPercentage(): number;
  setLpAmountPercentage(value: number): void;

  getRedemptionLockTime(): number;
  setRedemptionLockTime(value: number): void;

  getLockedAmount(): string;
  setLockedAmount(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Subscription.AsObject;
  static toObject(includeInstance: boolean, msg: Subscription): Subscription.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Subscription, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Subscription;
  static deserializeBinaryFromReader(message: Subscription, reader: jspb.BinaryReader): Subscription;
}

export namespace Subscription {
  export type AsObject = {
    vaultInfo?: Vault.AsObject,
    lpAmount: string,
    holderAddress: string,
    lpAmountPercentage: number,
    redemptionLockTime: number,
    lockedAmount: string,
  }
}

export class LPHoldersRequest extends jspb.Message {
  hasPageSize(): boolean;
  clearPageSize(): void;
  getPageSize(): number;
  setPageSize(value: number): void;

  hasPageIndex(): boolean;
  clearPageIndex(): void;
  getPageIndex(): number;
  setPageIndex(value: number): void;

  hasVaultAddress(): boolean;
  clearVaultAddress(): void;
  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LPHoldersRequest.AsObject;
  static toObject(includeInstance: boolean, msg: LPHoldersRequest): LPHoldersRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LPHoldersRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LPHoldersRequest;
  static deserializeBinaryFromReader(message: LPHoldersRequest, reader: jspb.BinaryReader): LPHoldersRequest;
}

export namespace LPHoldersRequest {
  export type AsObject = {
    pageSize: number,
    pageIndex: number,
    vaultAddress: string,
  }
}

export class LPHoldersResponse extends jspb.Message {
  clearHoldersList(): void;
  getHoldersList(): Array<Holders>;
  setHoldersList(value: Array<Holders>): void;
  addHolders(value?: Holders, index?: number): Holders;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LPHoldersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: LPHoldersResponse): LPHoldersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LPHoldersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LPHoldersResponse;
  static deserializeBinaryFromReader(message: LPHoldersResponse, reader: jspb.BinaryReader): LPHoldersResponse;
}

export namespace LPHoldersResponse {
  export type AsObject = {
    holdersList: Array<Holders.AsObject>,
  }
}

export class Holders extends jspb.Message {
  getHolderAddress(): string;
  setHolderAddress(value: string): void;

  getVaultAddress(): string;
  setVaultAddress(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  getUpdatedAt(): number;
  setUpdatedAt(value: number): void;

  getLpAmountPercentage(): number;
  setLpAmountPercentage(value: number): void;

  getRedemptionLockTime(): number;
  setRedemptionLockTime(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Holders.AsObject;
  static toObject(includeInstance: boolean, msg: Holders): Holders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Holders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Holders;
  static deserializeBinaryFromReader(message: Holders, reader: jspb.BinaryReader): Holders;
}

export namespace Holders {
  export type AsObject = {
    holderAddress: string,
    vaultAddress: string,
    amount: string,
    updatedAt: number,
    lpAmountPercentage: number,
    redemptionLockTime: number,
  }
}

export class PortfolioRequest extends jspb.Message {
  getHolderAddress(): string;
  setHolderAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PortfolioRequest.AsObject;
  static toObject(includeInstance: boolean, msg: PortfolioRequest): PortfolioRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PortfolioRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PortfolioRequest;
  static deserializeBinaryFromReader(message: PortfolioRequest, reader: jspb.BinaryReader): PortfolioRequest;
}

export namespace PortfolioRequest {
  export type AsObject = {
    holderAddress: string,
  }
}

export class PortfolioResponse extends jspb.Message {
  getTotalValue(): number;
  setTotalValue(value: number): void;

  getPnl(): number;
  setPnl(value: number): void;

  clearTotalValueChartList(): void;
  getTotalValueChartList(): Array<PriceSnapshot>;
  setTotalValueChartList(value: Array<PriceSnapshot>): void;
  addTotalValueChart(value?: PriceSnapshot, index?: number): PriceSnapshot;

  clearPnlChartList(): void;
  getPnlChartList(): Array<PriceSnapshot>;
  setPnlChartList(value: Array<PriceSnapshot>): void;
  addPnlChart(value?: PriceSnapshot, index?: number): PriceSnapshot;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PortfolioResponse.AsObject;
  static toObject(includeInstance: boolean, msg: PortfolioResponse): PortfolioResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PortfolioResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PortfolioResponse;
  static deserializeBinaryFromReader(message: PortfolioResponse, reader: jspb.BinaryReader): PortfolioResponse;
}

export namespace PortfolioResponse {
  export type AsObject = {
    totalValue: number,
    pnl: number,
    totalValueChartList: Array<PriceSnapshot.AsObject>,
    pnlChartList: Array<PriceSnapshot.AsObject>,
  }
}

export class LeaderboardRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LeaderboardRequest.AsObject;
  static toObject(includeInstance: boolean, msg: LeaderboardRequest): LeaderboardRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LeaderboardRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LeaderboardRequest;
  static deserializeBinaryFromReader(message: LeaderboardRequest, reader: jspb.BinaryReader): LeaderboardRequest;
}

export namespace LeaderboardRequest {
  export type AsObject = {
  }
}

export class LeaderboardResponse extends jspb.Message {
  clearEntriesList(): void;
  getEntriesList(): Array<LeaderboardEntry>;
  setEntriesList(value: Array<LeaderboardEntry>): void;
  addEntries(value?: LeaderboardEntry, index?: number): LeaderboardEntry;

  getSnapshotBlock(): number;
  setSnapshotBlock(value: number): void;

  getUpdatedAt(): number;
  setUpdatedAt(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LeaderboardResponse.AsObject;
  static toObject(includeInstance: boolean, msg: LeaderboardResponse): LeaderboardResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LeaderboardResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LeaderboardResponse;
  static deserializeBinaryFromReader(message: LeaderboardResponse, reader: jspb.BinaryReader): LeaderboardResponse;
}

export namespace LeaderboardResponse {
  export type AsObject = {
    entriesList: Array<LeaderboardEntry.AsObject>,
    snapshotBlock: number,
    updatedAt: number,
  }
}

export class LeaderboardEntry extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getPnl(): number;
  setPnl(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LeaderboardEntry.AsObject;
  static toObject(includeInstance: boolean, msg: LeaderboardEntry): LeaderboardEntry.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LeaderboardEntry, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LeaderboardEntry;
  static deserializeBinaryFromReader(message: LeaderboardEntry, reader: jspb.BinaryReader): LeaderboardEntry;
}

export namespace LeaderboardEntry {
  export type AsObject = {
    address: string,
    pnl: number,
  }
}

